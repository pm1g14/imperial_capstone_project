/// <reference types="bn.js" />
import { Connection, PublicKey, TransactionMessage, AddressLookupTableAccount, VersionedTransaction, TransactionInstruction } from '@solana/web3.js';
import { BN } from '@coral-xyz/anchor';
import { JupiterClient } from '../jupiter/jupiterClient';
import { TitanClient } from '../titan/titanClient';
export type SwapMode = 'ExactIn' | 'ExactOut';
export type SwapClientType = 'jupiter' | 'titan';
/**
 * Unified quote response interface that combines properties from both Jupiter and Titan
 * This provides a consistent interface while allowing for provider-specific fields
 */
export interface UnifiedQuoteResponse {
    inputMint: string;
    inAmount: string;
    outputMint: string;
    outAmount: string;
    swapMode: SwapMode;
    slippageBps: number;
    routePlan: Array<{
        swapInfo: any;
        percent: number;
    }>;
    otherAmountThreshold?: string;
    priceImpactPct?: string;
    platformFee?: {
        amount?: string;
        feeBps?: number;
    };
    contextSlot?: number;
    timeTaken?: number;
    error?: string;
    errorCode?: string;
}
export interface SwapQuoteParams {
    inputMint: PublicKey;
    outputMint: PublicKey;
    amount: BN;
    userPublicKey?: PublicKey;
    maxAccounts?: number;
    slippageBps?: number;
    swapMode?: SwapMode;
    onlyDirectRoutes?: boolean;
    excludeDexes?: string[];
    sizeConstraint?: number;
    accountsLimitWritable?: number;
    autoSlippage?: boolean;
    maxAutoSlippageBps?: number;
    usdEstimate?: number;
}
export interface SwapTransactionParams {
    quote: UnifiedQuoteResponse;
    userPublicKey: PublicKey;
    slippageBps?: number;
}
export interface SwapTransactionResult {
    transaction?: VersionedTransaction;
    transactionMessage?: TransactionMessage;
    lookupTables?: AddressLookupTableAccount[];
}
export declare class UnifiedSwapClient {
    private client;
    private clientType;
    constructor({ clientType, connection, authToken, url, proxyUrl, }: {
        clientType: SwapClientType;
        connection: Connection;
        authToken?: string;
        url?: string;
        proxyUrl?: string;
    });
    /**
     * Get a swap quote from the underlying client
     */
    getQuote(params: SwapQuoteParams): Promise<UnifiedQuoteResponse>;
    /**
     * Get a swap transaction from the underlying client
     */
    getSwap(params: SwapTransactionParams): Promise<SwapTransactionResult>;
    /**
     * Get swap instructions from the underlying client (Jupiter or Titan)
     * This is the core swap logic without any context preparation
     */
    getSwapInstructions({ inputMint, outputMint, amount, userPublicKey, slippageBps, swapMode, onlyDirectRoutes, quote, sizeConstraint, }: {
        inputMint: PublicKey;
        outputMint: PublicKey;
        amount: BN;
        userPublicKey: PublicKey;
        slippageBps?: number;
        swapMode?: SwapMode;
        onlyDirectRoutes?: boolean;
        quote?: UnifiedQuoteResponse;
        sizeConstraint?: number;
    }): Promise<{
        instructions: TransactionInstruction[];
        lookupTables: AddressLookupTableAccount[];
    }>;
    /**
     * Get the underlying client instance
     */
    getClient(): JupiterClient | TitanClient;
    /**
     * Get the client type
     */
    getClientType(): SwapClientType;
    /**
     * Check if this is a Jupiter client
     */
    isJupiter(): boolean;
    /**
     * Check if this is a Titan client
     */
    isTitan(): boolean;
}
