"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PollingConstituentAccountSubscriber = void 0;
const types_1 = require("../accounts/types");
const events_1 = require("events");
class PollingConstituentAccountSubscriber {
    constructor(constituentMap, program, frequency, commitment, additionalFilters) {
        this.constituentMap = constituentMap;
        this.isSubscribed = false;
        this.program = program;
        this.frequency = frequency;
        this.commitment = commitment;
        this.additionalFilters = additionalFilters;
        this.eventEmitter = new events_1.EventEmitter();
    }
    async subscribe() {
        if (this.isSubscribed || this.frequency <= 0) {
            return true;
        }
        const executeSync = async () => {
            await this.sync();
            this.intervalId = setTimeout(executeSync, this.frequency);
        };
        // Initial sync
        await this.sync();
        // Start polling
        this.intervalId = setTimeout(executeSync, this.frequency);
        this.isSubscribed = true;
        return true;
    }
    async sync() {
        try {
            await this.constituentMap.sync();
            this.eventEmitter.emit('update');
        }
        catch (error) {
            console.log(`PollingConstituentAccountSubscriber.sync() error: ${error.message}`);
            this.eventEmitter.emit('error', error);
        }
    }
    async unsubscribe() {
        if (!this.isSubscribed) {
            return;
        }
        if (this.intervalId) {
            clearTimeout(this.intervalId);
            this.intervalId = undefined;
        }
        this.isSubscribed = false;
    }
    assertIsSubscribed() {
        if (!this.isSubscribed) {
            throw new types_1.NotSubscribedError('You must call `subscribe` before using this function');
        }
    }
    didSubscriptionSucceed() {
        return this.isSubscribed;
    }
}
exports.PollingConstituentAccountSubscriber = PollingConstituentAccountSubscriber;
