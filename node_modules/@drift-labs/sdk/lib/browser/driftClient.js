"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriftClient = void 0;
const anchor = __importStar(require("@coral-xyz/anchor"));
const anchor_1 = require("@coral-xyz/anchor");
const bs58_1 = __importDefault(require("bs58"));
const spl_token_1 = require("@solana/spl-token");
const types_1 = require("./types");
const drift_json_1 = __importDefault(require("./idl/drift.json"));
const web3_js_1 = require("@solana/web3.js");
const events_1 = require("events");
const pda_1 = require("./addresses/pda");
const types_2 = require("./accounts/types");
const numericConstants_1 = require("./constants/numericConstants");
const position_1 = require("./math/position");
const spotBalance_1 = require("./math/spotBalance");
const userName_1 = require("./userName");
const pollingDriftClientAccountSubscriber_1 = require("./accounts/pollingDriftClientAccountSubscriber");
const webSocketDriftClientAccountSubscriber_1 = require("./accounts/webSocketDriftClientAccountSubscriber");
const retryTxSender_1 = require("./tx/retryTxSender");
const user_1 = require("./user");
const config_1 = require("./config");
const spotMarkets_1 = require("./constants/spotMarkets");
const userStats_1 = require("./userStats");
const spotPosition_1 = require("./math/spotPosition");
const market_1 = require("./math/market");
const fetch_1 = require("./accounts/fetch");
const spotMarket_1 = require("./math/spotMarket");
const jupiterClient_1 = require("./jupiter/jupiterClient");
const memcmp_1 = require("./memcmp");
const marinade_1 = require("./marinade");
const orderParams_1 = require("./orderParams");
const utils_1 = require("./math/utils");
const txParamProcessor_1 = require("./tx/txParamProcessor");
const oracles_1 = require("./math/oracles");
const txHandler_1 = require("./tx/txHandler");
const price_service_sdk_1 = require("@pythnetwork/price-service-sdk");
const pythOracleUtils_1 = require("./util/pythOracleUtils");
const ed25519Utils_1 = require("./util/ed25519Utils");
const utils_2 = require("./tx/utils");
const pyth_solana_receiver_json_1 = __importDefault(require("./idl/pyth_solana_receiver.json"));
const on_demand_1 = require("@switchboard-xyz/on-demand");
const grpcDriftClientAccountSubscriber_1 = require("./accounts/grpcDriftClientAccountSubscriber");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const oracleId_1 = require("./oracles/oracleId");
// BN is already imported globally in this file via other imports
const sha256_1 = require("@noble/hashes/sha256");
const utils_3 = require("./oracles/utils");
const orders_1 = require("./math/orders");
const builder_1 = require("./math/builder");
const titanClient_1 = require("./titan/titanClient");
const UnifiedSwapClient_1 = require("./swap/UnifiedSwapClient");
const pyth_1 = require("./pyth");
/**
 * # DriftClient
 * This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more.
 */
class DriftClient {
    get isSubscribed() {
        return this._isSubscribed && this.accountSubscriber.isSubscribed;
    }
    async getPrePlaceOrderIxs(orderParams, userAccount, options) {
        var _a;
        const preIxs = [];
        if ((0, types_1.isVariant)(orderParams.marketType, 'perp')) {
            const { positionMaxLev, isolatedPositionDepositAmount } = options !== null && options !== void 0 ? options : {};
            if (((_a = isolatedPositionDepositAmount === null || isolatedPositionDepositAmount === void 0 ? void 0 : isolatedPositionDepositAmount.gt) === null || _a === void 0 ? void 0 : _a.call(isolatedPositionDepositAmount, numericConstants_1.ZERO)) &&
                this.isOrderIncreasingPosition(orderParams, userAccount.subAccountId)) {
                preIxs.push(await this.getTransferIsolatedPerpPositionDepositIx(isolatedPositionDepositAmount, orderParams.marketIndex, userAccount.subAccountId));
            }
            if (positionMaxLev) {
                const marginRatio = Math.floor((1 / positionMaxLev) * numericConstants_1.MARGIN_PRECISION.toNumber());
                preIxs.push(await this.getUpdateUserPerpPositionCustomMarginRatioIx(orderParams.marketIndex, marginRatio, userAccount.subAccountId));
            }
        }
        return preIxs;
    }
    set isSubscribed(val) {
        this._isSubscribed = val;
    }
    constructor(config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26;
        this.users = new Map();
        this._isSubscribed = false;
        this.perpMarketLastSlotCache = new Map();
        this.spotMarketLastSlotCache = new Map();
        this.mustIncludePerpMarketIndexes = new Set();
        this.mustIncludeSpotMarketIndexes = new Set();
        this.connection = config.connection;
        this.wallet = config.wallet;
        this.env = (_a = config.env) !== null && _a !== void 0 ? _a : 'mainnet-beta';
        this.opts = config.opts || {
            ...config_1.DEFAULT_CONFIRMATION_OPTS,
        };
        this.useHotWalletAdmin = (_b = config.useHotWalletAdmin) !== null && _b !== void 0 ? _b : false;
        if ((_c = config === null || config === void 0 ? void 0 : config.connection) === null || _c === void 0 ? void 0 : _c.commitment) {
            // At the moment this ensures that our transaction simulations (which use Connection object) will use the same commitment level as our Transaction blockhashes (which use these opts)
            this.opts.commitment = config.connection.commitment;
            this.opts.preflightCommitment = config.connection.commitment;
        }
        this.provider = new anchor_1.AnchorProvider(config.connection, 
        // @ts-ignore
        config.wallet, this.opts);
        this.program = new anchor_1.Program(drift_json_1.default, (_d = config.programID) !== null && _d !== void 0 ? _d : new web3_js_1.PublicKey(config_1.DRIFT_PROGRAM_ID), this.provider, config.coder);
        this.authority = (_e = config.authority) !== null && _e !== void 0 ? _e : this.wallet.publicKey;
        this.activeSubAccountId = (_f = config.activeSubAccountId) !== null && _f !== void 0 ? _f : 0;
        this.skipLoadUsers = (_g = config.skipLoadUsers) !== null && _g !== void 0 ? _g : false;
        this.txVersion =
            (_h = config.txVersion) !== null && _h !== void 0 ? _h : this.getTxVersionForNewWallet(config.wallet);
        this.txParams = {
            computeUnits: (_k = (_j = config.txParams) === null || _j === void 0 ? void 0 : _j.computeUnits) !== null && _k !== void 0 ? _k : 600000,
            computeUnitsPrice: (_m = (_l = config.txParams) === null || _l === void 0 ? void 0 : _l.computeUnitsPrice) !== null && _m !== void 0 ? _m : 0,
        };
        this.txHandler =
            (_o = config === null || config === void 0 ? void 0 : config.txHandler) !== null && _o !== void 0 ? _o : new txHandler_1.TxHandler({
                connection: this.connection,
                // @ts-ignore
                wallet: this.provider.wallet,
                confirmationOptions: this.opts,
                opts: {
                    returnBlockHeightsWithSignedTxCallbackData: config.enableMetricsEvents,
                    onSignedCb: this.handleSignedTransaction.bind(this),
                    preSignedCb: this.handlePreSignedTransaction.bind(this),
                },
                config: config.txHandlerConfig,
            });
        if (config.includeDelegates && config.subAccountIds) {
            throw new Error('Can only pass one of includeDelegates or subAccountIds. If you want to specify subaccount ids for multiple authorities, pass authoritySubaccountMap instead');
        }
        if (config.authoritySubAccountMap && config.subAccountIds) {
            throw new Error('Can only pass one of authoritySubaccountMap or subAccountIds');
        }
        if (config.authoritySubAccountMap && config.includeDelegates) {
            throw new Error('Can only pass one of authoritySubaccountMap or includeDelegates');
        }
        this.authoritySubAccountMap = config.authoritySubAccountMap
            ? config.authoritySubAccountMap
            : config.subAccountIds
                ? new Map([[this.authority.toString(), config.subAccountIds]])
                : new Map();
        this.includeDelegates = (_p = config.includeDelegates) !== null && _p !== void 0 ? _p : false;
        if (((_q = config.accountSubscription) === null || _q === void 0 ? void 0 : _q.type) === 'polling') {
            this.userAccountSubscriptionConfig = {
                type: 'polling',
                accountLoader: config.accountSubscription.accountLoader,
            };
            this.userStatsAccountSubscriptionConfig = {
                type: 'polling',
                accountLoader: config.accountSubscription.accountLoader,
            };
        }
        else if (((_r = config.accountSubscription) === null || _r === void 0 ? void 0 : _r.type) === 'grpc') {
            this.userAccountSubscriptionConfig = {
                type: 'grpc',
                resubTimeoutMs: (_s = config.accountSubscription) === null || _s === void 0 ? void 0 : _s.resubTimeoutMs,
                logResubMessages: (_t = config.accountSubscription) === null || _t === void 0 ? void 0 : _t.logResubMessages,
                grpcConfigs: (_u = config.accountSubscription) === null || _u === void 0 ? void 0 : _u.grpcConfigs,
                grpcMultiUserAccountSubscriber: (_v = config.accountSubscription) === null || _v === void 0 ? void 0 : _v.grpcMultiUserAccountSubscriber,
            };
            this.userStatsAccountSubscriptionConfig = {
                type: 'grpc',
                grpcConfigs: (_w = config.accountSubscription) === null || _w === void 0 ? void 0 : _w.grpcConfigs,
                resubTimeoutMs: (_x = config.accountSubscription) === null || _x === void 0 ? void 0 : _x.resubTimeoutMs,
                logResubMessages: (_y = config.accountSubscription) === null || _y === void 0 ? void 0 : _y.logResubMessages,
            };
        }
        else {
            this.userAccountSubscriptionConfig = {
                type: 'websocket',
                resubTimeoutMs: (_z = config.accountSubscription) === null || _z === void 0 ? void 0 : _z.resubTimeoutMs,
                logResubMessages: (_0 = config.accountSubscription) === null || _0 === void 0 ? void 0 : _0.logResubMessages,
                commitment: (_1 = config.accountSubscription) === null || _1 === void 0 ? void 0 : _1.commitment,
                programUserAccountSubscriber: (_2 = config.accountSubscription) === null || _2 === void 0 ? void 0 : _2.programUserAccountSubscriber,
            };
            this.userStatsAccountSubscriptionConfig = {
                type: 'websocket',
                resubTimeoutMs: (_3 = config.accountSubscription) === null || _3 === void 0 ? void 0 : _3.resubTimeoutMs,
                logResubMessages: (_4 = config.accountSubscription) === null || _4 === void 0 ? void 0 : _4.logResubMessages,
                commitment: (_5 = config.accountSubscription) === null || _5 === void 0 ? void 0 : _5.commitment,
            };
        }
        if (config.userStats) {
            this.userStats = new userStats_1.UserStats({
                driftClient: this,
                userStatsAccountPublicKey: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority),
                accountSubscription: this.userAccountSubscriptionConfig,
            });
        }
        this.marketLookupTable = config.marketLookupTable;
        if (!this.marketLookupTable) {
            this.marketLookupTable = new web3_js_1.PublicKey(config_1.configs[this.env].MARKET_LOOKUP_TABLE);
        }
        this.marketLookupTables = config.marketLookupTables;
        if (!this.marketLookupTables) {
            this.marketLookupTables = config_1.configs[this.env].MARKET_LOOKUP_TABLES.map((tableAddr) => new web3_js_1.PublicKey(tableAddr));
        }
        const delistedMarketSetting = config.delistedMarketSetting || types_2.DelistedMarketSetting.Unsubscribe;
        const noMarketsAndOraclesSpecified = config.perpMarketIndexes === undefined &&
            config.spotMarketIndexes === undefined &&
            config.oracleInfos === undefined;
        if (((_6 = config.accountSubscription) === null || _6 === void 0 ? void 0 : _6.type) === 'polling') {
            this.accountSubscriber = new pollingDriftClientAccountSubscriber_1.PollingDriftClientAccountSubscriber(this.program, config.accountSubscription.accountLoader, (_7 = config.perpMarketIndexes) !== null && _7 !== void 0 ? _7 : [], (_8 = config.spotMarketIndexes) !== null && _8 !== void 0 ? _8 : [], (_9 = config.oracleInfos) !== null && _9 !== void 0 ? _9 : [], noMarketsAndOraclesSpecified, delistedMarketSetting);
        }
        else if (((_10 = config.accountSubscription) === null || _10 === void 0 ? void 0 : _10.type) === 'grpc') {
            const accountSubscriberClass = (_12 = (_11 = config.accountSubscription) === null || _11 === void 0 ? void 0 : _11.driftClientAccountSubscriber) !== null && _12 !== void 0 ? _12 : grpcDriftClientAccountSubscriber_1.grpcDriftClientAccountSubscriber;
            this.accountSubscriber = new accountSubscriberClass(config.accountSubscription.grpcConfigs, this.program, (_13 = config.perpMarketIndexes) !== null && _13 !== void 0 ? _13 : [], (_14 = config.spotMarketIndexes) !== null && _14 !== void 0 ? _14 : [], (_15 = config.oracleInfos) !== null && _15 !== void 0 ? _15 : [], noMarketsAndOraclesSpecified, delistedMarketSetting, {
                resubTimeoutMs: (_16 = config.accountSubscription) === null || _16 === void 0 ? void 0 : _16.resubTimeoutMs,
                logResubMessages: (_17 = config.accountSubscription) === null || _17 === void 0 ? void 0 : _17.logResubMessages,
            });
        }
        else {
            const accountSubscriberClass = (_19 = (_18 = config.accountSubscription) === null || _18 === void 0 ? void 0 : _18.driftClientAccountSubscriber) !== null && _19 !== void 0 ? _19 : webSocketDriftClientAccountSubscriber_1.WebSocketDriftClientAccountSubscriber;
            this.accountSubscriber = new accountSubscriberClass(this.program, (_20 = config.perpMarketIndexes) !== null && _20 !== void 0 ? _20 : [], (_21 = config.spotMarketIndexes) !== null && _21 !== void 0 ? _21 : [], (_22 = config.oracleInfos) !== null && _22 !== void 0 ? _22 : [], noMarketsAndOraclesSpecified, delistedMarketSetting, {
                resubTimeoutMs: (_23 = config.accountSubscription) === null || _23 === void 0 ? void 0 : _23.resubTimeoutMs,
                logResubMessages: (_24 = config.accountSubscription) === null || _24 === void 0 ? void 0 : _24.logResubMessages,
            }, (_25 = config.accountSubscription) === null || _25 === void 0 ? void 0 : _25.commitment);
        }
        this.eventEmitter = this.accountSubscriber.eventEmitter;
        this.metricsEventEmitter = new events_1.EventEmitter();
        if (config.enableMetricsEvents) {
            this.enableMetricsEvents = true;
        }
        this.txSender =
            (_26 = config.txSender) !== null && _26 !== void 0 ? _26 : new retryTxSender_1.RetryTxSender({
                connection: this.connection,
                wallet: this.wallet,
                opts: this.opts,
                txHandler: this.txHandler,
            });
        this.sbOnDemandProgramdId = config_1.configs[this.env].SB_ON_DEMAND_PID;
    }
    getUserMapKey(subAccountId, authority) {
        return `${subAccountId}_${authority.toString()}`;
    }
    createUser(subAccountId, accountSubscriptionConfig, authority) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.authority, subAccountId);
        return new user_1.User({
            driftClient: this,
            userAccountPublicKey,
            accountSubscription: accountSubscriptionConfig,
        });
    }
    async subscribe() {
        let subscribePromises = [this.addAndSubscribeToUsers()].concat(this.accountSubscriber.subscribe());
        if (this.userStats !== undefined) {
            subscribePromises = subscribePromises.concat(this.userStats.subscribe());
        }
        this.isSubscribed = (await Promise.all(subscribePromises)).reduce((success, prevSuccess) => success && prevSuccess);
        return this.isSubscribed;
    }
    subscribeUsers() {
        return [...this.users.values()].map((user) => user.subscribe());
    }
    /**
     *	Forces the accountSubscriber to fetch account updates from rpc
     */
    async fetchAccounts() {
        let promises = [...this.users.values()]
            .map((user) => user.fetchAccounts())
            .concat(this.accountSubscriber.fetch());
        if (this.userStats) {
            promises = promises.concat(this.userStats.fetchAccounts());
        }
        await Promise.all(promises);
    }
    async unsubscribe() {
        let unsubscribePromises = this.unsubscribeUsers().concat(this.accountSubscriber.unsubscribe());
        if (this.userStats !== undefined) {
            unsubscribePromises = unsubscribePromises.concat(this.userStats.unsubscribe());
        }
        await Promise.all(unsubscribePromises);
        this.isSubscribed = false;
    }
    unsubscribeUsers() {
        return [...this.users.values()].map((user) => user.unsubscribe());
    }
    async getStatePublicKey() {
        if (this.statePublicKey) {
            return this.statePublicKey;
        }
        this.statePublicKey = await (0, pda_1.getDriftStateAccountPublicKey)(this.program.programId);
        return this.statePublicKey;
    }
    getSignerPublicKey() {
        if (this.signerPublicKey) {
            return this.signerPublicKey;
        }
        this.signerPublicKey = (0, pda_1.getDriftSignerPublicKey)(this.program.programId);
        return this.signerPublicKey;
    }
    getStateAccount() {
        return this.accountSubscriber.getStateAccountAndSlot().data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     */
    async forceGetStateAccount() {
        await this.accountSubscriber.fetch();
        return this.accountSubscriber.getStateAccountAndSlot().data;
    }
    getPerpMarketAccount(marketIndex) {
        var _a;
        return (_a = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _a === void 0 ? void 0 : _a.data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param marketIndex
     */
    async forceGetPerpMarketAccount(marketIndex) {
        var _a, _b;
        await this.accountSubscriber.fetch();
        let data = (_a = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _a === void 0 ? void 0 : _a.data;
        let i = 0;
        while (data === undefined && i < 10) {
            await this.accountSubscriber.fetch();
            data = (_b = this.accountSubscriber.getMarketAccountAndSlot(marketIndex)) === null || _b === void 0 ? void 0 : _b.data;
            i++;
        }
        return data;
    }
    getPerpMarketAccounts() {
        return this.accountSubscriber
            .getMarketAccountsAndSlots()
            .filter((value) => value !== undefined)
            .map((value) => value.data);
    }
    getSpotMarketAccount(marketIndex) {
        return this.accountSubscriber.getSpotMarketAccountAndSlot(marketIndex).data;
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param marketIndex
     */
    async forceGetSpotMarketAccount(marketIndex) {
        await this.accountSubscriber.fetch();
        return this.accountSubscriber.getSpotMarketAccountAndSlot(marketIndex).data;
    }
    getSpotMarketAccounts() {
        return this.accountSubscriber
            .getSpotMarketAccountsAndSlots()
            .filter((value) => value !== undefined)
            .map((value) => value.data);
    }
    getQuoteSpotMarketAccount() {
        return this.accountSubscriber.getSpotMarketAccountAndSlot(numericConstants_1.QUOTE_SPOT_MARKET_INDEX).data;
    }
    getOraclePriceDataAndSlot(oraclePublicKey, oracleSource) {
        return this.accountSubscriber.getOraclePriceDataAndSlot((0, oracleId_1.getOracleId)(oraclePublicKey, oracleSource));
    }
    async getSerumV3FulfillmentConfig(serumMarket) {
        const address = await (0, pda_1.getSerumFulfillmentConfigPublicKey)(this.program.programId, serumMarket);
        return (await this.program.account.serumV3FulfillmentConfig.fetch(address));
    }
    async getSerumV3FulfillmentConfigs() {
        const accounts = await this.program.account.serumV3FulfillmentConfig.all();
        return accounts.map((account) => account.account);
    }
    async getPhoenixV1FulfillmentConfig(phoenixMarket) {
        const address = await (0, pda_1.getPhoenixFulfillmentConfigPublicKey)(this.program.programId, phoenixMarket);
        return (await this.program.account.phoenixV1FulfillmentConfig.fetch(address));
    }
    async getPhoenixV1FulfillmentConfigs() {
        const accounts = await this.program.account.phoenixV1FulfillmentConfig.all();
        return accounts.map((account) => account.account);
    }
    async getOpenbookV2FulfillmentConfig(openbookMarket) {
        const address = (0, pda_1.getOpenbookV2FulfillmentConfigPublicKey)(this.program.programId, openbookMarket);
        return (await this.program.account.openbookV2FulfillmentConfig.fetch(address));
    }
    async getOpenbookV2FulfillmentConfigs() {
        const accounts = await this.program.account.openbookV2FulfillmentConfig.all();
        return accounts.map((account) => account.account);
    }
    /** @deprecated use fetchAllLookupTableAccounts() */
    async fetchMarketLookupTableAccount() {
        if (this.lookupTableAccount)
            return this.lookupTableAccount;
        if (!this.marketLookupTable) {
            console.log('Market lookup table address not set');
            return;
        }
        const lookupTableAccount = (await this.connection.getAddressLookupTable(this.marketLookupTable)).value;
        this.lookupTableAccount = lookupTableAccount;
        return lookupTableAccount;
    }
    async fetchAllLookupTableAccounts() {
        if (this.lookupTableAccounts)
            return this.lookupTableAccounts;
        if (!this.marketLookupTables) {
            console.log('Market lookup table address not set');
            return [];
        }
        const lookupTableAccountResults = await Promise.all(this.marketLookupTables.map((lookupTable) => this.connection.getAddressLookupTable(lookupTable)));
        // Filter out null values - lookup tables may not exist on-chain
        const lookupTableAccounts = lookupTableAccountResults
            .map((result) => result.value)
            .filter((account) => account !== null);
        this.lookupTableAccounts = lookupTableAccounts;
        return lookupTableAccounts;
    }
    getTxVersionForNewWallet(newWallet) {
        var _a, _b, _c;
        if (!(newWallet === null || newWallet === void 0 ? void 0 : newWallet.supportedTransactionVersions))
            return 0; // Assume versioned txs supported if wallet doesn't have a supportedTransactionVersions property
        const walletSupportsVersionedTxns = ((_a = newWallet.supportedTransactionVersions) === null || _a === void 0 ? void 0 : _a.has(0)) ||
            ((_c = (_b = newWallet.supportedTransactionVersions) === null || _b === void 0 ? void 0 : _b.size) !== null && _c !== void 0 ? _c : 0) > 1;
        return walletSupportsVersionedTxns ? 0 : 'legacy';
    }
    /**
     * Update the wallet to use for drift transactions and linked user account
     * @param newWallet
     * @param subAccountIds
     * @param activeSubAccountId
     * @param includeDelegates
     */
    async updateWallet(newWallet, subAccountIds, activeSubAccountId, includeDelegates, authoritySubaccountMap) {
        var _a;
        const newProvider = new anchor_1.AnchorProvider(this.connection, 
        // @ts-ignore
        newWallet, this.opts);
        const newProgram = new anchor_1.Program(drift_json_1.default, this.program.programId, newProvider);
        this.skipLoadUsers = false;
        // Update provider for txSender with new wallet details
        this.txSender.wallet = newWallet;
        this.wallet = newWallet;
        this.txHandler.updateWallet(newWallet);
        this.provider = newProvider;
        this.program = newProgram;
        this.authority = newWallet.publicKey;
        this.activeSubAccountId = activeSubAccountId;
        this.userStatsAccountPublicKey = undefined;
        this.includeDelegates = includeDelegates !== null && includeDelegates !== void 0 ? includeDelegates : false;
        this.txVersion = this.getTxVersionForNewWallet(this.wallet);
        if (includeDelegates && subAccountIds) {
            throw new Error('Can only pass one of includeDelegates or subAccountIds. If you want to specify subaccount ids for multiple authorities, pass authoritySubaccountMap instead');
        }
        if (authoritySubaccountMap && subAccountIds) {
            throw new Error('Can only pass one of authoritySubaccountMap or subAccountIds');
        }
        if (authoritySubaccountMap && includeDelegates) {
            throw new Error('Can only pass one of authoritySubaccountMap or includeDelegates');
        }
        this.authoritySubAccountMap = authoritySubaccountMap
            ? authoritySubaccountMap
            : subAccountIds
                ? new Map([[this.authority.toString(), subAccountIds]])
                : new Map();
        /* Reset user stats account */
        if ((_a = this.userStats) === null || _a === void 0 ? void 0 : _a.isSubscribed) {
            await this.userStats.unsubscribe();
        }
        this.userStats = undefined;
        this.userStats = new userStats_1.UserStats({
            driftClient: this,
            userStatsAccountPublicKey: this.getUserStatsAccountPublicKey(),
            accountSubscription: this.userStatsAccountSubscriptionConfig,
        });
        const subscriptionPromises = [this.userStats.subscribe()];
        let success = true;
        if (this.isSubscribed) {
            const reSubscribeUsersPromise = async () => {
                await Promise.all(this.unsubscribeUsers());
                this.users.clear();
                success = await this.addAndSubscribeToUsers();
            };
            subscriptionPromises.push(reSubscribeUsersPromise());
        }
        await Promise.all(subscriptionPromises);
        return success;
    }
    /**
     * Update the subscribed accounts to a given authority, while leaving the
     * connected wallet intact. This allows a user to emulate another user's
     * account on the UI and sign permissionless transactions with their own wallet.
     * @param emulateAuthority
     */
    async emulateAccount(emulateAuthority) {
        var _a;
        this.skipLoadUsers = false;
        // Update provider for txSender with new wallet details
        this.authority = emulateAuthority;
        this.userStatsAccountPublicKey = undefined;
        this.includeDelegates = true;
        this.txVersion = this.getTxVersionForNewWallet(this.wallet);
        this.authoritySubAccountMap = new Map();
        /* Reset user stats account */
        if ((_a = this.userStats) === null || _a === void 0 ? void 0 : _a.isSubscribed) {
            await this.userStats.unsubscribe();
        }
        this.userStats = undefined;
        this.userStats = new userStats_1.UserStats({
            driftClient: this,
            userStatsAccountPublicKey: this.getUserStatsAccountPublicKey(),
            accountSubscription: this.userStatsAccountSubscriptionConfig,
        });
        await this.userStats.subscribe();
        let success = true;
        if (this.isSubscribed) {
            await Promise.all(this.unsubscribeUsers());
            this.users.clear();
            success = await this.addAndSubscribeToUsers(emulateAuthority);
        }
        return success;
    }
    async switchActiveUser(subAccountId, authority) {
        var _a;
        const authorityChanged = authority && !((_a = this.authority) === null || _a === void 0 ? void 0 : _a.equals(authority));
        this.activeSubAccountId = subAccountId;
        this.authority = authority !== null && authority !== void 0 ? authority : this.authority;
        this.userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority);
        /* If changing the user authority ie switching from delegate to non-delegate account, need to re-subscribe to the user stats account */
        if (authorityChanged && this.userStats) {
            if (this.userStats.isSubscribed) {
                await this.userStats.unsubscribe();
            }
            this.userStats = new userStats_1.UserStats({
                driftClient: this,
                userStatsAccountPublicKey: this.userStatsAccountPublicKey,
                accountSubscription: this.userStatsAccountSubscriptionConfig,
            });
            this.userStats.subscribe();
        }
    }
    async addUser(subAccountId, authority, userAccount) {
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userKey = this.getUserMapKey(subAccountId, authority);
        if (this.users.has(userKey) && this.users.get(userKey).isSubscribed) {
            return true;
        }
        const user = this.createUser(subAccountId, this.userAccountSubscriptionConfig, authority);
        const result = await user.subscribe(userAccount);
        if (result) {
            this.users.set(userKey, user);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Adds and subscribes to users based on params set by the constructor or by updateWallet.
     */
    async addAndSubscribeToUsers(authority) {
        var _a, _b, _c, _d, _e, _f, _g;
        // save the rpc calls if driftclient is initialized without a real wallet
        if (this.skipLoadUsers)
            return true;
        let result = true;
        if (this.authoritySubAccountMap && this.authoritySubAccountMap.size > 0) {
            this.authoritySubAccountMap.forEach(async (value, key) => {
                for (const subAccountId of value) {
                    result =
                        result && (await this.addUser(subAccountId, new web3_js_1.PublicKey(key)));
                }
            });
            if (this.activeSubAccountId == undefined) {
                this.switchActiveUser((_a = [...this.authoritySubAccountMap.values()][0][0]) !== null && _a !== void 0 ? _a : 0, new web3_js_1.PublicKey((_b = [...this.authoritySubAccountMap.keys()][0]) !== null && _b !== void 0 ? _b : this.authority.toString()));
            }
        }
        else {
            let userAccounts = [];
            let delegatedAccounts = [];
            const userAccountsPromise = this.getUserAccountsForAuthority(authority !== null && authority !== void 0 ? authority : this.wallet.publicKey);
            if (this.includeDelegates) {
                const delegatedAccountsPromise = this.getUserAccountsForDelegate(authority !== null && authority !== void 0 ? authority : this.wallet.publicKey);
                [userAccounts, delegatedAccounts] = await Promise.all([
                    userAccountsPromise,
                    delegatedAccountsPromise,
                ]);
                !userAccounts && (userAccounts = []);
                !delegatedAccounts && (delegatedAccounts = []);
            }
            else {
                userAccounts = (_c = (await userAccountsPromise)) !== null && _c !== void 0 ? _c : [];
            }
            const allAccounts = userAccounts.concat(delegatedAccounts);
            const addAllAccountsPromise = allAccounts.map((acc) => this.addUser(acc.subAccountId, acc.authority, acc));
            const addAllAccountsResults = await Promise.all(addAllAccountsPromise);
            result = addAllAccountsResults.every((res) => !!res);
            if (this.activeSubAccountId == undefined) {
                this.switchActiveUser((_e = (_d = userAccounts.concat(delegatedAccounts)[0]) === null || _d === void 0 ? void 0 : _d.subAccountId) !== null && _e !== void 0 ? _e : 0, (_g = (_f = userAccounts.concat(delegatedAccounts)[0]) === null || _f === void 0 ? void 0 : _f.authority) !== null && _g !== void 0 ? _g : this.authority);
            }
        }
        return result;
    }
    /**
     * Returns the instructions to initialize a user account and the public key of the user account.
     * @param subAccountId
     * @param name
     * @param referrerInfo
     * @returns [instructions, userAccountPublicKey]
     */
    async getInitializeUserAccountIxs(subAccountId = 0, name, referrerInfo, poolId) {
        const initializeIxs = [];
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                initializeIxs.push(await this.getInitializeUserStatsIx());
            }
        }
        initializeIxs.push(initializeUserAccountIx);
        if (poolId) {
            initializeIxs.push(await this.getUpdateUserPoolIdIx(poolId, subAccountId));
        }
        return [initializeIxs, userAccountPublicKey];
    }
    /**
     * Initializes a user account and returns the transaction signature and the public key of the user account.
     * @param subAccountId
     * @param name
     * @param referrerInfo
     * @param txParams
     * @returns [transactionSignature, userAccountPublicKey]
     */
    async initializeUserAccount(subAccountId = 0, name, referrerInfo, txParams) {
        const [initializeIxs, userAccountPublicKey] = await this.getInitializeUserAccountIxs(subAccountId, name, referrerInfo);
        const tx = await this.buildTransaction(initializeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async getInitializeUserStatsIx(overrides) {
        var _a;
        const payer = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.externalWallet) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        const authority = this.authority;
        return await this.program.instruction.initializeUserStats({
            accounts: {
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority),
                authority,
                payer,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
        });
    }
    async initializeSignedMsgUserOrders(authority, numOrders, txParams) {
        const initializeIxs = [];
        const [signedMsgUserAccountPublicKey, initializeUserAccountIx] = await this.getInitializeSignedMsgUserOrdersAccountIx(authority, numOrders);
        initializeIxs.push(initializeUserAccountIx);
        const tx = await this.buildTransaction(initializeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return [txSig, signedMsgUserAccountPublicKey];
    }
    async getInitializeSignedMsgUserOrdersAccountIx(authority, numOrders, overrides) {
        var _a;
        const payer = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.externalWallet) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        const signedMsgUserAccountPublicKey = (0, pda_1.getSignedMsgUserAccountPublicKey)(this.program.programId, authority);
        const initializeUserAccountIx = await this.program.instruction.initializeSignedMsgUserOrders(numOrders, {
            accounts: {
                signedMsgUserOrders: signedMsgUserAccountPublicKey,
                authority,
                payer,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        return [signedMsgUserAccountPublicKey, initializeUserAccountIx];
    }
    async resizeSignedMsgUserOrders(authority, numOrders, userSubaccountId, txParams) {
        const resizeUserAccountIx = await this.getResizeSignedMsgUserOrdersInstruction(authority, numOrders, userSubaccountId);
        const tx = await this.buildTransaction([resizeUserAccountIx], txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getResizeSignedMsgUserOrdersInstruction(authority, numOrders, userSubaccountId) {
        const signedMsgUserAccountPublicKey = (0, pda_1.getSignedMsgUserAccountPublicKey)(this.program.programId, authority);
        const resizeUserAccountIx = await this.program.instruction.resizeSignedMsgUserOrders(numOrders, {
            accounts: {
                signedMsgUserOrders: signedMsgUserAccountPublicKey,
                authority,
                payer: this.wallet.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
                user: await (0, pda_1.getUserAccountPublicKey)(this.program.programId, authority, userSubaccountId),
            },
        });
        return resizeUserAccountIx;
    }
    async initializeSignedMsgWsDelegatesAccount(authority, delegates = [], txParams) {
        const ix = await this.getInitializeSignedMsgWsDelegatesAccountIx(authority, delegates);
        const tx = await this.buildTransaction([ix], txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getInitializeSignedMsgWsDelegatesAccountIx(authority, delegates = []) {
        const signedMsgWsDelegates = (0, pda_1.getSignedMsgWsDelegatesAccountPublicKey)(this.program.programId, authority);
        const ix = await this.program.instruction.initializeSignedMsgWsDelegates(delegates, {
            accounts: {
                signedMsgWsDelegates,
                authority: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        return ix;
    }
    async initializeRevenueShare(authority, txParams) {
        const ix = await this.getInitializeRevenueShareIx(authority);
        const tx = await this.buildTransaction([ix], txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getInitializeRevenueShareIx(authority, overrides) {
        var _a;
        const revenueShare = (0, pda_1.getRevenueShareAccountPublicKey)(this.program.programId, authority);
        return this.program.instruction.initializeRevenueShare({
            accounts: {
                revenueShare,
                authority,
                payer: (_a = overrides === null || overrides === void 0 ? void 0 : overrides.payer) !== null && _a !== void 0 ? _a : this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
    }
    async initializeRevenueShareEscrow(authority, numOrders, txParams) {
        const ix = await this.getInitializeRevenueShareEscrowIx(authority, numOrders);
        const tx = await this.buildTransaction([ix], txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getInitializeRevenueShareEscrowIx(authority, numOrders, overrides) {
        var _a;
        const escrow = (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, authority);
        return this.program.instruction.initializeRevenueShareEscrow(numOrders, {
            accounts: {
                escrow,
                authority,
                payer: (_a = overrides === null || overrides === void 0 ? void 0 : overrides.payer) !== null && _a !== void 0 ? _a : this.wallet.publicKey,
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority),
                state: await this.getStatePublicKey(),
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
    }
    async migrateReferrer(authority, txParams) {
        const ix = await this.getMigrateReferrerIx(authority);
        const tx = await this.buildTransaction([ix], txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getMigrateReferrerIx(authority) {
        const escrow = (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, authority);
        return this.program.instruction.migrateReferrer({
            accounts: {
                escrow,
                authority,
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority),
                state: await this.getStatePublicKey(),
                payer: this.wallet.publicKey,
            },
        });
    }
    async resizeRevenueShareEscrowOrders(authority, numOrders, txParams) {
        const ix = await this.getResizeRevenueShareEscrowOrdersIx(authority, numOrders);
        const tx = await this.buildTransaction([ix], txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getResizeRevenueShareEscrowOrdersIx(authority, numOrders) {
        const escrow = (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, authority);
        return this.program.instruction.resizeRevenueShareEscrowOrders(numOrders, {
            accounts: {
                escrow,
                authority,
                payer: this.wallet.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
    }
    /**
     * Creates the transaction to add or update an approved builder.
     * This allows the builder to receive revenue share from referrals.
     *
     * @param builder - The public key of the builder to add or update.
     * @param maxFeeTenthBps - The maximum fee tenth bps to set for the builder.
     * @param add - Whether to add or update the builder. If the builder already exists, `add = true` will update the `maxFeeTenthBps`, otherwise it will add the builder. If `add = false`, the builder's `maxFeeTenthBps` will be set to 0.
     * @param txParams - The transaction parameters to use for the transaction.
     * @returns The transaction to add or update an approved builder.
     */
    async changeApprovedBuilder(builder, maxFeeTenthBps, add, txParams) {
        const ix = await this.getChangeApprovedBuilderIx(builder, maxFeeTenthBps, add);
        const tx = await this.buildTransaction([ix], txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    /**
     * Creates the transaction instruction to add or update an approved builder.
     * This allows the builder to receive revenue share from referrals.
     *
     * @param builder - The public key of the builder to add or update.
     * @param maxFeeTenthBps - The maximum fee tenth bps to set for the builder.
     * @param add - Whether to add or update the builder. If the builder already exists, `add = true` will update the `maxFeeTenthBps`, otherwise it will add the builder. If `add = false`, the builder's `maxFeeTenthBps` will be set to 0.
     * @returns The transaction instruction to add or update an approved builder.
     */
    async getChangeApprovedBuilderIx(builder, maxFeeTenthBps, add, overrides) {
        var _a, _b;
        const authority = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.authority) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        const payer = (_b = overrides === null || overrides === void 0 ? void 0 : overrides.payer) !== null && _b !== void 0 ? _b : this.wallet.publicKey;
        const escrow = (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, authority);
        return this.program.instruction.changeApprovedBuilder(builder, maxFeeTenthBps, add, {
            accounts: {
                escrow,
                authority,
                payer,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
    }
    async addSignedMsgWsDelegate(authority, delegate, txParams) {
        const ix = await this.getAddSignedMsgWsDelegateIx(authority, delegate);
        const tx = await this.buildTransaction([ix], txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getAddSignedMsgWsDelegateIx(authority, delegate) {
        const signedMsgWsDelegates = (0, pda_1.getSignedMsgWsDelegatesAccountPublicKey)(this.program.programId, authority);
        const ix = await this.program.instruction.changeSignedMsgWsDelegateStatus(delegate, true, {
            accounts: {
                signedMsgWsDelegates,
                authority: this.wallet.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        return ix;
    }
    async removeSignedMsgWsDelegate(authority, delegate, txParams) {
        const ix = await this.getRemoveSignedMsgWsDelegateIx(authority, delegate);
        const tx = await this.buildTransaction([ix], txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getRemoveSignedMsgWsDelegateIx(authority, delegate) {
        const signedMsgWsDelegates = (0, pda_1.getSignedMsgWsDelegatesAccountPublicKey)(this.program.programId, authority);
        const ix = await this.program.instruction.changeSignedMsgWsDelegateStatus(delegate, false, {
            accounts: {
                signedMsgWsDelegates,
                authority: this.wallet.publicKey,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        return ix;
    }
    async initializeFuelOverflow(authority) {
        const ix = await this.getInitializeFuelOverflowIx(authority);
        const tx = await this.buildTransaction([ix], this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getInitializeFuelOverflowIx(authority) {
        return await this.program.instruction.initializeFuelOverflow({
            accounts: {
                fuelOverflow: (0, pda_1.getFuelOverflowAccountPublicKey)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.wallet.publicKey),
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.wallet.publicKey),
                authority: authority !== null && authority !== void 0 ? authority : this.wallet.publicKey,
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
    }
    async sweepFuel(authority) {
        const ix = await this.getSweepFuelIx(authority);
        const tx = await this.buildTransaction([ix], this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getSweepFuelIx(authority) {
        return await this.program.instruction.sweepFuel({
            accounts: {
                fuelOverflow: (0, pda_1.getFuelOverflowAccountPublicKey)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.wallet.publicKey),
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.wallet.publicKey),
                authority: authority !== null && authority !== void 0 ? authority : this.wallet.publicKey,
                signer: this.wallet.publicKey,
            },
        });
    }
    async getInitializeUserInstructions(subAccountId = 0, name, referrerInfo, overrides) {
        var _a;
        // Use external wallet as payer if provided, otherwise use the wallet
        const payer = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.externalWallet) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        // The authority is the account owner (this.authority), not the payer
        const accountAuthority = this.authority;
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, accountAuthority, subAccountId);
        const remainingAccounts = new Array();
        if (referrerInfo !== undefined) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const state = this.getStateAccount();
        if (!state.whitelistMint.equals(web3_js_1.PublicKey.default)) {
            const associatedTokenPublicKey = await (0, spl_token_1.getAssociatedTokenAddress)(state.whitelistMint, payer);
            remainingAccounts.push({
                pubkey: associatedTokenPublicKey,
                isWritable: false,
                isSigner: false,
            });
        }
        if (name === undefined) {
            if (subAccountId === 0) {
                name = userName_1.DEFAULT_USER_NAME;
            }
            else {
                name = `Subaccount ${subAccountId + 1}`;
            }
        }
        const nameBuffer = (0, userName_1.encodeName)(name);
        const initializeUserAccountIx = await this.program.instruction.initializeUser(subAccountId, nameBuffer, {
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: accountAuthority,
                payer: payer,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
                state: await this.getStatePublicKey(),
            },
            remainingAccounts,
        });
        return [userAccountPublicKey, initializeUserAccountIx];
    }
    async getNextSubAccountId() {
        const userStats = this.getUserStats();
        let userStatsAccount;
        if (!userStats) {
            userStatsAccount = await (0, fetch_1.fetchUserStatsAccount)(this.connection, this.program, this.wallet.publicKey);
        }
        else {
            userStatsAccount = userStats.getAccount();
        }
        return userStatsAccount.numberOfSubAccountsCreated;
    }
    async initializeReferrerName(name) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, 0);
        const nameBuffer = (0, userName_1.encodeName)(name);
        const referrerNameAccountPublicKey = (0, pda_1.getReferrerNamePublicKeySync)(this.program.programId, nameBuffer);
        const tx = await this.program.transaction.initializeReferrerName(nameBuffer, {
            accounts: {
                referrerName: referrerNameAccountPublicKey,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                payer: this.wallet.publicKey,
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                systemProgram: anchor.web3.SystemProgram.programId,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserName(name, subAccountId = 0) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const nameBuffer = (0, userName_1.encodeName)(name);
        const tx = await this.program.transaction.updateUserName(subAccountId, nameBuffer, {
            accounts: {
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserCustomMarginRatio(updates, txParams) {
        const ixs = await Promise.all(updates.map(async ({ marginRatio, subAccountId }) => {
            const ix = await this.getUpdateUserCustomMarginRatioIx(marginRatio, subAccountId);
            return ix;
        }));
        const tx = await this.buildTransaction(ixs, txParams !== null && txParams !== void 0 ? txParams : this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserCustomMarginRatioIx(marginRatio, subAccountId = 0) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        await this.addUser(subAccountId, this.wallet.publicKey);
        const ix = this.program.instruction.updateUserCustomMarginRatio(subAccountId, marginRatio, {
            accounts: {
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async getUpdateUserPerpPositionCustomMarginRatioIx(perpMarketIndex, marginRatio, subAccountId = 0, overrides) {
        var _a, _b;
        let userAccountPublicKey = overrides === null || overrides === void 0 ? void 0 : overrides.userAccountPublicKey;
        if (!userAccountPublicKey) {
            userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, (_a = overrides === null || overrides === void 0 ? void 0 : overrides.authority) !== null && _a !== void 0 ? _a : this.authority, subAccountId);
        }
        const signingAuthority = (_b = overrides === null || overrides === void 0 ? void 0 : overrides.signingAuthority) !== null && _b !== void 0 ? _b : this.wallet.publicKey;
        const ix = this.program.instruction.updateUserPerpPositionCustomMarginRatio(subAccountId, perpMarketIndex, marginRatio, {
            accounts: {
                user: userAccountPublicKey,
                authority: signingAuthority,
            },
        });
        return ix;
    }
    async updateUserPerpPositionCustomMarginRatio(perpMarketIndex, marginRatio, subAccountId = 0, txParams, enterHighLeverageMode) {
        const ixs = [];
        if (enterHighLeverageMode) {
            const enableIx = await this.getEnableHighLeverageModeIx(subAccountId);
            ixs.push(enableIx);
        }
        const updateIx = await this.getUpdateUserPerpPositionCustomMarginRatioIx(perpMarketIndex, marginRatio, subAccountId);
        ixs.push(updateIx);
        const tx = await this.buildTransaction(ixs, txParams !== null && txParams !== void 0 ? txParams : this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserMarginTradingEnabledIx(marginTradingEnabled, subAccountId = 0, userAccountPublicKey) {
        const userAccountPublicKeyToUse = userAccountPublicKey ||
            (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        await this.addUser(subAccountId, this.wallet.publicKey);
        let remainingAccounts;
        try {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [this.getUserAccount(subAccountId)],
            });
        }
        catch (err) {
            remainingAccounts = [];
        }
        return await this.program.instruction.updateUserMarginTradingEnabled(subAccountId, marginTradingEnabled, {
            accounts: {
                user: userAccountPublicKeyToUse,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserMarginTradingEnabled(updates) {
        const ixs = await Promise.all(updates.map(async ({ marginTradingEnabled, subAccountId }) => {
            return await this.getUpdateUserMarginTradingEnabledIx(marginTradingEnabled, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserDelegateIx(delegate, overrides) {
        var _a, _b, _c;
        const subAccountId = (_a = overrides.subAccountId) !== null && _a !== void 0 ? _a : this.activeSubAccountId;
        const userAccountPublicKey = (_b = overrides.userAccountPublicKey) !== null && _b !== void 0 ? _b : (await this.getUserAccountPublicKey());
        const authority = (_c = overrides.authority) !== null && _c !== void 0 ? _c : this.wallet.publicKey;
        return await this.program.instruction.updateUserDelegate(subAccountId, delegate, {
            accounts: {
                user: userAccountPublicKey,
                authority,
            },
        });
    }
    async updateUserDelegate(delegate, subAccountId = 0) {
        const tx = await this.program.transaction.updateUserDelegate(subAccountId, delegate, {
            accounts: {
                user: await this.getUserAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async updateUserAdvancedLp(updates) {
        const ixs = await Promise.all(updates.map(async ({ advancedLp, subAccountId }) => {
            return await this.getUpdateAdvancedDlpIx(advancedLp, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateAdvancedDlpIx(advancedLp, subAccountId) {
        const ix = await this.program.instruction.updateUserAdvancedLp(subAccountId, advancedLp, {
            accounts: {
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId),
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async updateUserReduceOnly(updates) {
        const ixs = await Promise.all(updates.map(async ({ reduceOnly, subAccountId }) => {
            return await this.getUpdateUserReduceOnlyIx(reduceOnly, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserReduceOnlyIx(reduceOnly, subAccountId) {
        const ix = await this.program.instruction.updateUserReduceOnly(subAccountId, reduceOnly, {
            accounts: {
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId),
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async updateUserPoolId(updates) {
        const ixs = await Promise.all(updates.map(async ({ poolId, subAccountId }) => {
            return await this.getUpdateUserPoolIdIx(poolId, subAccountId);
        }));
        const tx = await this.buildTransaction(ixs, this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserPoolIdIx(poolId, subAccountId) {
        const ix = await this.program.instruction.updateUserPoolId(subAccountId, poolId, {
            accounts: {
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId),
                authority: this.wallet.publicKey,
            },
        });
        return ix;
    }
    async fetchAllUserAccounts(includeIdle = true) {
        let filters = undefined;
        if (!includeIdle) {
            filters = [(0, memcmp_1.getNonIdleUserFilter)()];
        }
        return (await this.program.account.user.all(filters));
    }
    async getUserAccountsForDelegate(delegate) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 40,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(delegate.toBuffer()),
                },
            },
        ]);
        return programAccounts
            .map((programAccount) => programAccount.account)
            .sort((a, b) => a.subAccountId - b.subAccountId);
    }
    async getUserAccountsAndAddressesForAuthority(authority) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount);
    }
    async getUserAccountsForAuthority(authority) {
        const programAccounts = await this.program.account.user.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts
            .map((programAccount) => programAccount.account)
            .sort((a, b) => a.subAccountId - b.subAccountId);
    }
    async getReferredUserStatsAccountsByReferrer(referrer) {
        const programAccounts = await this.program.account.userStats.all([
            {
                memcmp: {
                    offset: 40,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(referrer.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount.account);
    }
    async getReferrerNameAccountsForAuthority(authority) {
        const programAccounts = await this.program.account.referrerName.all([
            {
                memcmp: {
                    offset: 8,
                    /** data to match, as base-58 encoded string and limited to less than 129 bytes */
                    bytes: bs58_1.default.encode(authority.toBuffer()),
                },
            },
        ]);
        return programAccounts.map((programAccount) => programAccount.account);
    }
    async deleteUser(subAccountId = 0, txParams) {
        var _a;
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const ix = await this.getUserDeletionIx(userAccountPublicKey);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ix, txParams), [], this.opts);
        const userMapKey = this.getUserMapKey(subAccountId, this.wallet.publicKey);
        await ((_a = this.users.get(userMapKey)) === null || _a === void 0 ? void 0 : _a.unsubscribe());
        this.users.delete(userMapKey);
        return txSig;
    }
    async getUserDeletionIx(userAccountPublicKey) {
        const ix = await this.program.instruction.deleteUser({
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                state: await this.getStatePublicKey(),
            },
        });
        return ix;
    }
    async forceDeleteUser(userAccountPublicKey, userAccount, txParams) {
        const tx = await this.buildTransaction(await this.getForceDeleteUserIx(userAccountPublicKey, userAccount), txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getForceDeleteUserIx(userAccountPublicKey, userAccount) {
        const writableSpotMarketIndexes = [];
        for (const spotPosition of userAccount.spotPositions) {
            if ((0, spotPosition_1.isSpotPositionAvailable)(spotPosition)) {
                continue;
            }
            writableSpotMarketIndexes.push(spotPosition.marketIndex);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writableSpotMarketIndexes,
        });
        for (const order of userAccount.orders) {
            if ((0, orders_1.hasBuilder)(order)) {
                remainingAccounts.push({
                    pubkey: (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, userAccount.authority),
                    isWritable: true,
                    isSigner: false,
                });
                break;
            }
        }
        const tokenPrograms = new Set();
        for (const spotPosition of userAccount.spotPositions) {
            if ((0, spotPosition_1.isSpotPositionAvailable)(spotPosition)) {
                continue;
            }
            const spotMarket = this.getSpotMarketAccount(spotPosition.marketIndex);
            remainingAccounts.push({
                isSigner: false,
                isWritable: true,
                pubkey: spotMarket.vault,
            });
            const tokenProgram = this.getTokenProgramForSpotMarket(spotMarket);
            const keeperVault = await this.getAssociatedTokenAccount(spotPosition.marketIndex, false, tokenProgram);
            remainingAccounts.push({
                isSigner: false,
                isWritable: true,
                pubkey: keeperVault,
            });
            tokenPrograms.add(tokenProgram.toBase58());
            this.addTokenMintToRemainingAccounts(spotMarket, remainingAccounts);
        }
        for (const tokenProgram of tokenPrograms) {
            remainingAccounts.push({
                isSigner: false,
                isWritable: false,
                pubkey: new web3_js_1.PublicKey(tokenProgram),
            });
        }
        const authority = userAccount.authority;
        const userStats = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority);
        const ix = await this.program.instruction.forceDeleteUser({
            accounts: {
                user: userAccountPublicKey,
                userStats,
                authority,
                state: await this.getStatePublicKey(),
                driftSigner: this.getSignerPublicKey(),
                keeper: this.wallet.publicKey,
            },
            remainingAccounts,
        });
        return ix;
    }
    async deleteSignedMsgUserOrders(txParams) {
        const ix = await this.getSignedMsgUserOrdersDeletionIx(this.wallet.publicKey);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ix, txParams), [], this.opts);
        return txSig;
    }
    async getSignedMsgUserOrdersDeletionIx(authority) {
        const ix = await this.program.instruction.deleteSignedMsgUserOrders({
            accounts: {
                user: authority,
                signedMsgUserOrders: (0, pda_1.getSignedMsgUserAccountPublicKey)(this.program.programId, authority),
                authority: this.wallet.publicKey,
                state: await this.getStatePublicKey(),
            },
        });
        return ix;
    }
    /**
     * Checks if a SignedMsg User Orders account exists for the given authority.
     * The account pubkey is derived using the program ID and authority as seeds.
     * Makes an RPC call to check if the account exists on-chain.
     *
     * @param authority The authority public key to check for
     * @returns Promise that resolves to true if the account exists, false otherwise
     */
    async isSignedMsgUserOrdersAccountInitialized(authority) {
        const signedMsgUserOrdersAccountPublicKey = (0, pda_1.getSignedMsgUserAccountPublicKey)(this.program.programId, authority);
        return this.checkIfAccountExists(signedMsgUserOrdersAccountPublicKey);
    }
    async reclaimRent(subAccountId = 0, txParams) {
        const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const ix = await this.getReclaimRentIx(userAccountPublicKey);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ix, txParams), [], this.opts);
        return txSig;
    }
    async getReclaimRentIx(userAccountPublicKey) {
        return await this.program.instruction.reclaimRent({
            accounts: {
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                state: await this.getStatePublicKey(),
                rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            },
        });
    }
    getUser(subAccountId, authority) {
        subAccountId = subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId;
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userMapKey = this.getUserMapKey(subAccountId, authority);
        if (!this.users.has(userMapKey)) {
            throw new Error(`DriftClient has no user for user id ${userMapKey}`);
        }
        return this.users.get(userMapKey);
    }
    hasUser(subAccountId, authority) {
        subAccountId = subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId;
        authority = authority !== null && authority !== void 0 ? authority : this.authority;
        const userMapKey = this.getUserMapKey(subAccountId, authority);
        return this.users.has(userMapKey);
    }
    getUsers() {
        // delegate users get added to the end
        return [...this.users.values()]
            .filter((acct) => acct.getUserAccount().authority.equals(this.wallet.publicKey))
            .concat([...this.users.values()].filter((acct) => !acct.getUserAccount().authority.equals(this.wallet.publicKey)));
    }
    getUserStats() {
        return this.userStats;
    }
    async fetchReferrerNameAccount(name) {
        const nameBuffer = (0, userName_1.encodeName)(name);
        const referrerNameAccountPublicKey = (0, pda_1.getReferrerNamePublicKeySync)(this.program.programId, nameBuffer);
        return (await this.program.account.referrerName.fetch(referrerNameAccountPublicKey));
    }
    getUserStatsAccountPublicKey() {
        if (this.userStatsAccountPublicKey) {
            return this.userStatsAccountPublicKey;
        }
        this.userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.authority);
        return this.userStatsAccountPublicKey;
    }
    async getUserAccountPublicKey(subAccountId, authority) {
        return this.getUser(subAccountId, authority).userAccountPublicKey;
    }
    getUserAccount(subAccountId, authority) {
        return this.getUser(subAccountId, authority).getUserAccount();
    }
    /**
     * Forces a fetch to rpc before returning accounts. Useful for anchor tests.
     * @param subAccountId
     */
    async forceGetUserAccount(subAccountId, authority) {
        await this.getUser(subAccountId, authority).fetchAccounts();
        return this.getUser(subAccountId, authority).getUserAccount();
    }
    getUserAccountAndSlot(subAccountId, authority) {
        return this.getUser(subAccountId, authority).getUserAccountAndSlot();
    }
    getSpotPosition(marketIndex, subAccountId) {
        return this.getUserAccount(subAccountId).spotPositions.find((spotPosition) => spotPosition.marketIndex === marketIndex);
    }
    getQuoteAssetTokenAmount() {
        return this.getTokenAmount(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
    }
    getIsolatedPerpPositionTokenAmount(perpMarketIndex, subAccountId) {
        return this.getUser(subAccountId).getIsolatePerpPositionTokenAmount(perpMarketIndex);
    }
    /**
     * Returns the token amount for a given market. The spot market precision is based on the token mint decimals.
     * Positive if it is a deposit, negative if it is a borrow.
     * @param marketIndex
     */
    getTokenAmount(marketIndex) {
        const spotPosition = this.getSpotPosition(marketIndex);
        if (spotPosition === undefined) {
            return numericConstants_1.ZERO;
        }
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_1.getTokenAmount)(spotPosition.scaledBalance, spotMarket, spotPosition.balanceType), spotPosition.balanceType);
    }
    /**
     * Converts an amount to the spot precision for a given market. The spot market precision is based on the token mint decimals.
     * @param marketIndex
     * @param amount
     */
    convertToSpotPrecision(marketIndex, amount) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return (0, spotMarket_1.castNumberToSpotPrecision)(amount, spotMarket);
    }
    /**
     * Converts an amount to the perp precision. The perp market precision is {@link BASE_PRECISION} (1e9).
     * @param amount
     */
    convertToPerpPrecision(amount) {
        if (typeof amount === 'number') {
            return (0, utils_1.numberToSafeBN)(amount, numericConstants_1.BASE_PRECISION);
        }
        else {
            return amount.mul(numericConstants_1.BASE_PRECISION);
        }
    }
    /**
     * Converts an amount to the price precision. The perp market precision is {@link PRICE_PRECISION} (1e6).
     * @param amount
     */
    convertToPricePrecision(amount) {
        if (typeof amount === 'number') {
            return (0, utils_1.numberToSafeBN)(amount, numericConstants_1.PRICE_PRECISION);
        }
        else {
            return amount.mul(numericConstants_1.BASE_PRECISION);
        }
    }
    /**
     * Each drift instruction must include perp and sport market accounts in the ix remaining accounts.
     * Use this function to force a subset of markets to be included in the remaining accounts for every ix
     *
     * @param perpMarketIndexes
     * @param spotMarketIndexes
     */
    mustIncludeMarketsInIx({ perpMarketIndexes, spotMarketIndexes, }) {
        perpMarketIndexes.forEach((perpMarketIndex) => {
            this.mustIncludePerpMarketIndexes.add(perpMarketIndex);
        });
        spotMarketIndexes.forEach((spotMarketIndex) => {
            this.mustIncludeSpotMarketIndexes.add(spotMarketIndex);
        });
    }
    getRemainingAccounts(params) {
        var _a;
        const { oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap } = this.getRemainingAccountMapsForUsers(params.userAccounts);
        if (params.useMarketLastSlotCache) {
            const lastUserSlot = (_a = this.getUserAccountAndSlot(params.userAccounts.length > 0
                ? params.userAccounts[0].subAccountId
                : this.activeSubAccountId, params.userAccounts.length > 0
                ? params.userAccounts[0].authority
                : this.authority)) === null || _a === void 0 ? void 0 : _a.slot;
            for (const [marketIndex, slot,] of this.perpMarketLastSlotCache.entries()) {
                // if cache has more recent slot than user positions account slot, add market to remaining accounts
                // otherwise remove from slot
                if (slot > lastUserSlot) {
                    this.addPerpMarketToRemainingAccountMaps(marketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
                }
                else {
                    this.perpMarketLastSlotCache.delete(marketIndex);
                }
            }
            for (const [marketIndex, slot,] of this.spotMarketLastSlotCache.entries()) {
                // if cache has more recent slot than user positions account slot, add market to remaining accounts
                // otherwise remove from slot
                if (slot > lastUserSlot) {
                    this.addSpotMarketToRemainingAccountMaps(marketIndex, false, oracleAccountMap, spotMarketAccountMap);
                }
                else {
                    this.spotMarketLastSlotCache.delete(marketIndex);
                }
            }
        }
        if (params.readablePerpMarketIndex !== undefined) {
            const readablePerpMarketIndexes = Array.isArray(params.readablePerpMarketIndex)
                ? params.readablePerpMarketIndex
                : [params.readablePerpMarketIndex];
            for (const marketIndex of readablePerpMarketIndexes) {
                this.addPerpMarketToRemainingAccountMaps(marketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
            }
        }
        for (const perpMarketIndex of this.mustIncludePerpMarketIndexes.values()) {
            this.addPerpMarketToRemainingAccountMaps(perpMarketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
        }
        if (params.readableSpotMarketIndexes !== undefined) {
            for (const readableSpotMarketIndex of params.readableSpotMarketIndexes) {
                this.addSpotMarketToRemainingAccountMaps(readableSpotMarketIndex, false, oracleAccountMap, spotMarketAccountMap);
            }
        }
        for (const spotMarketIndex of this.mustIncludeSpotMarketIndexes.values()) {
            this.addSpotMarketToRemainingAccountMaps(spotMarketIndex, false, oracleAccountMap, spotMarketAccountMap);
        }
        if (params.writablePerpMarketIndexes !== undefined) {
            for (const writablePerpMarketIndex of params.writablePerpMarketIndexes) {
                this.addPerpMarketToRemainingAccountMaps(writablePerpMarketIndex, true, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
            }
        }
        if (params.writableSpotMarketIndexes !== undefined) {
            for (const writableSpotMarketIndex of params.writableSpotMarketIndexes) {
                this.addSpotMarketToRemainingAccountMaps(writableSpotMarketIndex, true, oracleAccountMap, spotMarketAccountMap);
            }
        }
        return [
            ...oracleAccountMap.values(),
            ...spotMarketAccountMap.values(),
            ...perpMarketAccountMap.values(),
        ];
    }
    addPerpMarketToRemainingAccountMaps(marketIndex, writable, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap) {
        const perpMarketAccount = this.getPerpMarketAccount(marketIndex);
        perpMarketAccountMap.set(marketIndex, {
            pubkey: perpMarketAccount.pubkey,
            isSigner: false,
            isWritable: writable,
        });
        const oracleWritable = writable && (0, types_1.isVariant)(perpMarketAccount.amm.oracleSource, 'prelaunch');
        oracleAccountMap.set(perpMarketAccount.amm.oracle.toString(), {
            pubkey: perpMarketAccount.amm.oracle,
            isSigner: false,
            isWritable: oracleWritable,
        });
        this.addSpotMarketToRemainingAccountMaps(perpMarketAccount.quoteSpotMarketIndex, false, oracleAccountMap, spotMarketAccountMap);
    }
    addSpotMarketToRemainingAccountMaps(marketIndex, writable, oracleAccountMap, spotMarketAccountMap) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        spotMarketAccountMap.set(spotMarketAccount.marketIndex, {
            pubkey: spotMarketAccount.pubkey,
            isSigner: false,
            isWritable: writable,
        });
        if (!spotMarketAccount.oracle.equals(web3_js_1.PublicKey.default)) {
            oracleAccountMap.set(spotMarketAccount.oracle.toString(), {
                pubkey: spotMarketAccount.oracle,
                isSigner: false,
                isWritable: false,
            });
        }
    }
    addBuilderToRemainingAccounts(builders, remainingAccounts) {
        for (const builder of builders) {
            // Add User account for the builder
            const builderUserAccount = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, builder, 0 // subAccountId 0 for builder user account
            );
            remainingAccounts.push({
                pubkey: builderUserAccount,
                isSigner: false,
                isWritable: true,
            });
            const builderAccount = (0, pda_1.getRevenueShareAccountPublicKey)(this.program.programId, builder);
            remainingAccounts.push({
                pubkey: builderAccount,
                isSigner: false,
                isWritable: true,
            });
        }
    }
    getRemainingAccountMapsForUsers(userAccounts) {
        const oracleAccountMap = new Map();
        const spotMarketAccountMap = new Map();
        const perpMarketAccountMap = new Map();
        for (const userAccount of userAccounts) {
            for (const spotPosition of userAccount.spotPositions) {
                if (!(0, spotPosition_1.isSpotPositionAvailable)(spotPosition)) {
                    this.addSpotMarketToRemainingAccountMaps(spotPosition.marketIndex, false, oracleAccountMap, spotMarketAccountMap);
                    if (!spotPosition.openAsks.eq(numericConstants_1.ZERO) ||
                        !spotPosition.openBids.eq(numericConstants_1.ZERO)) {
                        this.addSpotMarketToRemainingAccountMaps(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, false, oracleAccountMap, spotMarketAccountMap);
                    }
                }
            }
            for (const position of userAccount.perpPositions) {
                if (!(0, position_1.positionIsAvailable)(position)) {
                    this.addPerpMarketToRemainingAccountMaps(position.marketIndex, false, oracleAccountMap, spotMarketAccountMap, perpMarketAccountMap);
                }
            }
        }
        return {
            oracleAccountMap,
            spotMarketAccountMap,
            perpMarketAccountMap,
        };
    }
    getOrder(orderId, subAccountId) {
        var _a;
        return (_a = this.getUserAccount(subAccountId)) === null || _a === void 0 ? void 0 : _a.orders.find((order) => order.orderId === orderId);
    }
    getOrderByUserId(userOrderId, subAccountId) {
        var _a;
        return (_a = this.getUserAccount(subAccountId)) === null || _a === void 0 ? void 0 : _a.orders.find((order) => order.userOrderId === userOrderId);
    }
    /**
     * Get the associated token address for the given spot market
     * @param marketIndex
     * @param useNative
     * @param tokenProgram
     */
    async getAssociatedTokenAccount(marketIndex, useNative = true, tokenProgram = spl_token_1.TOKEN_PROGRAM_ID, authority = this.wallet.publicKey, allowOwnerOffCurve = false) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        if (useNative && spotMarket.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT)) {
            return authority;
        }
        const mint = spotMarket.mint;
        return await (0, spl_token_1.getAssociatedTokenAddress)(mint, authority, allowOwnerOffCurve, tokenProgram);
    }
    createAssociatedTokenAccountIdempotentInstruction(account, payer, owner, mint, tokenProgram = spl_token_1.TOKEN_PROGRAM_ID) {
        return new web3_js_1.TransactionInstruction({
            keys: [
                { pubkey: payer, isSigner: true, isWritable: true },
                { pubkey: account, isSigner: false, isWritable: true },
                { pubkey: owner, isSigner: false, isWritable: false },
                { pubkey: mint, isSigner: false, isWritable: false },
                {
                    pubkey: anchor.web3.SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                { pubkey: tokenProgram, isSigner: false, isWritable: false },
            ],
            programId: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
            data: Buffer.from([0x1]),
        });
    }
    async getDepositTxnIx(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly = false, overrides) {
        var _a;
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const signer = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.authority) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        const createWSOLTokenAccount = isSolMarket && associatedTokenAccount.equals(signer);
        const instructions = [];
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, true, overrides);
            associatedTokenAccount = pubkey;
            instructions.push(...ixs);
        }
        const depositCollateralIx = await this.getDepositInstruction(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly, true, overrides);
        instructions.push(depositCollateralIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            instructions.push((0, spl_token_1.createCloseAccountInstruction)(associatedTokenAccount, signer, signer, []));
        }
        return instructions;
    }
    async buildSwiftDepositTx(signedOrderParams, takerInfo, depositAmount, depositSpotMarketIndex, tradePerpMarketIndex, subAccountId, takerAssociatedTokenAccount, initSwiftAccount = false) {
        const instructions = await this.getDepositTxnIx(depositAmount, depositSpotMarketIndex, takerAssociatedTokenAccount, subAccountId, false);
        if (initSwiftAccount) {
            const isSignedMsgUserOrdersAccountInitialized = await this.isSignedMsgUserOrdersAccountInitialized(this.wallet.publicKey);
            if (!isSignedMsgUserOrdersAccountInitialized) {
                const [, initializeSignedMsgUserOrdersAccountIx] = await this.getInitializeSignedMsgUserOrdersAccountIx(this.wallet.publicKey, 8);
                instructions.push(initializeSignedMsgUserOrdersAccountIx);
            }
        }
        const ixsWithPlace = await this.getPlaceSignedMsgTakerPerpOrderIxs(signedOrderParams, tradePerpMarketIndex, takerInfo, instructions);
        await this.buildTransaction(ixsWithPlace, {
            computeUnitsPrice: 1000,
            computeUnits: 100000,
        });
    }
    async createDepositTxn(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly = false, txParams, initSwiftAccount = false, overrides) {
        const instructions = await this.getDepositTxnIx(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly, overrides);
        if (initSwiftAccount) {
            const isSignedMsgUserOrdersAccountInitialized = await this.isSignedMsgUserOrdersAccountInitialized(this.wallet.publicKey);
            if (!isSignedMsgUserOrdersAccountInitialized) {
                const [, initializeSignedMsgUserOrdersAccountIx] = await this.getInitializeSignedMsgUserOrdersAccountIx(this.wallet.publicKey, 8);
                instructions.push(initializeSignedMsgUserOrdersAccountIx);
            }
        }
        txParams = { ...(txParams !== null && txParams !== void 0 ? txParams : this.txParams), computeUnits: 800000 };
        const tx = await this.buildTransaction(instructions, txParams);
        return tx;
    }
    /**
     * Deposit funds into the given spot market
     *
     * @param amount to deposit
     * @param marketIndex spot market index to deposit into
     * @param associatedTokenAccount can be the wallet public key if using native sol
     * @param subAccountId subaccountId to deposit
     * @param reduceOnly if true, deposit must not increase account risk
     * @param txParams transaction parameters
     * @param initSwiftAccount if true, initialize a swift account for the user
     * @param overrides allows overriding authority for the deposit transaction
     */
    async deposit(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly = false, txParams, initSwiftAccount = false, overrides) {
        const tx = await this.createDepositTxn(amount, marketIndex, associatedTokenAccount, subAccountId, reduceOnly, txParams, initSwiftAccount, overrides);
        const { txSig, slot } = await this.sendTransaction(tx, [], this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getDepositInstruction(amount, marketIndex, userTokenAccount, subAccountId, reduceOnly = false, userInitialized = true, overrides) {
        var _a;
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId);
        let remainingAccounts = [];
        if (userInitialized) {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [await this.forceGetUserAccount(subAccountId)],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        else {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [],
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        this.addTokenMintToRemainingAccounts(spotMarketAccount, remainingAccounts);
        if (this.isTransferHook(spotMarketAccount)) {
            await this.addExtraAccountMetasToRemainingAccounts(spotMarketAccount.mint, remainingAccounts);
        }
        const authority = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.authority) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarketAccount);
        return await this.program.instruction.deposit(marketIndex, amount, reduceOnly, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                userTokenAccount: userTokenAccount,
                authority,
                tokenProgram,
            },
            remainingAccounts,
        });
    }
    async checkIfAccountExists(account) {
        try {
            const accountInfo = await this.connection.getAccountInfo(account);
            return accountInfo != null;
        }
        catch (e) {
            // Doesn't already exist
            return false;
        }
    }
    async getWrappedSolAccountCreationIxs(amount, includeRent, overrides) {
        var _a;
        const authority = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.authority) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        // Generate a random seed for wrappedSolAccount.
        const seed = web3_js_1.Keypair.generate().publicKey.toBase58().slice(0, 32);
        // Calculate a publicKey that will be controlled by the authority.
        const wrappedSolAccount = await web3_js_1.PublicKey.createWithSeed(authority, seed, spl_token_1.TOKEN_PROGRAM_ID);
        const result = {
            ixs: [],
            signers: [],
            pubkey: wrappedSolAccount,
        };
        const rentSpaceLamports = new anchor_1.BN(web3_js_1.LAMPORTS_PER_SOL / 100);
        const lamports = includeRent
            ? amount.add(rentSpaceLamports)
            : rentSpaceLamports;
        result.ixs.push(web3_js_1.SystemProgram.createAccountWithSeed({
            fromPubkey: authority,
            basePubkey: authority,
            seed,
            newAccountPubkey: wrappedSolAccount,
            lamports: lamports.toNumber(),
            space: 165,
            programId: spl_token_1.TOKEN_PROGRAM_ID,
        }));
        result.ixs.push((0, spl_token_1.createInitializeAccountInstruction)(wrappedSolAccount, spotMarkets_1.WRAPPED_SOL_MINT, authority));
        return result;
    }
    getTokenProgramForSpotMarket(spotMarketAccount) {
        if (this.isToken2022(spotMarketAccount)) {
            return spl_token_1.TOKEN_2022_PROGRAM_ID;
        }
        return spl_token_1.TOKEN_PROGRAM_ID;
    }
    isToken2022(spotMarketAccount) {
        return ((spotMarketAccount.tokenProgramFlag & types_1.TokenProgramFlag.Token2022) > 0);
    }
    isTransferHook(spotMarketAccount) {
        return ((spotMarketAccount.tokenProgramFlag & types_1.TokenProgramFlag.TransferHook) > 0);
    }
    addTokenMintToRemainingAccounts(spotMarketAccount, remainingAccounts) {
        if (this.isToken2022(spotMarketAccount)) {
            remainingAccounts.push({
                pubkey: spotMarketAccount.mint,
                isSigner: false,
                isWritable: false,
            });
        }
    }
    async addExtraAccountMetasToRemainingAccounts(mint, remainingAccounts) {
        const mintAccount = await (0, spl_token_1.getMint)(this.connection, mint, 'confirmed', spl_token_1.TOKEN_2022_PROGRAM_ID);
        const hookAccount = (0, spl_token_1.getTransferHook)(mintAccount);
        if (hookAccount.programId.equals(web3_js_1.PublicKey.default)) {
            return;
        }
        const extraAccountMetasAddress = (0, spl_token_1.getExtraAccountMetaAddress)(mint, hookAccount.programId);
        const extraAccountMetas = (0, spl_token_1.getExtraAccountMetas)(await this.connection.getAccountInfo(extraAccountMetasAddress));
        for (const acc of extraAccountMetas) {
            // assuming it's an extra account meta that does not rely on ix data
            const resolvedAcc = await (0, spl_token_1.resolveExtraAccountMeta)(this.connection, acc, remainingAccounts, Buffer.from([]), hookAccount.programId);
            remainingAccounts.push(resolvedAcc);
        }
        remainingAccounts.push({
            pubkey: hookAccount.programId,
            isSigner: false,
            isWritable: false,
        });
        remainingAccounts.push({
            pubkey: extraAccountMetasAddress,
            isSigner: false,
            isWritable: false,
        });
    }
    getAssociatedTokenAccountCreationIx(tokenMintAddress, associatedTokenAddress, tokenProgram) {
        return (0, spl_token_1.createAssociatedTokenAccountInstruction)(this.wallet.publicKey, associatedTokenAddress, this.wallet.publicKey, tokenMintAddress, tokenProgram);
    }
    async createInitializeUserAccountAndDepositCollateralIxs(amount, userTokenAccount, marketIndex = 0, subAccountId = 0, name, fromSubAccountId, referrerInfo, donateAmount, customMaxMarginRatio, poolId, overrides) {
        var _a;
        const ixs = [];
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo, overrides);
        // Check signed message orders account for the actual authority (account owner)
        const isSignedMsgUserOrdersAccountInitialized = await this.isSignedMsgUserOrdersAccountInitialized(this.authority);
        if (!isSignedMsgUserOrdersAccountInitialized) {
            const [, initializeSignedMsgUserOrdersAccountIx] = await this.getInitializeSignedMsgUserOrdersAccountIx(this.authority, 8, overrides);
            ixs.push(initializeSignedMsgUserOrdersAccountIx);
        }
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarket.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        // Use external wallet for deposit source if provided, otherwise use the wallet
        const depositSource = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.externalWallet) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        const isFromSubaccount = fromSubAccountId !== null &&
            fromSubAccountId !== undefined &&
            !isNaN(fromSubAccountId);
        donateAmount = donateAmount ? donateAmount : numericConstants_1.ZERO;
        const createWSOLTokenAccount = (isSolMarket &&
            userTokenAccount.equals(depositSource) &&
            !isFromSubaccount) ||
            !donateAmount.eq(numericConstants_1.ZERO);
        const wSolAmount = isSolMarket ? amount.add(donateAmount) : donateAmount;
        let wsolTokenAccount;
        if (createWSOLTokenAccount) {
            const { ixs: startIxs, pubkey } = await this.getWrappedSolAccountCreationIxs(wSolAmount, true, (overrides === null || overrides === void 0 ? void 0 : overrides.externalWallet)
                ? { authority: overrides.externalWallet }
                : undefined);
            wsolTokenAccount = pubkey;
            if (isSolMarket) {
                userTokenAccount = pubkey;
            }
            ixs.push(...startIxs);
        }
        // For Token2022 tokens, check if the user's token account exists and create it if it doesn't
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarket);
        if (!isSolMarket &&
            !isFromSubaccount &&
            !tokenProgram.equals(spl_token_1.TOKEN_PROGRAM_ID)) {
            const accountExists = await this.checkIfAccountExists(userTokenAccount);
            if (!accountExists) {
                const createAtaIx = this.getAssociatedTokenAccountCreationIx(spotMarket.mint, userTokenAccount, tokenProgram);
                ixs.push(createAtaIx);
            }
        }
        const depositCollateralIx = isFromSubaccount
            ? await this.getTransferDepositIx(amount, marketIndex, fromSubAccountId, subAccountId)
            : await this.getDepositInstruction(amount, marketIndex, userTokenAccount, subAccountId, false, false, (overrides === null || overrides === void 0 ? void 0 : overrides.externalWallet)
                ? { authority: overrides.externalWallet }
                : undefined);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                ixs.push(await this.getInitializeUserStatsIx(overrides));
            }
        }
        ixs.push(initializeUserAccountIx);
        if (poolId) {
            ixs.push(await this.getUpdateUserPoolIdIx(poolId, subAccountId));
        }
        ixs.push(depositCollateralIx);
        if (!donateAmount.eq(numericConstants_1.ZERO)) {
            const donateIx = await this.getDepositIntoSpotMarketRevenuePoolIx(1, donateAmount, wsolTokenAccount);
            ixs.push(donateIx);
        }
        // Set the max margin ratio to initialize account with if passed
        if (customMaxMarginRatio) {
            const customMarginRatioIx = await this.getUpdateUserCustomMarginRatioIx(customMaxMarginRatio, subAccountId);
            ixs.push(customMarginRatioIx);
        }
        // Close the wrapped sol account at the end of the transaction
        // Return funds to the deposit source (external wallet if provided)
        if (createWSOLTokenAccount) {
            ixs.push((0, spl_token_1.createCloseAccountInstruction)(wsolTokenAccount, depositSource, depositSource, []));
        }
        return {
            ixs,
            userAccountPublicKey,
        };
    }
    async createInitializeUserAccountAndDepositCollateral(amount, userTokenAccount, marketIndex = 0, subAccountId = 0, name, fromSubAccountId, referrerInfo, donateAmount, txParams, customMaxMarginRatio, poolId, overrides) {
        const { ixs, userAccountPublicKey } = await this.createInitializeUserAccountAndDepositCollateralIxs(amount, userTokenAccount, marketIndex, subAccountId, name, fromSubAccountId, referrerInfo, donateAmount, customMaxMarginRatio, poolId, overrides);
        const tx = await this.buildTransaction(ixs, txParams);
        return [tx, userAccountPublicKey];
    }
    /**
     * Creates the User account for a user, and deposits some initial collateral
     * @param amount
     * @param userTokenAccount
     * @param marketIndex
     * @param subAccountId
     * @param name
     * @param fromSubAccountId
     * @param referrerInfo
     * @param donateAmount
     * @param txParams
     * @param customMaxMarginRatio
     * @param poolId
     * @param overrides - Optional overrides including externalWallet for depositing from a different wallet
     * @returns
     */
    async initializeUserAccountAndDepositCollateral(amount, userTokenAccount, marketIndex = 0, subAccountId = 0, name, fromSubAccountId, referrerInfo, donateAmount, txParams, customMaxMarginRatio, poolId, overrides) {
        const [tx, userAccountPublicKey] = await this.createInitializeUserAccountAndDepositCollateral(amount, userTokenAccount, marketIndex, subAccountId, name, fromSubAccountId, referrerInfo, donateAmount, txParams, customMaxMarginRatio, poolId, overrides);
        const additionalSigners = [];
        const { txSig, slot } = await this.sendTransaction(tx, additionalSigners, this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async initializeUserAccountForDevnet(subAccountId = 0, name = userName_1.DEFAULT_USER_NAME, marketIndex, tokenFaucet, amount, referrerInfo, txParams) {
        const ixs = [];
        const [associateTokenPublicKey, createAssociatedAccountIx, mintToIx] = await tokenFaucet.createAssociatedTokenAccountAndMintToInstructions(this.wallet.publicKey, amount);
        const [userAccountPublicKey, initializeUserAccountIx] = await this.getInitializeUserInstructions(subAccountId, name, referrerInfo);
        const depositCollateralIx = await this.getDepositInstruction(amount, marketIndex, associateTokenPublicKey, subAccountId, false, false);
        ixs.push(createAssociatedAccountIx, mintToIx);
        if (subAccountId === 0) {
            if (!(await this.checkIfAccountExists(this.getUserStatsAccountPublicKey()))) {
                ixs.push(await this.getInitializeUserStatsIx());
            }
        }
        ixs.push(initializeUserAccountIx, depositCollateralIx);
        const tx = await this.buildTransaction(ixs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        await this.addUser(subAccountId);
        return [txSig, userAccountPublicKey];
    }
    async getWithdrawalIxs(amount, marketIndex, associatedTokenAddress, reduceOnly = false, subAccountId, _updateFuel = false) {
        const withdrawIxs = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const authority = this.wallet.publicKey;
        const createWSOLTokenAccount = isSolMarket && associatedTokenAddress.equals(authority);
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, false);
            associatedTokenAddress = pubkey;
            withdrawIxs.push(...ixs);
        }
        else {
            const accountExists = await this.checkIfAccountExists(associatedTokenAddress);
            if (!accountExists) {
                const createAssociatedTokenAccountIx = this.getAssociatedTokenAccountCreationIx(spotMarketAccount.mint, associatedTokenAddress, this.getTokenProgramForSpotMarket(spotMarketAccount));
                withdrawIxs.push(createAssociatedTokenAccountIx);
            }
        }
        const withdrawCollateralIx = await this.getWithdrawIx(amount, spotMarketAccount.marketIndex, associatedTokenAddress, reduceOnly, subAccountId);
        withdrawIxs.push(withdrawCollateralIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            withdrawIxs.push((0, spl_token_1.createCloseAccountInstruction)(associatedTokenAddress, authority, authority, []));
        }
        return withdrawIxs;
    }
    /**
     * Withdraws from a user account. If deposit doesn't already exist, creates a borrow
     * @param amount
     * @param marketIndex
     * @param associatedTokenAddress - the token account to withdraw to. can be the wallet public key if using native sol
     * @param reduceOnly
     */
    async withdraw(amount, marketIndex, associatedTokenAddress, reduceOnly = false, subAccountId, txParams, updateFuel = false) {
        const additionalSigners = [];
        const withdrawIxs = await this.getWithdrawalIxs(amount, marketIndex, associatedTokenAddress, reduceOnly, subAccountId, updateFuel);
        const tx = await this.buildTransaction(withdrawIxs, txParams !== null && txParams !== void 0 ? txParams : this.txParams);
        const { txSig, slot } = await this.sendTransaction(tx, additionalSigners, this.opts);
        this.spotMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async withdrawAllDustPositions(subAccountId, txParams, opts) {
        var _a, _b;
        const user = this.getUser(subAccountId);
        const dustPositionSpotMarketAccounts = user.getSpotMarketAccountsWithDustPosition();
        if (!dustPositionSpotMarketAccounts ||
            dustPositionSpotMarketAccounts.length === 0) {
            (_a = opts === null || opts === void 0 ? void 0 : opts.dustPositionCountCallback) === null || _a === void 0 ? void 0 : _a.call(opts, 0);
            return undefined;
        }
        (_b = opts === null || opts === void 0 ? void 0 : opts.dustPositionCountCallback) === null || _b === void 0 ? void 0 : _b.call(opts, dustPositionSpotMarketAccounts.length);
        let allWithdrawIxs = [];
        for (const position of dustPositionSpotMarketAccounts) {
            const tokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(position.mint, this.wallet.publicKey);
            const tokenAmount = await user.getTokenAmount(position.marketIndex);
            const withdrawIxs = await this.getWithdrawalIxs(tokenAmount.muln(2), //  2x to ensure all dust is withdrawn
            position.marketIndex, tokenAccount, true, // reduce-only true to ensure all dust is withdrawn
            subAccountId);
            allWithdrawIxs = allWithdrawIxs.concat(withdrawIxs);
        }
        const tx = await this.buildTransaction(allWithdrawIxs, txParams !== null && txParams !== void 0 ? txParams : this.txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getWithdrawIx(amount, marketIndex, userTokenAccount, reduceOnly = false, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [marketIndex],
            readableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        this.addTokenMintToRemainingAccounts(spotMarketAccount, remainingAccounts);
        if (this.isTransferHook(spotMarketAccount)) {
            await this.addExtraAccountMetasToRemainingAccounts(spotMarketAccount.mint, remainingAccounts);
        }
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarketAccount);
        return await this.program.instruction.withdraw(marketIndex, amount, reduceOnly, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                driftSigner: this.getSignerPublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                userTokenAccount: userTokenAccount,
                authority: this.wallet.publicKey,
                tokenProgram,
            },
            remainingAccounts,
        });
    }
    /**
     * Withdraws from the fromSubAccount and deposits into the toSubAccount
     * @param amount
     * @param marketIndex
     * @param fromSubAccountId
     * @param toSubAccountId
     * @param txParams
     */
    async transferDeposit(amount, marketIndex, fromSubAccountId, toSubAccountId, txParams) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getTransferDepositIx(amount, marketIndex, fromSubAccountId, toSubAccountId), txParams), [], this.opts);
        if (fromSubAccountId === this.activeSubAccountId ||
            toSubAccountId === this.activeSubAccountId) {
            this.spotMarketLastSlotCache.set(marketIndex, slot);
        }
        return txSig;
    }
    async getTransferDepositIx(amount, marketIndex, fromSubAccountId, toSubAccountId) {
        const fromUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, fromSubAccountId);
        const toUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, toSubAccountId);
        let remainingAccounts;
        const userMapKey = this.getUserMapKey(fromSubAccountId, this.wallet.publicKey);
        if (this.users.has(userMapKey)) {
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [this.users.get(userMapKey).getUserAccount()],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        else {
            const userAccountPublicKey = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.authority, fromSubAccountId);
            const fromUserAccount = (await this.program.account.user.fetch(userAccountPublicKey));
            remainingAccounts = this.getRemainingAccounts({
                userAccounts: [fromUserAccount],
                useMarketLastSlotCache: true,
                writableSpotMarketIndexes: [marketIndex],
            });
        }
        return await this.program.instruction.transferDeposit(marketIndex, amount, {
            accounts: {
                authority: this.wallet.publicKey,
                fromUser,
                toUser,
                userStats: this.getUserStatsAccountPublicKey(),
                state: await this.getStatePublicKey(),
                spotMarketVault: this.getSpotMarketAccount(marketIndex).vault,
            },
            remainingAccounts,
        });
    }
    async transferPools(depositFromMarketIndex, depositToMarketIndex, borrowFromMarketIndex, borrowToMarketIndex, depositAmount, borrowAmount, fromSubAccountId, toSubAccountId, txParams) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getTransferPoolsIx(depositFromMarketIndex, depositToMarketIndex, borrowFromMarketIndex, borrowToMarketIndex, depositAmount, borrowAmount, fromSubAccountId, toSubAccountId), txParams), [], this.opts);
        if (fromSubAccountId === this.activeSubAccountId ||
            toSubAccountId === this.activeSubAccountId) {
            this.spotMarketLastSlotCache.set(depositFromMarketIndex, slot);
            this.spotMarketLastSlotCache.set(depositToMarketIndex, slot);
            this.spotMarketLastSlotCache.set(borrowFromMarketIndex, slot);
            this.spotMarketLastSlotCache.set(borrowToMarketIndex, slot);
        }
        return txSig;
    }
    async getTransferPoolsIx(depositFromMarketIndex, depositToMarketIndex, borrowFromMarketIndex, borrowToMarketIndex, depositAmount, borrowAmount, fromSubAccountId, toSubAccountId, isToNewSubAccount) {
        const fromUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, fromSubAccountId);
        const toUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey, toSubAccountId);
        const userAccounts = [this.getUserAccount(fromSubAccountId)];
        if (!isToNewSubAccount) {
            userAccounts.push(this.getUserAccount(toSubAccountId));
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [
                depositFromMarketIndex,
                depositToMarketIndex,
                borrowFromMarketIndex,
                borrowToMarketIndex,
            ],
        });
        const tokenPrograms = new Set();
        const depositFromSpotMarket = this.getSpotMarketAccount(depositFromMarketIndex);
        const borrowFromSpotMarket = this.getSpotMarketAccount(borrowFromMarketIndex);
        tokenPrograms.add(this.getTokenProgramForSpotMarket(depositFromSpotMarket).toBase58());
        tokenPrograms.add(this.getTokenProgramForSpotMarket(borrowFromSpotMarket).toBase58());
        for (const tokenProgram of tokenPrograms) {
            remainingAccounts.push({
                isSigner: false,
                isWritable: false,
                pubkey: new web3_js_1.PublicKey(tokenProgram),
            });
        }
        return await this.program.instruction.transferPools(depositFromMarketIndex, depositToMarketIndex, borrowFromMarketIndex, borrowToMarketIndex, depositAmount !== null && depositAmount !== void 0 ? depositAmount : null, borrowAmount !== null && borrowAmount !== void 0 ? borrowAmount : null, {
            accounts: {
                authority: this.wallet.publicKey,
                fromUser,
                toUser,
                userStats: this.getUserStatsAccountPublicKey(),
                state: await this.getStatePublicKey(),
                depositFromSpotMarketVault: this.getSpotMarketAccount(depositFromMarketIndex).vault,
                depositToSpotMarketVault: this.getSpotMarketAccount(depositToMarketIndex).vault,
                borrowFromSpotMarketVault: this.getSpotMarketAccount(borrowFromMarketIndex).vault,
                borrowToSpotMarketVault: this.getSpotMarketAccount(borrowToMarketIndex).vault,
                driftSigner: this.getSignerPublicKey(),
            },
            remainingAccounts,
        });
    }
    async transferPerpPosition(fromSubAccountId, toSubAccountId, marketIndex, amount, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getTransferPerpPositionIx(fromSubAccountId, toSubAccountId, marketIndex, amount), txParams), [], this.opts);
        return txSig;
    }
    async getTransferPerpPositionIx(fromSubAccountId, toSubAccountId, marketIndex, amount) {
        const fromUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, fromSubAccountId);
        const toUser = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, toSubAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                this.getUserAccount(fromSubAccountId),
                this.getUserAccount(toSubAccountId),
            ],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        return await this.program.instruction.transferPerpPosition(marketIndex, amount !== null && amount !== void 0 ? amount : null, {
            accounts: {
                authority: this.wallet.publicKey,
                fromUser,
                toUser,
                userStats: this.getUserStatsAccountPublicKey(),
                state: await this.getStatePublicKey(),
            },
            remainingAccounts,
        });
    }
    async depositIntoIsolatedPerpPosition(amount, perpMarketIndex, userTokenAccount, subAccountId, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getDepositIntoIsolatedPerpPositionIx(amount, perpMarketIndex, userTokenAccount, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getDepositIntoIsolatedPerpPositionIx(amount, perpMarketIndex, userTokenAccount, subAccountId) {
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId);
        const perpMarketAccount = this.getPerpMarketAccount(perpMarketIndex);
        const spotMarketIndex = perpMarketAccount.quoteSpotMarketIndex;
        const spotMarketAccount = this.getSpotMarketAccount(spotMarketIndex);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            writableSpotMarketIndexes: [spotMarketIndex],
            readablePerpMarketIndex: [perpMarketIndex],
        });
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarketAccount);
        return await this.program.instruction.depositIntoIsolatedPerpPosition(spotMarketIndex, perpMarketIndex, amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarketVault: spotMarketAccount.vault,
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                userTokenAccount: userTokenAccount,
                authority: this.wallet.publicKey,
                tokenProgram,
            },
            remainingAccounts,
        });
    }
    async transferIsolatedPerpPositionDeposit(amount, perpMarketIndex, subAccountId, txParams, trySettle, noBuffer) {
        const ixs = [];
        const tokenAmountDeposited = this.getIsolatedPerpPositionTokenAmount(perpMarketIndex);
        const transferIx = await this.getTransferIsolatedPerpPositionDepositIx(amount, perpMarketIndex, subAccountId, noBuffer);
        const needsToSettle = amount.lt(tokenAmountDeposited.neg()) || amount.eq(numericConstants_1.MIN_I64) || trySettle;
        if (needsToSettle) {
            const settleIx = await this.settleMultiplePNLsIx(await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId), this.getUserAccount(subAccountId), [perpMarketIndex], types_1.SettlePnlMode.TRY_SETTLE);
            ixs.push(settleIx);
        }
        ixs.push(transferIx);
        const tx = await this.buildTransaction(ixs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], {
            ...this.opts,
            skipPreflight: true,
        });
        return txSig;
    }
    async getTransferIsolatedPerpPositionDepositIx(amount, perpMarketIndex, subAccountId, noAmountBuffer, signingAuthority) {
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId);
        const perpMarketAccount = this.getPerpMarketAccount(perpMarketIndex);
        const spotMarketIndex = perpMarketAccount.quoteSpotMarketIndex;
        const spotMarketAccount = this.getSpotMarketAccount(spotMarketIndex);
        const user = await this.getUserAccount(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [user],
            writableSpotMarketIndexes: [spotMarketIndex],
            readablePerpMarketIndex: [perpMarketIndex],
        });
        const amountWithBuffer = noAmountBuffer || amount.eq(numericConstants_1.MIN_I64)
            ? amount
            : amount.add(amount.div(new anchor_1.BN(200))); // .5% buffer
        return await this.program.instruction.transferIsolatedPerpPositionDeposit(spotMarketIndex, perpMarketIndex, amountWithBuffer, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarketVault: spotMarketAccount.vault,
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: signingAuthority !== null && signingAuthority !== void 0 ? signingAuthority : this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async withdrawFromIsolatedPerpPosition(amount, perpMarketIndex, userTokenAccount, subAccountId, txParams) {
        const instructions = await this.getWithdrawFromIsolatedPerpPositionIxsBundle(amount, perpMarketIndex, subAccountId, userTokenAccount);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(instructions, txParams));
        return txSig;
    }
    async getWithdrawFromIsolatedPerpPositionIxsBundle(amount, perpMarketIndex, subAccountId, userTokenAccount) {
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId);
        const userAccount = this.getUserAccount(subAccountId);
        const tokenAmountDeposited = this.getIsolatedPerpPositionTokenAmount(perpMarketIndex);
        const isolatedPositionUnrealizedPnl = (0, position_1.calculateClaimablePnl)(this.getPerpMarketAccount(perpMarketIndex), this.getSpotMarketAccount(this.getPerpMarketAccount(perpMarketIndex).quoteSpotMarketIndex), userAccount.perpPositions.find((p) => p.marketIndex === perpMarketIndex), this.getOracleDataForSpotMarket(this.getPerpMarketAccount(perpMarketIndex).quoteSpotMarketIndex));
        const depositAmountPlusUnrealizedPnl = tokenAmountDeposited.add(isolatedPositionUnrealizedPnl);
        const amountToWithdraw = amount.gt(depositAmountPlusUnrealizedPnl)
            ? numericConstants_1.MIN_I64 // min i64
            : amount;
        let associatedTokenAccount = userTokenAccount;
        if (!associatedTokenAccount) {
            const perpMarketAccount = this.getPerpMarketAccount(perpMarketIndex);
            const quoteSpotMarketIndex = perpMarketAccount.quoteSpotMarketIndex;
            associatedTokenAccount = await this.getAssociatedTokenAccount(quoteSpotMarketIndex);
        }
        const withdrawIx = await this.getWithdrawFromIsolatedPerpPositionIx(amountToWithdraw, perpMarketIndex, associatedTokenAccount, subAccountId);
        const ixs = [withdrawIx];
        const needsToSettle = amount.gt(tokenAmountDeposited) && isolatedPositionUnrealizedPnl.gt(numericConstants_1.ZERO);
        if (needsToSettle) {
            const settleIx = await this.settleMultiplePNLsIx(userAccountPublicKey, userAccount, [perpMarketIndex], types_1.SettlePnlMode.TRY_SETTLE);
            ixs.push(settleIx);
        }
        return ixs;
    }
    async getWithdrawFromIsolatedPerpPositionIx(amount, perpMarketIndex, userTokenAccount, subAccountId) {
        const userAccountPublicKey = await (0, pda_1.getUserAccountPublicKey)(this.program.programId, this.authority, subAccountId !== null && subAccountId !== void 0 ? subAccountId : this.activeSubAccountId);
        const perpMarketAccount = this.getPerpMarketAccount(perpMarketIndex);
        const spotMarketIndex = perpMarketAccount.quoteSpotMarketIndex;
        const spotMarketAccount = this.getSpotMarketAccount(spotMarketIndex);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            writableSpotMarketIndexes: [spotMarketIndex],
            readablePerpMarketIndex: [perpMarketIndex],
        });
        return await this.program.instruction.withdrawFromIsolatedPerpPosition(spotMarketIndex, perpMarketIndex, amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarketVault: spotMarketAccount.vault,
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                userTokenAccount: userTokenAccount,
                tokenProgram: this.getTokenProgramForSpotMarket(spotMarketAccount),
                driftSigner: this.getSignerPublicKey(),
            },
            remainingAccounts,
        });
    }
    async updateSpotMarketCumulativeInterest(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.updateSpotMarketCumulativeInterestIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async updateSpotMarketCumulativeInterestIx(marketIndex) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        return await this.program.instruction.updateSpotMarketCumulativeInterest({
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                spotMarketVault: spotMarket.vault,
                oracle: spotMarket.oracle,
            },
        });
    }
    async settleLP(settleeUserAccountPublicKey, marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.settleLPIx(settleeUserAccountPublicKey, marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async settleLPIx(settleeUserAccountPublicKey, marketIndex) {
        const settleeUserAccount = (await this.program.account.user.fetch(settleeUserAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [settleeUserAccount],
            writablePerpMarketIndexes: [marketIndex],
        });
        return this.program.instruction.settleLp(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: settleeUserAccountPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async removePerpLpShares(marketIndex, sharesToBurn, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getRemovePerpLpSharesIx(marketIndex, sharesToBurn, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async removePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getRemovePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn), txParams), [], this.opts);
        return txSig;
    }
    async getRemovePerpLpSharesInExpiringMarket(marketIndex, userAccountPublicKey, sharesToBurn) {
        const userAccount = (await this.program.account.user.fetch(userAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writablePerpMarketIndexes: [marketIndex],
        });
        if (sharesToBurn == undefined) {
            const perpPosition = userAccount.perpPositions.filter((position) => position.marketIndex === marketIndex)[0];
            sharesToBurn = perpPosition.lpShares;
            console.log('burning lp shares:', sharesToBurn.toString());
        }
        return this.program.instruction.removePerpLpSharesInExpiringMarket(sharesToBurn, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getRemovePerpLpSharesIx(marketIndex, sharesToBurn, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        if (sharesToBurn == undefined) {
            const userAccount = this.getUserAccount(subAccountId);
            const perpPosition = userAccount.perpPositions.filter((position) => position.marketIndex === marketIndex)[0];
            sharesToBurn = perpPosition.lpShares;
            console.log('burning lp shares:', sharesToBurn.toString());
        }
        return this.program.instruction.removePerpLpShares(sharesToBurn, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async addPerpLpShares(amount, marketIndex, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getAddPerpLpSharesIx(amount, marketIndex, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getAddPerpLpSharesIx(amount, marketIndex, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        return this.program.instruction.addPerpLpShares(amount, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    getQuoteValuePerLpShare(marketIndex) {
        const perpMarketAccount = this.getPerpMarketAccount(marketIndex);
        const openBids = anchor_1.BN.max(perpMarketAccount.amm.baseAssetReserve.sub(perpMarketAccount.amm.minBaseAssetReserve), numericConstants_1.ZERO);
        const openAsks = anchor_1.BN.max(perpMarketAccount.amm.maxBaseAssetReserve.sub(perpMarketAccount.amm.baseAssetReserve), numericConstants_1.ZERO);
        const oraclePriceData = this.getOracleDataForPerpMarket(marketIndex);
        const maxOpenBidsAsks = anchor_1.BN.max(openBids, openAsks);
        const quoteValuePerLpShare = maxOpenBidsAsks
            .mul(oraclePriceData.price)
            .mul(numericConstants_1.QUOTE_PRECISION)
            .div(numericConstants_1.PRICE_PRECISION)
            .div(perpMarketAccount.amm.sqrtK);
        return quoteValuePerLpShare;
    }
    /**
     * @deprecated use {@link placePerpOrder} or {@link placeAndTakePerpOrder} instead
     */
    async openPosition(direction, amount, marketIndex, limitPrice, subAccountId) {
        return await this.placeAndTakePerpOrder({
            orderType: types_1.OrderType.MARKET,
            marketIndex,
            direction,
            baseAssetAmount: amount,
            price: limitPrice,
        }, undefined, undefined, undefined, undefined, undefined, subAccountId);
    }
    async sendSignedTx(tx, opts) {
        const { txSig } = await this.sendTransaction(tx, undefined, opts !== null && opts !== void 0 ? opts : this.opts, true);
        return txSig;
    }
    async prepareMarketOrderTxs(orderParams, userAccountPublicKey, userAccount, makerInfo, txParams, bracketOrdersParams = new Array(), referrerInfo, cancelExistingOrders, settlePnl, positionMaxLev, isolatedPositionDepositAmount) {
        const marketIndex = orderParams.marketIndex;
        const orderId = userAccount.nextOrderId;
        const ixPromisesForTxs = {
            cancelExistingOrdersTx: undefined,
            settlePnlTx: undefined,
            fillTx: undefined,
            marketOrderTx: undefined,
        };
        const txKeys = Object.keys(ixPromisesForTxs);
        const preIxs = await this.getPrePlaceOrderIxs(orderParams, userAccount, {
            positionMaxLev,
            isolatedPositionDepositAmount,
        });
        ixPromisesForTxs.marketOrderTx = (async () => {
            const placeOrdersIx = await this.getPlaceOrdersIx([orderParams, ...bracketOrdersParams], userAccount.subAccountId);
            if (preIxs.length) {
                return [...preIxs, placeOrdersIx];
            }
            return placeOrdersIx;
        })();
        /* Cancel open orders in market if requested */
        if (cancelExistingOrders && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
            ixPromisesForTxs.cancelExistingOrdersTx = this.getCancelOrdersIx(orderParams.marketType, orderParams.marketIndex, null, userAccount.subAccountId);
        }
        /* Settle PnL after fill if requested */
        if (settlePnl && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
            ixPromisesForTxs.settlePnlTx = this.settlePNLIx(userAccountPublicKey, userAccount, marketIndex);
        }
        // use versioned transactions if there is a lookup table account and wallet is compatible
        if (this.txVersion === 0) {
            ixPromisesForTxs.fillTx = this.getFillPerpOrderIx(userAccountPublicKey, userAccount, {
                orderId,
                marketIndex,
            }, makerInfo, referrerInfo, userAccount.subAccountId);
        }
        const ixs = await Promise.all(Object.values(ixPromisesForTxs));
        const ixsMap = ixs.reduce((acc, ix, i) => {
            acc[txKeys[i]] = ix;
            return acc;
        }, {});
        const txsMap = (await this.buildTransactionsMap(ixsMap, txParams));
        return txsMap;
    }
    /**
     * Sends a market order and returns a signed tx which can fill the order against the vamm, which the caller can use to fill their own order if required.
     * @param orderParams
     * @param userAccountPublicKey
     * @param userAccount
     * @param makerInfo
     * @param txParams
     * @param bracketOrdersParams
     * @param cancelExistingOrders - Builds and returns an extra transaciton to cancel the existing orders in the same perp market. Intended use is to auto-cancel TP/SL orders when closing a position. Ignored if orderParams.marketType is not MarketType.PERP
     * @returns
     */
    async sendMarketOrderAndGetSignedFillTx(orderParams, userAccountPublicKey, userAccount, makerInfo, txParams, bracketOrdersParams = new Array(), referrerInfo, cancelExistingOrders, settlePnl) {
        const preppedTxs = await this.prepareMarketOrderTxs(orderParams, userAccountPublicKey, userAccount, makerInfo, txParams, bracketOrdersParams, referrerInfo, cancelExistingOrders, settlePnl);
        const signedTxs = (await this.txHandler.getSignedTransactionMap(preppedTxs, this.wallet)).signedTxMap;
        const { txSig, slot } = await this.sendTransaction(signedTxs.marketOrderTx, [], this.opts, true);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return {
            txSig,
            signedFillTx: signedTxs.fillTx,
            signedCancelExistingOrdersTx: signedTxs.cancelExistingOrdersTx,
            signedSettlePnlTx: signedTxs.settlePnlTx,
        };
    }
    async placePerpOrder(orderParams, txParams, subAccountId, isolatedPositionDepositAmount) {
        var _a;
        const preIxs = [];
        if (((_a = isolatedPositionDepositAmount === null || isolatedPositionDepositAmount === void 0 ? void 0 : isolatedPositionDepositAmount.gt) === null || _a === void 0 ? void 0 : _a.call(isolatedPositionDepositAmount, numericConstants_1.ZERO)) &&
            this.isOrderIncreasingPosition(orderParams, subAccountId)) {
            preIxs.push(await this.getTransferIsolatedPerpPositionDepositIx(isolatedPositionDepositAmount, orderParams.marketIndex, subAccountId));
        }
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlacePerpOrderIx(orderParams, subAccountId), txParams, undefined, undefined, undefined, undefined, preIxs), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async getPlacePerpOrderIx(orderParams, subAccountId, depositToTradeArgs) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const isDepositToTradeTx = depositToTradeArgs !== undefined;
        const user = isDepositToTradeTx
            ? (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.authority, subAccountId)
            : await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: (depositToTradeArgs === null || depositToTradeArgs === void 0 ? void 0 : depositToTradeArgs.isMakingNewAccount)
                ? []
                : [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: false,
            readablePerpMarketIndex: orderParams.marketIndex,
            readableSpotMarketIndexes: isDepositToTradeTx
                ? [depositToTradeArgs === null || depositToTradeArgs === void 0 ? void 0 : depositToTradeArgs.depositMarketIndex]
                : undefined,
        });
        if ((0, orderParams_1.isUpdateHighLeverageMode)(orderParams.bitFlags)) {
            remainingAccounts.push({
                pubkey: (0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId),
                isWritable: true,
                isSigner: false,
            });
        }
        return await this.program.instruction.placePerpOrder(orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateAMMs(marketIndexes, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateAMMsIx(marketIndexes), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateAMMsIx(marketIndexes) {
        const marketAccountInfos = [];
        const oracleAccountInfos = [];
        for (const marketIndex of marketIndexes) {
            const market = this.getPerpMarketAccount(marketIndex);
            marketAccountInfos.push({
                pubkey: market.pubkey,
                isWritable: true,
                isSigner: false,
            });
            oracleAccountInfos.push({
                pubkey: market.amm.oracle,
                isWritable: false,
                isSigner: false,
            });
        }
        const remainingAccounts = oracleAccountInfos.concat(marketAccountInfos);
        return await this.program.instruction.updateAmms(marketIndexes, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async settleExpiredMarket(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSettleExpiredMarketIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getSettleExpiredMarketIx(marketIndex) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            writablePerpMarketIndexes: [marketIndex],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, marketIndex);
        return await this.program.instruction.settleExpiredMarket(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                admin: this.isSubscribed
                    ? this.getStateAccount().admin
                    : this.wallet.publicKey,
                perpMarket: perpMarketPublicKey,
            },
            remainingAccounts,
        });
    }
    async settleExpiredMarketPoolsToRevenuePool(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSettleExpiredMarketPoolsToRevenuePoolIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getSettleExpiredMarketPoolsToRevenuePoolIx(perpMarketIndex) {
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, perpMarketIndex);
        const spotMarketPublicKey = await (0, pda_1.getSpotMarketPublicKey)(this.program.programId, numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        return await this.program.instruction.settleExpiredMarketPoolsToRevenuePool({
            accounts: {
                state: await this.getStatePublicKey(),
                admin: this.isSubscribed
                    ? this.getStateAccount().admin
                    : this.wallet.publicKey,
                spotMarket: spotMarketPublicKey,
                perpMarket: perpMarketPublicKey,
            },
        });
    }
    async cancelOrder(orderId, txParams, subAccountId, overrides) {
        const cancelIx = await this.getCancelOrderIx(orderId, subAccountId);
        const instructions = [cancelIx];
        if ((overrides === null || overrides === void 0 ? void 0 : overrides.withdrawIsolatedDepositAmount) !== undefined) {
            const order = this.getOrder(orderId, subAccountId);
            const perpMarketIndex = order === null || order === void 0 ? void 0 : order.marketIndex;
            const withdrawAmount = overrides.withdrawIsolatedDepositAmount;
            if (withdrawAmount.gt(numericConstants_1.ZERO)) {
                const withdrawIxs = await this.getWithdrawFromIsolatedPerpPositionIxsBundle(withdrawAmount, perpMarketIndex, subAccountId);
                instructions.push(...withdrawIxs);
            }
        }
        const { txSig } = await this.sendTransaction(await this.buildTransaction(instructions, txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrderIx(orderId, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrder(orderId !== null && orderId !== void 0 ? orderId : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async cancelOrderByUserId(userOrderId, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrderByUserIdIx(userOrderId, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrderByUserIdIx(userOrderId, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const order = this.getOrderByUserId(userOrderId);
        const oracle = this.getPerpMarketAccount(order.marketIndex).amm.oracle;
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrderByUserId(userOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
                oracle,
            },
            remainingAccounts,
        });
    }
    /**
     * Sends a transaction to cancel the provided order ids.
     *
     * @param orderIds - The order ids to cancel.
     * @param txParams - The transaction parameters.
     * @param subAccountId - The sub account id to cancel the orders for.
     * @param user - The user to cancel the orders for. If provided, it will be prioritized over the subAccountId.
     * @returns The transaction signature.
     */
    async cancelOrdersByIds(orderIds, txParams, subAccountId, user, overrides) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrdersByIdsIx(orderIds, subAccountId, user, overrides), txParams), [], this.opts);
        return txSig;
    }
    /**
     * Returns the transaction instruction to cancel the provided order ids.
     *
     * @param orderIds - The order ids to cancel.
     * @param subAccountId - The sub account id to cancel the orders for.
     * @param user - The user to cancel the orders for. If provided, it will be prioritized over the subAccountId.
     * @returns The transaction instruction to cancel the orders.
     */
    async getCancelOrdersByIdsIx(orderIds, subAccountId, user, overrides) {
        var _a, _b, _c;
        const userAccountPubKey = (_a = user === null || user === void 0 ? void 0 : user.userAccountPublicKey) !== null && _a !== void 0 ? _a : (await this.getUserAccountPublicKey(subAccountId));
        const userAccount = (_b = user === null || user === void 0 ? void 0 : user.getUserAccount()) !== null && _b !== void 0 ? _b : this.getUserAccount(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            useMarketLastSlotCache: true,
        });
        const authority = (_c = overrides === null || overrides === void 0 ? void 0 : overrides.authority) !== null && _c !== void 0 ? _c : this.wallet.publicKey;
        return await this.program.instruction.cancelOrdersByIds(orderIds, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPubKey,
                authority,
            },
            remainingAccounts,
        });
    }
    async cancelOrders(marketType, marketIndex, direction, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCancelOrdersIx(marketType, marketIndex, direction, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getCancelOrdersIx(marketType, marketIndex, direction, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        let readablePerpMarketIndex = undefined;
        let readableSpotMarketIndexes = undefined;
        if (typeof marketIndex === 'number') {
            if (marketType && (0, types_1.isVariant)(marketType, 'perp')) {
                readablePerpMarketIndex = marketIndex;
            }
            else if (marketType && (0, types_1.isVariant)(marketType, 'spot')) {
                readableSpotMarketIndexes = [marketIndex];
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            readablePerpMarketIndex,
            readableSpotMarketIndexes,
            useMarketLastSlotCache: true,
        });
        return await this.program.instruction.cancelOrders(marketType !== null && marketType !== void 0 ? marketType : null, marketIndex !== null && marketIndex !== void 0 ? marketIndex : null, direction !== null && direction !== void 0 ? direction : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async cancelAndPlaceOrders(cancelOrderParams, placeOrderParams, txParams, subAccountId) {
        const ixs = [
            await this.getCancelOrdersIx(cancelOrderParams.marketType, cancelOrderParams.marketIndex, cancelOrderParams.direction, subAccountId),
            await this.getPlaceOrdersIx(placeOrderParams, subAccountId),
        ];
        const tx = await this.buildTransaction(ixs, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async placeOrders(params, txParams, subAccountId, optionalIxs, isolatedPositionDepositAmount) {
        const { txSig } = await this.sendTransaction((await this.preparePlaceOrdersTx(params, txParams, subAccountId, optionalIxs, isolatedPositionDepositAmount)).placeOrdersTx, [], this.opts, false);
        return txSig;
    }
    async preparePlaceOrdersTx(params, txParams, subAccountId, optionalIxs, isolatedPositionDepositAmount) {
        var _a;
        const lookupTableAccounts = await this.fetchAllLookupTableAccounts();
        const preIxs = [];
        if ((params === null || params === void 0 ? void 0 : params.length) === 1) {
            const p = params[0];
            if ((0, types_1.isVariant)(p.marketType, 'perp') &&
                ((_a = isolatedPositionDepositAmount === null || isolatedPositionDepositAmount === void 0 ? void 0 : isolatedPositionDepositAmount.gt) === null || _a === void 0 ? void 0 : _a.call(isolatedPositionDepositAmount, numericConstants_1.ZERO)) &&
                this.isOrderIncreasingPosition(p, subAccountId)) {
                preIxs.push(await this.getTransferIsolatedPerpPositionDepositIx(isolatedPositionDepositAmount, p.marketIndex, subAccountId));
            }
        }
        const tx = await this.buildTransaction(await this.getPlaceOrdersIx(params, subAccountId), txParams, undefined, lookupTableAccounts, undefined, undefined, [...preIxs, ...(optionalIxs !== null && optionalIxs !== void 0 ? optionalIxs : [])]);
        return {
            placeOrdersTx: tx,
        };
    }
    async getPlaceOrdersIx(params, subAccountId, overrides) {
        var _a;
        const user = await this.getUserAccountPublicKey(subAccountId);
        const readablePerpMarketIndex = [];
        const readableSpotMarketIndexes = [];
        for (const param of params) {
            if (!param.marketType) {
                throw new Error('must set param.marketType');
            }
            if ((0, types_1.isVariant)(param.marketType, 'perp')) {
                readablePerpMarketIndex.push(param.marketIndex);
            }
            else {
                readableSpotMarketIndexes.push(param.marketIndex);
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            readablePerpMarketIndex,
            readableSpotMarketIndexes,
            useMarketLastSlotCache: true,
        });
        for (const param of params) {
            if ((0, orderParams_1.isUpdateHighLeverageMode)(param.bitFlags)) {
                remainingAccounts.push({
                    pubkey: (0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId),
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
        const formattedParams = params.map((item) => (0, orderParams_1.getOrderParams)(item));
        const authority = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.authority) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        return await this.program.instruction.placeOrders(formattedParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority,
            },
            remainingAccounts,
        });
    }
    async getPlaceOrdersAndSetPositionMaxLevIx(params, positionMaxLev, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const readablePerpMarketIndex = [];
        const readableSpotMarketIndexes = [];
        for (const param of params) {
            if (!param.marketType) {
                throw new Error('must set param.marketType');
            }
            if ((0, types_1.isVariant)(param.marketType, 'perp')) {
                readablePerpMarketIndex.push(param.marketIndex);
            }
            else {
                readableSpotMarketIndexes.push(param.marketIndex);
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            readablePerpMarketIndex,
            readableSpotMarketIndexes,
            useMarketLastSlotCache: true,
        });
        for (const param of params) {
            if ((0, orderParams_1.isUpdateHighLeverageMode)(param.bitFlags)) {
                remainingAccounts.push({
                    pubkey: (0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId),
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
        const formattedParams = params.map((item) => (0, orderParams_1.getOrderParams)(item));
        const placeOrdersIxs = await this.program.instruction.placeOrders(formattedParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
        const marginRatio = Math.floor((1 / positionMaxLev) * numericConstants_1.MARGIN_PRECISION.toNumber());
        // Keep existing behavior but note: prefer using getPostPlaceOrderIxs path
        const setPositionMaxLevIxs = await this.getUpdateUserPerpPositionCustomMarginRatioIx(readablePerpMarketIndex[0], marginRatio, subAccountId);
        return [placeOrdersIxs, setPositionMaxLevIxs];
    }
    async fillPerpOrder(userAccountPublicKey, user, order, makerInfo, referrerInfo, txParams, fillerSubAccountId, fillerAuthority, hasBuilderFee) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getFillPerpOrderIx(userAccountPublicKey, user, order, makerInfo, referrerInfo, fillerSubAccountId, undefined, fillerAuthority, hasBuilderFee), txParams), [], this.opts);
        return txSig;
    }
    async getFillPerpOrderIx(userAccountPublicKey, userAccount, order, makerInfo, referrerInfo, fillerSubAccountId, isSignedMsg, fillerAuthority, hasBuilderFee) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        let filler;
        if (fillerAuthority) {
            filler = (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, fillerAuthority, fillerSubAccountId);
        }
        else {
            filler = await this.getUserAccountPublicKey(fillerSubAccountId);
        }
        let fillerStatsPublicKey;
        if (fillerAuthority) {
            fillerStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, fillerAuthority);
        }
        else {
            fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        }
        const marketIndex = order
            ? order.marketIndex
            : userAccount.orders.find((order) => order.orderId === userAccount.nextOrderId - 1).marketIndex;
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [userAccount];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writablePerpMarketIndexes: [marketIndex],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        if (referrerInfo) {
            const referrerIsMaker = makerInfo.find((maker) => maker.maker.equals(referrerInfo.referrer)) !==
                undefined;
            if (!referrerIsMaker) {
                remainingAccounts.push({
                    pubkey: referrerInfo.referrer,
                    isWritable: true,
                    isSigner: false,
                });
                remainingAccounts.push({
                    pubkey: referrerInfo.referrerStats,
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
        let withBuilder = false;
        if (hasBuilderFee) {
            withBuilder = true;
        }
        else {
            // figure out if we need builder account or not
            if (order && !isSignedMsg) {
                const userOrder = userAccount.orders.find((o) => o.orderId === order.orderId);
                if (userOrder) {
                    withBuilder = (0, orders_1.hasBuilder)(userOrder);
                }
            }
            else if (isSignedMsg) {
                // Order hasn't been placed yet, we cant tell if it has a builder or not.
                // Include it optimistically
                withBuilder = true;
            }
        }
        if (withBuilder) {
            remainingAccounts.push({
                pubkey: (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, userAccount.authority),
                isWritable: true,
                isSigner: false,
            });
        }
        const orderId = isSignedMsg ? null : order.orderId;
        return await this.program.instruction.fillPerpOrder(orderId, null, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                fillerStats: fillerStatsPublicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async getRevertFillIx(fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        return this.program.instruction.revertFill({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                fillerStats: fillerStatsPublicKey,
                authority: this.wallet.publicKey,
            },
        });
    }
    async placeSpotOrder(orderParams, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction((await this.preparePlaceSpotOrderTx(orderParams, txParams, subAccountId))
            .placeSpotOrderTx, [], this.opts, false);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async preparePlaceSpotOrderTx(orderParams, txParams, subAccountId) {
        const tx = await this.buildTransaction(await this.getPlaceSpotOrderIx(orderParams, subAccountId), txParams);
        return {
            placeSpotOrderTx: tx,
        };
    }
    async getPlaceSpotOrderIx(orderParams, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.SPOT });
        const userAccountPublicKey = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
            readableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        return await this.program.instruction.placeSpotOrder(orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async fillSpotOrder(userAccountPublicKey, user, order, fulfillmentConfig, makerInfo, referrerInfo, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getFillSpotOrderIx(userAccountPublicKey, user, order, fulfillmentConfig, makerInfo, referrerInfo), txParams), [], this.opts);
        return txSig;
    }
    async getFillSpotOrderIx(userAccountPublicKey, userAccount, order, fulfillmentConfig, makerInfo, referrerInfo, fillerPublicKey) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const fillerStatsPublicKey = this.getUserStatsAccountPublicKey();
        const marketIndex = order
            ? order.marketIndex
            : userAccount.orders.find((order) => order.orderId === userAccount.nextOrderId - 1).marketIndex;
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [userAccount];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writableSpotMarketIndexes: [marketIndex, numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const orderId = order.orderId;
        this.addSpotFulfillmentAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
        return await this.program.instruction.fillSpotOrder(orderId, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, null, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                fillerStats: fillerStatsPublicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    addSpotFulfillmentAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        if (fulfillmentConfig) {
            if ('serumProgramId' in fulfillmentConfig) {
                this.addSerumRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
            }
            else if ('phoenixProgramId' in fulfillmentConfig) {
                this.addPhoenixRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
            }
            else if ('openbookV2ProgramId' in fulfillmentConfig) {
                this.addOpenbookRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig);
            }
            else {
                throw Error('Invalid fulfillment config type');
            }
        }
        else {
            remainingAccounts.push({
                pubkey: this.getSpotMarketAccount(marketIndex).vault,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: this.getQuoteSpotMarketAccount().vault,
                isWritable: false,
                isSigner: false,
            });
        }
    }
    addSerumRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        remainingAccounts.push({
            pubkey: fulfillmentConfig.pubkey,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumProgramId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumMarket,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumRequestQueue,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumEventQueue,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumBids,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumAsks,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumBaseVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumQuoteVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.serumOpenOrders,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: (0, pda_1.getSerumSignerPublicKey)(fulfillmentConfig.serumProgramId, fulfillmentConfig.serumMarket, fulfillmentConfig.serumSignerNonce),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSignerPublicKey(),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getStateAccount().srmVault,
            isWritable: false,
            isSigner: false,
        });
    }
    addPhoenixRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        remainingAccounts.push({
            pubkey: fulfillmentConfig.pubkey,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixProgramId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixLogAuthority,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixMarket,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSignerPublicKey(),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixBaseVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.phoenixQuoteVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
    }
    addOpenbookRemainingAccounts(marketIndex, remainingAccounts, fulfillmentConfig) {
        remainingAccounts.push({
            pubkey: fulfillmentConfig.pubkey,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSignerPublicKey(),
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2ProgramId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2Market,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2MarketAuthority,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2EventHeap,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2Bids,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2Asks,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2BaseVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: fulfillmentConfig.openbookV2QuoteVault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().vault,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: spl_token_1.TOKEN_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: web3_js_1.SystemProgram.programId,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getSpotMarketAccount(marketIndex).pubkey,
            isWritable: true,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: this.getQuoteSpotMarketAccount().pubkey,
            isWritable: true,
            isSigner: false,
        });
        if (fulfillmentConfig.remainingAccounts) {
            for (const remainingAccount of fulfillmentConfig.remainingAccounts) {
                remainingAccounts.push({
                    pubkey: remainingAccount,
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
    }
    /**
     * Swap tokens in drift account using titan or jupiter
     * @param swapClient swap client to find routes and instructions (Titan or Jupiter)
     * @param jupiterClient @deprecated Use swapClient instead. Legacy parameter for backward compatibility
     * @param outMarketIndex the market index of the token you're buying
     * @param inMarketIndex the market index of the token you're selling
     * @param outAssociatedTokenAccount the token account to receive the token being sold on the swap provider
     * @param inAssociatedTokenAccount the token account to
     * @param amount the amount of TokenIn, regardless of swapMode
     * @param slippageBps the max slippage passed to the swap provider api
     * @param swapMode swap provider swapMode (ExactIn or ExactOut), default is ExactIn
     * @param route the swap provider route to use for the swap
     * @param reduceOnly specify if In or Out token on the drift account must reduceOnly, checked at end of swap
     * @param v6 pass in the quote response from swap provider quote's API (deprecated, use quote instead)
     * @param quote pass in the quote response from swap provider quote's API
     * @param txParams
     */
    async swap({ swapClient, jupiterClient, outMarketIndex, inMarketIndex, outAssociatedTokenAccount, inAssociatedTokenAccount, amount, slippageBps, swapMode, reduceOnly, txParams, v6, quote, onlyDirectRoutes = false, }) {
        // Handle backward compatibility: use jupiterClient if swapClient is not provided
        const clientToUse = swapClient || jupiterClient;
        if (!clientToUse) {
            throw new Error('Either swapClient or jupiterClient must be provided');
        }
        let res;
        // Use unified SwapClient if available
        if (clientToUse instanceof UnifiedSwapClient_1.UnifiedSwapClient) {
            res = await this.getSwapIxV2({
                swapClient: clientToUse,
                outMarketIndex,
                inMarketIndex,
                outAssociatedTokenAccount,
                inAssociatedTokenAccount,
                amount,
                slippageBps,
                swapMode,
                onlyDirectRoutes,
                reduceOnly,
                quote,
                v6,
            });
        }
        else if (clientToUse instanceof titanClient_1.TitanClient) {
            res = await this.getTitanSwapIx({
                titanClient: clientToUse,
                outMarketIndex,
                inMarketIndex,
                outAssociatedTokenAccount,
                inAssociatedTokenAccount,
                amount,
                slippageBps,
                swapMode,
                onlyDirectRoutes,
                reduceOnly,
            });
        }
        else if (clientToUse instanceof jupiterClient_1.JupiterClient) {
            const quoteToUse = quote !== null && quote !== void 0 ? quote : v6 === null || v6 === void 0 ? void 0 : v6.quote;
            res = await this.getJupiterSwapIxV6({
                jupiterClient: clientToUse,
                outMarketIndex,
                inMarketIndex,
                outAssociatedTokenAccount,
                inAssociatedTokenAccount,
                amount,
                slippageBps,
                swapMode,
                quote: quoteToUse,
                reduceOnly,
                onlyDirectRoutes,
            });
        }
        else {
            throw new Error('Invalid swap client type. Must be SwapClient, TitanClient, or JupiterClient.');
        }
        const ixs = res.ixs;
        const lookupTables = res.lookupTables;
        const tx = (await this.buildTransaction(ixs, txParams, 0, lookupTables));
        const { txSig, slot } = await this.sendTransaction(tx);
        this.spotMarketLastSlotCache.set(outMarketIndex, slot);
        this.spotMarketLastSlotCache.set(inMarketIndex, slot);
        return txSig;
    }
    async getTitanSwapIx({ titanClient, outMarketIndex, inMarketIndex, outAssociatedTokenAccount, inAssociatedTokenAccount, amount, slippageBps, swapMode, onlyDirectRoutes, reduceOnly, userAccountPublicKey, }) {
        const outMarket = this.getSpotMarketAccount(outMarketIndex);
        const inMarket = this.getSpotMarketAccount(inMarketIndex);
        const isExactOut = swapMode === 'ExactOut';
        const exactOutBufferedAmountIn = amount.muln(1001).divn(1000); // Add 10bp buffer
        const preInstructions = [];
        if (!outAssociatedTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(outMarket);
            outAssociatedTokenAccount = await this.getAssociatedTokenAccount(outMarket.marketIndex, false, tokenProgram);
            const accountInfo = await this.connection.getAccountInfo(outAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(outAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, outMarket.mint, tokenProgram));
            }
        }
        if (!inAssociatedTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(inMarket);
            inAssociatedTokenAccount = await this.getAssociatedTokenAccount(inMarket.marketIndex, false, tokenProgram);
            const accountInfo = await this.connection.getAccountInfo(inAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(inAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, inMarket.mint, tokenProgram));
            }
        }
        const { beginSwapIx, endSwapIx } = await this.getSwapIx({
            outMarketIndex,
            inMarketIndex,
            amountIn: isExactOut ? exactOutBufferedAmountIn : amount,
            inTokenAccount: inAssociatedTokenAccount,
            outTokenAccount: outAssociatedTokenAccount,
            reduceOnly,
            userAccountPublicKey,
        });
        const { transactionMessage, lookupTables } = await titanClient.getSwap({
            inputMint: inMarket.mint,
            outputMint: outMarket.mint,
            amount,
            userPublicKey: this.provider.wallet.publicKey,
            slippageBps,
            swapMode: isExactOut ? titanClient_1.SwapMode.ExactOut : titanClient_1.SwapMode.ExactIn,
            onlyDirectRoutes,
            sizeConstraint: utils_2.MAX_TX_BYTE_SIZE - 375, // buffer for drift instructions
        });
        const titanInstructions = titanClient.getTitanInstructions({
            transactionMessage,
            inputMint: inMarket.mint,
            outputMint: outMarket.mint,
        });
        const ixs = [
            ...preInstructions,
            beginSwapIx,
            ...titanInstructions,
            endSwapIx,
        ];
        return { ixs, lookupTables };
    }
    async getJupiterSwapIxV6({ jupiterClient, outMarketIndex, inMarketIndex, outAssociatedTokenAccount, inAssociatedTokenAccount, amount, slippageBps, swapMode, onlyDirectRoutes, quote, reduceOnly, userAccountPublicKey, }) {
        const outMarket = this.getSpotMarketAccount(outMarketIndex);
        const inMarket = this.getSpotMarketAccount(inMarketIndex);
        if (!quote) {
            const fetchedQuote = await jupiterClient.getQuote({
                inputMint: inMarket.mint,
                outputMint: outMarket.mint,
                amount,
                slippageBps,
                swapMode,
                onlyDirectRoutes,
            });
            quote = fetchedQuote;
        }
        if (!quote) {
            throw new Error('Could not fetch swap quote. Please try again.');
        }
        const isExactOut = swapMode === 'ExactOut' || quote.swapMode === 'ExactOut';
        const amountIn = new anchor_1.BN(quote.inAmount);
        const exactOutBufferedAmountIn = amountIn.muln(1001).divn(1000); // Add 10bp buffer
        const transaction = await jupiterClient.getSwap({
            quote,
            userPublicKey: this.provider.wallet.publicKey,
            slippageBps,
        });
        const { transactionMessage, lookupTables } = await jupiterClient.getTransactionMessageAndLookupTables({
            transaction,
        });
        const jupiterInstructions = jupiterClient.getJupiterInstructions({
            transactionMessage,
            inputMint: inMarket.mint,
            outputMint: outMarket.mint,
        });
        const preInstructions = [];
        if (!outAssociatedTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(outMarket);
            outAssociatedTokenAccount = await this.getAssociatedTokenAccount(outMarket.marketIndex, false, tokenProgram);
            const accountInfo = await this.connection.getAccountInfo(outAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(outAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, outMarket.mint, tokenProgram));
            }
        }
        if (!inAssociatedTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(inMarket);
            inAssociatedTokenAccount = await this.getAssociatedTokenAccount(inMarket.marketIndex, false, tokenProgram);
            const accountInfo = await this.connection.getAccountInfo(inAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(inAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, inMarket.mint, tokenProgram));
            }
        }
        const { beginSwapIx, endSwapIx } = await this.getSwapIx({
            outMarketIndex,
            inMarketIndex,
            amountIn: isExactOut ? exactOutBufferedAmountIn : amountIn,
            inTokenAccount: inAssociatedTokenAccount,
            outTokenAccount: outAssociatedTokenAccount,
            reduceOnly,
            userAccountPublicKey,
        });
        const ixs = [
            ...preInstructions,
            beginSwapIx,
            ...jupiterInstructions,
            endSwapIx,
        ];
        return { ixs, lookupTables };
    }
    /**
     * Get the drift begin_swap and end_swap instructions
     *
     * @param outMarketIndex the market index of the token you're buying
     * @param inMarketIndex the market index of the token you're selling
     * @param amountIn the amount of the token to sell
     * @param inTokenAccount the token account to move the tokens being sold
     * @param outTokenAccount the token account to receive the tokens being bought
     * @param limitPrice the limit price of the swap
     * @param reduceOnly
     * @param userAccountPublicKey optional, specify a custom userAccountPublicKey to use instead of getting the current user account; can be helpful if the account is being created within the current tx
     */
    async getSwapIx({ outMarketIndex, inMarketIndex, amountIn, inTokenAccount, outTokenAccount, limitPrice, reduceOnly, userAccountPublicKey, }) {
        const userAccountPublicKeyToUse = userAccountPublicKey || (await this.getUserAccountPublicKey());
        const userAccounts = [];
        try {
            if (this.hasUser() && this.getUser().getUserAccountAndSlot()) {
                userAccounts.push(this.getUser().getUserAccountAndSlot().data);
            }
        }
        catch (err) {
            // ignore
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writableSpotMarketIndexes: [outMarketIndex, inMarketIndex],
            readableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const outSpotMarket = this.getSpotMarketAccount(outMarketIndex);
        const inSpotMarket = this.getSpotMarketAccount(inMarketIndex);
        const outTokenProgram = this.getTokenProgramForSpotMarket(outSpotMarket);
        const inTokenProgram = this.getTokenProgramForSpotMarket(inSpotMarket);
        if (!outTokenProgram.equals(inTokenProgram)) {
            remainingAccounts.push({
                pubkey: outTokenProgram,
                isWritable: false,
                isSigner: false,
            });
        }
        if (this.isToken2022(outSpotMarket) || this.isToken2022(inSpotMarket)) {
            remainingAccounts.push({
                pubkey: inSpotMarket.mint,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: outSpotMarket.mint,
                isWritable: false,
                isSigner: false,
            });
            if (this.isTransferHook(outSpotMarket)) {
                this.addExtraAccountMetasToRemainingAccounts(outSpotMarket.mint, remainingAccounts);
            }
            if (this.isTransferHook(inSpotMarket)) {
                this.addExtraAccountMetasToRemainingAccounts(inSpotMarket.mint, remainingAccounts);
            }
        }
        const beginSwapIx = await this.program.instruction.beginSwap(inMarketIndex, outMarketIndex, amountIn, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKeyToUse,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                outSpotMarketVault: outSpotMarket.vault,
                inSpotMarketVault: inSpotMarket.vault,
                inTokenAccount,
                outTokenAccount,
                tokenProgram: inTokenProgram,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        const endSwapIx = await this.program.instruction.endSwap(inMarketIndex, outMarketIndex, limitPrice !== null && limitPrice !== void 0 ? limitPrice : null, reduceOnly !== null && reduceOnly !== void 0 ? reduceOnly : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKeyToUse,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
                outSpotMarketVault: outSpotMarket.vault,
                inSpotMarketVault: inSpotMarket.vault,
                inTokenAccount,
                outTokenAccount,
                tokenProgram: inTokenProgram,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        return { beginSwapIx, endSwapIx };
    }
    async getSwapIxV2({ swapClient, outMarketIndex, inMarketIndex, outAssociatedTokenAccount, inAssociatedTokenAccount, amount, slippageBps, swapMode, onlyDirectRoutes, reduceOnly, quote, v6, userAccountPublicKey, }) {
        // Get market accounts to determine mints
        const outMarket = this.getSpotMarketAccount(outMarketIndex);
        const inMarket = this.getSpotMarketAccount(inMarketIndex);
        const isExactOut = swapMode === 'ExactOut';
        const preInstructions = [];
        // Handle token accounts if not provided
        let finalOutAssociatedTokenAccount = outAssociatedTokenAccount;
        let finalInAssociatedTokenAccount = inAssociatedTokenAccount;
        if (!finalOutAssociatedTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(outMarket);
            finalOutAssociatedTokenAccount = await this.getAssociatedTokenAccount(outMarket.marketIndex, false, tokenProgram);
            const accountInfo = await this.connection.getAccountInfo(finalOutAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(finalOutAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, outMarket.mint, tokenProgram));
            }
        }
        if (!finalInAssociatedTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(inMarket);
            finalInAssociatedTokenAccount = await this.getAssociatedTokenAccount(inMarket.marketIndex, false, tokenProgram);
            const accountInfo = await this.connection.getAccountInfo(finalInAssociatedTokenAccount);
            if (!accountInfo) {
                preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(finalInAssociatedTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, inMarket.mint, tokenProgram));
            }
        }
        let amountInForBeginSwap;
        if (isExactOut) {
            if (quote || (v6 === null || v6 === void 0 ? void 0 : v6.quote)) {
                amountInForBeginSwap = (v6 === null || v6 === void 0 ? void 0 : v6.quote)
                    ? new anchor_1.BN(v6.quote.inAmount)
                    : new anchor_1.BN(quote.inAmount);
            }
            else {
                amountInForBeginSwap = amount.muln(1001).divn(1000);
            }
        }
        else {
            amountInForBeginSwap = amount;
        }
        // Get drift swap instructions for begin and end
        const { beginSwapIx, endSwapIx } = await this.getSwapIx({
            outMarketIndex,
            inMarketIndex,
            amountIn: amountInForBeginSwap,
            inTokenAccount: finalInAssociatedTokenAccount,
            outTokenAccount: finalOutAssociatedTokenAccount,
            reduceOnly,
            userAccountPublicKey,
        });
        // Get core swap instructions from SwapClient
        const swapResult = await swapClient.getSwapInstructions({
            inputMint: inMarket.mint,
            outputMint: outMarket.mint,
            amount,
            userPublicKey: this.provider.wallet.publicKey,
            slippageBps,
            swapMode,
            onlyDirectRoutes,
            quote: quote !== null && quote !== void 0 ? quote : v6 === null || v6 === void 0 ? void 0 : v6.quote,
        });
        const allInstructions = [
            ...preInstructions,
            beginSwapIx,
            ...swapResult.instructions,
            endSwapIx,
        ];
        return {
            ixs: allInstructions,
            lookupTables: swapResult.lookupTables,
        };
    }
    async stakeForMSOL({ amount }) {
        const ixs = await this.getStakeForMSOLIx({ amount });
        const tx = await this.buildTransaction(ixs);
        return this.sendTransaction(tx);
    }
    async getStakeForMSOLIx({ amount, userAccountPublicKey, }) {
        const wSOLMint = this.getSpotMarketAccount(1).mint;
        const mSOLAccount = await this.getAssociatedTokenAccount(2);
        const wSOLAccount = await this.getAssociatedTokenAccount(1, false);
        const wSOLAccountExists = await this.checkIfAccountExists(wSOLAccount);
        const closeWSOLIx = (0, spl_token_1.createCloseAccountInstruction)(wSOLAccount, this.wallet.publicKey, this.wallet.publicKey);
        const createWSOLIx = await this.createAssociatedTokenAccountIdempotentInstruction(wSOLAccount, this.wallet.publicKey, this.wallet.publicKey, wSOLMint);
        const { beginSwapIx, endSwapIx } = await this.getSwapIx({
            inMarketIndex: 1,
            outMarketIndex: 2,
            amountIn: amount,
            inTokenAccount: wSOLAccount,
            outTokenAccount: mSOLAccount,
            userAccountPublicKey,
        });
        const program = (0, marinade_1.getMarinadeFinanceProgram)(this.provider);
        const depositIx = await (0, marinade_1.getMarinadeDepositIx)({
            program,
            mSOLAccount: mSOLAccount,
            transferFrom: this.wallet.publicKey,
            amount,
        });
        const ixs = [];
        if (!wSOLAccountExists) {
            ixs.push(createWSOLIx);
        }
        ixs.push(beginSwapIx, closeWSOLIx, depositIx, createWSOLIx, endSwapIx);
        return ixs;
    }
    async triggerOrder(userAccountPublicKey, user, order, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getTriggerOrderIx(userAccountPublicKey, user, order, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getTriggerOrderIx(userAccountPublicKey, userAccount, order, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        let remainingAccountsParams;
        if ((0, types_1.isVariant)(order.marketType, 'perp')) {
            remainingAccountsParams = {
                userAccounts: [userAccount],
                writablePerpMarketIndexes: [order.marketIndex],
            };
        }
        else {
            remainingAccountsParams = {
                userAccounts: [userAccount],
                writableSpotMarketIndexes: [order.marketIndex, numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
            };
        }
        const remainingAccounts = this.getRemainingAccounts(remainingAccountsParams);
        const orderId = order.orderId;
        return await this.program.instruction.triggerOrder(orderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async forceCancelOrders(userAccountPublicKey, user, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getForceCancelOrdersIx(userAccountPublicKey, user, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getForceCancelOrdersIx(userAccountPublicKey, userAccount, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        return await this.program.instruction.forceCancelOrders({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserIdle(userAccountPublicKey, user, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserIdleIx(userAccountPublicKey, user, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserIdleIx(userAccountPublicKey, userAccount, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.updateUserIdle({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async logUserBalances(userAccountPublicKey, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getLogUserBalancesIx(userAccountPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getLogUserBalancesIx(userAccountPublicKey) {
        const userAccount = (await this.program.account.user.fetch(userAccountPublicKey));
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.logUserBalances({
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    /* Deprecated */
    async updateUserFuelBonus(userAccountPublicKey, user, userAuthority, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserFuelBonusIx(userAccountPublicKey, user, userAuthority), txParams), [], this.opts);
        return txSig;
    }
    /* Deprecated */
    async getUpdateUserFuelBonusIx(userAccountPublicKey, userAccount, userAuthority) {
        const userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAuthority);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.updateUserFuelBonus({
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: userStatsAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async updateUserStatsReferrerStatus(userAuthority, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserStatsReferrerStatusIx(userAuthority), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserStatsReferrerStatusIx(userAuthority) {
        const userStatsAccountPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAuthority);
        return await this.program.instruction.updateUserStatsReferrerStatus({
            accounts: {
                state: await this.getStatePublicKey(),
                userStats: userStatsAccountPublicKey,
                authority: this.wallet.publicKey,
            },
        });
    }
    async updateUserOpenOrdersCount(userAccountPublicKey, user, txParams, fillerPublicKey) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserOpenOrdersCountIx(userAccountPublicKey, user, fillerPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserOpenOrdersCountIx(userAccountPublicKey, userAccount, fillerPublicKey) {
        const filler = fillerPublicKey !== null && fillerPublicKey !== void 0 ? fillerPublicKey : (await this.getUserAccountPublicKey());
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.updateUserOpenOrdersCount({
            accounts: {
                state: await this.getStatePublicKey(),
                filler,
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndTakePerpOrder(orderParams, makerInfo, referrerInfo, successCondition, auctionDurationPercentage, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo, successCondition, auctionDurationPercentage, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async preparePlaceAndTakePerpOrderWithAdditionalOrders(orderParams, makerInfo, referrerInfo, bracketOrdersParams = new Array(), txParams, subAccountId, cancelExistingOrders, settlePnl, exitEarlyIfSimFails, auctionDurationPercentage, optionalIxs, isolatedPositionDepositAmount) {
        const placeAndTakeIxs = [];
        const txsToSign = {
            placeAndTakeTx: undefined,
            cancelExistingOrdersTx: undefined,
            settlePnlTx: undefined,
        };
        // Get recent block hash so that we can re-use it for all transactions. Makes this logic run faster with fewer RPC requests
        const recentBlockHash = await this.txHandler.getLatestBlockhashForTransaction();
        const lookupTableAccounts = await this.fetchAllLookupTableAccounts();
        let earlyExitFailedPlaceAndTakeSim = false;
        const prepPlaceAndTakeTx = async () => {
            var _a, _b;
            const placeAndTakeIx = await this.getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo, undefined, auctionDurationPercentage, subAccountId);
            if ((0, types_1.isVariant)(orderParams.marketType, 'perp') &&
                ((_a = isolatedPositionDepositAmount === null || isolatedPositionDepositAmount === void 0 ? void 0 : isolatedPositionDepositAmount.gt) === null || _a === void 0 ? void 0 : _a.call(isolatedPositionDepositAmount, numericConstants_1.ZERO)) &&
                this.isOrderIncreasingPosition(orderParams, subAccountId)) {
                placeAndTakeIxs.push(await this.getTransferIsolatedPerpPositionDepositIx(isolatedPositionDepositAmount, orderParams.marketIndex, subAccountId));
            }
            placeAndTakeIxs.push(placeAndTakeIx);
            if (bracketOrdersParams.length > 0) {
                const bracketOrdersIx = await this.getPlaceOrdersIx(bracketOrdersParams, subAccountId);
                placeAndTakeIxs.push(bracketOrdersIx);
            }
            // Optional extra ixs can be appended at the front
            if (optionalIxs === null || optionalIxs === void 0 ? void 0 : optionalIxs.length) {
                placeAndTakeIxs.unshift(...optionalIxs);
            }
            const shouldUseSimulationComputeUnits = txParams === null || txParams === void 0 ? void 0 : txParams.useSimulatedComputeUnits;
            const shouldExitIfSimulationFails = exitEarlyIfSimFails;
            const txParamsWithoutImplicitSimulation = {
                ...txParams,
                useSimulatedComputeUnits: false,
            };
            if (shouldUseSimulationComputeUnits || shouldExitIfSimulationFails) {
                const placeAndTakeTxToSim = (await this.buildTransaction(placeAndTakeIxs, txParams, undefined, lookupTableAccounts, true, recentBlockHash, optionalIxs));
                const simulationResult = await txParamProcessor_1.TransactionParamProcessor.getTxSimComputeUnits(placeAndTakeTxToSim, this.connection, (_b = txParams.computeUnitsBufferMultiplier) !== null && _b !== void 0 ? _b : 1.2, txParams.lowerBoundCu);
                if (shouldExitIfSimulationFails && !simulationResult.success) {
                    earlyExitFailedPlaceAndTakeSim = true;
                    return;
                }
                txsToSign.placeAndTakeTx = await this.buildTransaction(placeAndTakeIxs, {
                    ...txParamsWithoutImplicitSimulation,
                    computeUnits: simulationResult.computeUnits,
                }, undefined, lookupTableAccounts, undefined, recentBlockHash, optionalIxs);
            }
            else {
                txsToSign.placeAndTakeTx = await this.buildTransaction(placeAndTakeIxs, txParams, undefined, lookupTableAccounts, undefined, recentBlockHash, optionalIxs);
            }
            return;
        };
        const prepCancelOrderTx = async () => {
            if (cancelExistingOrders && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
                const cancelOrdersIx = await this.getCancelOrdersIx(orderParams.marketType, orderParams.marketIndex, null, subAccountId);
                txsToSign.cancelExistingOrdersTx = await this.buildTransaction([cancelOrdersIx], txParams, this.txVersion, lookupTableAccounts, undefined, recentBlockHash, optionalIxs);
            }
            return;
        };
        const prepSettlePnlTx = async () => {
            if (settlePnl && (0, types_1.isVariant)(orderParams.marketType, 'perp')) {
                const userAccountPublicKey = await this.getUserAccountPublicKey(subAccountId);
                const settlePnlIx = await this.settlePNLIx(userAccountPublicKey, this.getUserAccount(subAccountId), orderParams.marketIndex);
                txsToSign.settlePnlTx = await this.buildTransaction([settlePnlIx], txParams, this.txVersion, lookupTableAccounts, undefined, recentBlockHash, optionalIxs);
            }
            return;
        };
        await Promise.all([
            prepPlaceAndTakeTx(),
            prepCancelOrderTx(),
            prepSettlePnlTx(),
        ]);
        if (earlyExitFailedPlaceAndTakeSim) {
            return null;
        }
        return txsToSign;
    }
    async placeAndTakePerpWithAdditionalOrders(orderParams, makerInfo, referrerInfo, bracketOrdersParams = new Array(), txParams, subAccountId, cancelExistingOrders, settlePnl, exitEarlyIfSimFails) {
        const txsToSign = await this.preparePlaceAndTakePerpOrderWithAdditionalOrders(orderParams, makerInfo, referrerInfo, bracketOrdersParams, txParams, subAccountId, cancelExistingOrders, settlePnl, exitEarlyIfSimFails);
        if (!txsToSign) {
            return null;
        }
        const signedTxs = (await this.txHandler.getSignedTransactionMap(txsToSign, 
        // @ts-ignore
        this.provider.wallet)).signedTxMap;
        const { txSig, slot } = await this.sendTransaction(signedTxs.placeAndTakeTx, [], this.opts, true);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return {
            txSig,
            signedCancelExistingOrdersTx: signedTxs.cancelExistingOrdersTx,
            signedSettlePnlTx: signedTxs.settlePnlTx,
        };
    }
    async getPlaceAndTakePerpOrderIx(orderParams, makerInfo, referrerInfo, successCondition, auctionDurationPercentage, subAccountId, overrides) {
        var _a;
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const userStatsPublicKey = await this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        makerInfo = Array.isArray(makerInfo)
            ? makerInfo
            : makerInfo
                ? [makerInfo]
                : [];
        const userAccounts = [this.getUserAccount(subAccountId)];
        for (const maker of makerInfo) {
            userAccounts.push(maker.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [orderParams.marketIndex],
        });
        for (const maker of makerInfo) {
            remainingAccounts.push({
                pubkey: maker.maker,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: maker.makerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        if (referrerInfo) {
            const referrerIsMaker = makerInfo.find((maker) => maker.maker.equals(referrerInfo.referrer)) !==
                undefined;
            if (!referrerIsMaker) {
                remainingAccounts.push({
                    pubkey: referrerInfo.referrer,
                    isWritable: true,
                    isSigner: false,
                });
                remainingAccounts.push({
                    pubkey: referrerInfo.referrerStats,
                    isWritable: true,
                    isSigner: false,
                });
            }
        }
        if ((0, orderParams_1.isUpdateHighLeverageMode)(orderParams.bitFlags)) {
            remainingAccounts.push({
                pubkey: (0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId),
                isWritable: true,
                isSigner: false,
            });
        }
        let optionalParams = null;
        if (auctionDurationPercentage || successCondition) {
            optionalParams =
                ((auctionDurationPercentage !== null && auctionDurationPercentage !== void 0 ? auctionDurationPercentage : 100) << 8) | (successCondition !== null && successCondition !== void 0 ? successCondition : 0);
        }
        const authority = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.authority) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        return await this.program.instruction.placeAndTakePerpOrder(orderParams, optionalParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                authority,
            },
            remainingAccounts,
        });
    }
    async placeAndMakePerpOrder(orderParams, takerInfo, referrerInfo, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceAndMakePerpOrderIx(orderParams, takerInfo, referrerInfo, subAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async getPlaceAndMakePerpOrderIx(orderParams, takerInfo, referrerInfo, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                this.getUserAccount(subAccountId),
                takerInfo.takerUserAccount,
            ],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [orderParams.marketIndex],
        });
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const takerOrderId = takerInfo.order.orderId;
        if ((0, orders_1.hasBuilder)(takerInfo.order)) {
            remainingAccounts.push({
                pubkey: (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, takerInfo.takerUserAccount.authority),
                isWritable: true,
                isSigner: false,
            });
        }
        return await this.program.instruction.placeAndMakePerpOrder(orderParams, takerOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                taker: takerInfo.taker,
                takerStats: takerInfo.takerStats,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    signSignedMsgOrderParamsMessage(orderParamsMessage, delegateSigner) {
        const borshBuf = this.encodeSignedMsgOrderParamsMessage(orderParamsMessage, delegateSigner);
        const orderParams = Buffer.from(borshBuf.toString('hex'));
        return {
            orderParams,
            signature: this.signMessage(Buffer.from(borshBuf.toString('hex'))),
        };
    }
    /**
     * Builds a deposit and place request for Swift service
     *
     * @param depositTx - The signed tx containing a drift deposit (e.g. see `buildSwiftDepositTx`)
     * @param orderParamsMessage - The order parameters message to sign
     * @param delegateSigner - Whether this is a delegate signer
     *
     * @returns request object for Swift service
     */
    buildDepositAndPlaceSignedMsgOrderRequest(depositTx, orderParamsMessage, delegateSigner) {
        // Serialize the deposit transaction
        const serializedDepositTx = Buffer.from(depositTx.serialize());
        // Get the signed swift order using the existing method
        const swiftOrder = this.signSignedMsgOrderParamsMessage(orderParamsMessage, delegateSigner);
        return {
            deposit_tx: serializedDepositTx,
            swift_order: swiftOrder,
        };
    }
    /*
     * Borsh encode signedMsg taker order params
     */
    encodeSignedMsgOrderParamsMessage(orderParamsMessage, delegateSigner) {
        if (orderParamsMessage.maxMarginRatio === undefined) {
            orderParamsMessage.maxMarginRatio = null;
        }
        if (orderParamsMessage.isolatedPositionDeposit === undefined) {
            orderParamsMessage.isolatedPositionDeposit = null;
        }
        const anchorIxName = delegateSigner
            ? 'global' + ':' + 'SignedMsgOrderParamsDelegateMessage'
            : 'global' + ':' + 'SignedMsgOrderParamsMessage';
        const prefix = Buffer.from((0, sha256_1.sha256)(anchorIxName).slice(0, 8));
        // Backwards-compat: normalize optional builder fields to null for encoding
        const withBuilderDefaults = {
            ...orderParamsMessage,
            builderIdx: orderParamsMessage.builderIdx !== undefined
                ? orderParamsMessage.builderIdx
                : null,
            builderFeeTenthBps: orderParamsMessage.builderFeeTenthBps !== undefined
                ? orderParamsMessage.builderFeeTenthBps
                : null,
        };
        const buf = Buffer.concat([
            prefix,
            delegateSigner
                ? this.program.coder.types.encode('SignedMsgOrderParamsDelegateMessage', withBuilderDefaults)
                : this.program.coder.types.encode('SignedMsgOrderParamsMessage', withBuilderDefaults),
        ]);
        return buf;
    }
    /*
     * Decode signedMsg taker order params from borsh buffer. Zero pads the message in case the
     * received message was encoded by an outdated IDL (size will be too small and decode will throw).
     * Note: the 128 will be problematic if the type we are expecting to deserializze into is 128 bytes
     * larger than the message we are receiving (unlikely, especially if all new fields are Options).
     */
    decodeSignedMsgOrderParamsMessage(encodedMessage, delegateSigner) {
        const decodeStr = delegateSigner
            ? 'SignedMsgOrderParamsDelegateMessage'
            : 'SignedMsgOrderParamsMessage';
        return this.program.coder.types.decode(decodeStr, Buffer.concat([
            encodedMessage.slice(8), // strip out discriminator
            Buffer.alloc(128), // pad on 128 bytes, this is most efficient way to messages that are too small
        ]));
    }
    signMessage(message, keypair = this.wallet.payer) {
        return Buffer.from(tweetnacl_1.default.sign.detached(message, keypair.secretKey));
    }
    async placeSignedMsgTakerOrder(signedSignedMsgOrderParams, marketIndex, takerInfo, precedingIxs = [], overrideCustomIxIndex, txParams) {
        const ixs = await this.getPlaceSignedMsgTakerPerpOrderIxs(signedSignedMsgOrderParams, marketIndex, takerInfo, precedingIxs, overrideCustomIxIndex);
        const { txSig } = await this.sendTransaction(await this.buildTransaction(ixs, txParams), [], this.opts);
        return txSig;
    }
    async getPlaceSignedMsgTakerPerpOrderIxs(signedSignedMsgOrderParams, marketIndex, takerInfo, precedingIxs = [], overrideCustomIxIndex) {
        var _a;
        const isDelegateSigner = takerInfo.signingAuthority.equals(takerInfo.takerUserAccount.delegate);
        const borshBuf = Buffer.from(signedSignedMsgOrderParams.orderParams.toString(), 'hex');
        const signedMessage = this.decodeSignedMsgOrderParamsMessage(borshBuf, isDelegateSigner);
        const writableSpotMarketIndexes = ((_a = signedMessage.isolatedPositionDeposit) === null || _a === void 0 ? void 0 : _a.gt(numericConstants_1.ZERO))
            ? [numericConstants_1.QUOTE_SPOT_MARKET_INDEX]
            : undefined;
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [takerInfo.takerUserAccount],
            useMarketLastSlotCache: false,
            readablePerpMarketIndex: marketIndex,
            writableSpotMarketIndexes,
        });
        if ((0, orderParams_1.isUpdateHighLeverageMode)(signedMessage.signedMsgOrderParams.bitFlags)) {
            remainingAccounts.push({
                pubkey: (0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId),
                isWritable: true,
                isSigner: false,
            });
        }
        if (signedMessage.builderFeeTenthBps !== null &&
            signedMessage.builderIdx !== null) {
            remainingAccounts.push({
                pubkey: (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, takerInfo.takerUserAccount.authority),
                isWritable: true,
                isSigner: false,
            });
        }
        const messageLengthBuffer = Buffer.alloc(2);
        messageLengthBuffer.writeUInt16LE(signedSignedMsgOrderParams.orderParams.length);
        const signedMsgIxData = Buffer.concat([
            signedSignedMsgOrderParams.signature,
            takerInfo.signingAuthority.toBytes(),
            messageLengthBuffer,
            signedSignedMsgOrderParams.orderParams,
        ]);
        const signedMsgOrderParamsSignatureIx = (0, ed25519Utils_1.createMinimalEd25519VerifyIx)(overrideCustomIxIndex || precedingIxs.length + 1, 12, signedMsgIxData, 0);
        const placeTakerSignedMsgPerpOrderIx = this.program.instruction.placeSignedMsgTakerOrder(signedMsgIxData, isDelegateSigner, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: takerInfo.taker,
                userStats: takerInfo.takerStats,
                signedMsgUserOrders: (0, pda_1.getSignedMsgUserAccountPublicKey)(this.program.programId, takerInfo.takerUserAccount.authority),
                authority: this.wallet.publicKey,
                ixSysvar: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        return [signedMsgOrderParamsSignatureIx, placeTakerSignedMsgPerpOrderIx];
    }
    async placeAndMakeSignedMsgPerpOrder(signedSignedMsgOrderParams, signedMsgOrderUuid, takerInfo, orderParams, referrerInfo, txParams, subAccountId, precedingIxs = [], overrideCustomIxIndex) {
        const ixs = await this.getPlaceAndMakeSignedMsgPerpOrderIxs(signedSignedMsgOrderParams, signedMsgOrderUuid, takerInfo, orderParams, referrerInfo, subAccountId, precedingIxs, overrideCustomIxIndex);
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(ixs, txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(orderParams.marketIndex, slot);
        return txSig;
    }
    async getPlaceAndMakeSignedMsgPerpOrderIxs(signedSignedMsgOrderParams, signedMsgOrderUuid, takerInfo, orderParams, referrerInfo, subAccountId, precedingIxs = [], overrideCustomIxIndex) {
        const [signedMsgOrderSignatureIx, placeTakerSignedMsgPerpOrderIx] = await this.getPlaceSignedMsgTakerPerpOrderIxs(signedSignedMsgOrderParams, orderParams.marketIndex, takerInfo, precedingIxs, overrideCustomIxIndex);
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.PERP });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                this.getUserAccount(subAccountId),
                takerInfo.takerUserAccount,
            ],
            useMarketLastSlotCache: false,
            writablePerpMarketIndexes: [orderParams.marketIndex],
        });
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        const isDelegateSigner = takerInfo.signingAuthority.equals(takerInfo.takerUserAccount.delegate);
        const borshBuf = Buffer.from(signedSignedMsgOrderParams.orderParams.toString(), 'hex');
        const signedMessage = this.decodeSignedMsgOrderParamsMessage(borshBuf, isDelegateSigner);
        if (signedMessage.builderFeeTenthBps !== null &&
            signedMessage.builderIdx !== null) {
            remainingAccounts.push({
                pubkey: (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, takerInfo.takerUserAccount.authority),
                isWritable: true,
                isSigner: false,
            });
        }
        const placeAndMakeIx = await this.program.instruction.placeAndMakeSignedMsgPerpOrder(orderParams, signedMsgOrderUuid, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                taker: takerInfo.taker,
                takerStats: takerInfo.takerStats,
                authority: this.wallet.publicKey,
                takerSignedMsgUserOrders: (0, pda_1.getSignedMsgUserAccountPublicKey)(this.program.programId, takerInfo.takerUserAccount.authority),
            },
            remainingAccounts,
        });
        return [
            signedMsgOrderSignatureIx,
            placeTakerSignedMsgPerpOrderIx,
            placeAndMakeIx,
        ];
    }
    async preparePlaceAndTakeSpotOrder(orderParams, fulfillmentConfig, makerInfo, referrerInfo, txParams, subAccountId) {
        const tx = await this.buildTransaction(await this.getPlaceAndTakeSpotOrderIx(orderParams, fulfillmentConfig, makerInfo, referrerInfo, subAccountId), txParams);
        return {
            placeAndTakeSpotOrderTx: tx,
        };
    }
    async placeAndTakeSpotOrder(orderParams, fulfillmentConfig, makerInfo, referrerInfo, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction((await this.preparePlaceAndTakeSpotOrder(orderParams, fulfillmentConfig, makerInfo, referrerInfo, txParams, subAccountId)).placeAndTakeSpotOrderTx, [], this.opts, false);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async getPlaceAndTakeSpotOrderIx(orderParams, fulfillmentConfig, makerInfo, referrerInfo, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.SPOT });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const userAccounts = [this.getUserAccount(subAccountId)];
        if (makerInfo !== undefined) {
            userAccounts.push(makerInfo.makerUserAccount);
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        let makerOrderId = null;
        if (makerInfo) {
            makerOrderId = makerInfo.order.orderId;
            remainingAccounts.push({
                pubkey: makerInfo.maker,
                isSigner: false,
                isWritable: true,
            });
            remainingAccounts.push({
                pubkey: makerInfo.makerStats,
                isSigner: false,
                isWritable: true,
            });
        }
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        this.addSpotFulfillmentAccounts(orderParams.marketIndex, remainingAccounts, fulfillmentConfig);
        return await this.program.instruction.placeAndTakeSpotOrder(orderParams, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, makerOrderId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async placeAndMakeSpotOrder(orderParams, takerInfo, fulfillmentConfig, referrerInfo, txParams, subAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getPlaceAndMakeSpotOrderIx(orderParams, takerInfo, fulfillmentConfig, referrerInfo, subAccountId), txParams), [], this.opts);
        this.spotMarketLastSlotCache.set(orderParams.marketIndex, slot);
        this.spotMarketLastSlotCache.set(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, slot);
        return txSig;
    }
    async getPlaceAndMakeSpotOrderIx(orderParams, takerInfo, fulfillmentConfig, referrerInfo, subAccountId) {
        orderParams = (0, orderParams_1.getOrderParams)(orderParams, { marketType: types_1.MarketType.SPOT });
        const userStatsPublicKey = this.getUserStatsAccountPublicKey();
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                this.getUserAccount(subAccountId),
                takerInfo.takerUserAccount,
            ],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [
                orderParams.marketIndex,
                numericConstants_1.QUOTE_SPOT_MARKET_INDEX,
            ],
        });
        if (referrerInfo) {
            remainingAccounts.push({
                pubkey: referrerInfo.referrer,
                isWritable: true,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: referrerInfo.referrerStats,
                isWritable: true,
                isSigner: false,
            });
        }
        this.addSpotFulfillmentAccounts(orderParams.marketIndex, remainingAccounts, fulfillmentConfig);
        const takerOrderId = takerInfo.order.orderId;
        return await this.program.instruction.placeAndMakeSpotOrder(orderParams, takerOrderId, fulfillmentConfig ? fulfillmentConfig.fulfillmentType : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: userStatsPublicKey,
                taker: takerInfo.taker,
                takerStats: takerInfo.takerStats,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    /**
     * @deprecated use {@link placePerpOrder} or {@link placeAndTakePerpOrder} instead
     */
    async closePosition(marketIndex, limitPrice, subAccountId) {
        const userPosition = this.getUser(subAccountId).getPerpPosition(marketIndex);
        if (!userPosition) {
            throw Error(`No position in market ${marketIndex.toString()}`);
        }
        return await this.placeAndTakePerpOrder({
            orderType: types_1.OrderType.MARKET,
            marketIndex,
            direction: (0, position_1.findDirectionToClose)(userPosition),
            baseAssetAmount: userPosition.baseAssetAmount.abs(),
            reduceOnly: true,
            price: limitPrice,
        }, undefined, undefined, undefined, undefined, undefined, subAccountId);
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @deprecated use modifyOrder instead
     * @param orderId: The open order to modify
     * @param newBaseAmount: The new base amount for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newLimitPice: The new limit price for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newOraclePriceOffset: The new oracle price offset for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @returns
     */
    async modifyPerpOrder(orderId, newBaseAmount, newLimitPrice, newOraclePriceOffset) {
        return this.modifyOrder({
            orderId,
            newBaseAmount,
            newLimitPrice,
            newOraclePriceOffset,
        });
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @deprecated use modifyOrderByUserOrderId instead
     * @param userOrderId: The open order to modify
     * @param newBaseAmount: The new base amount for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newLimitPice: The new limit price for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @param newOraclePriceOffset: The new oracle price offset for the order. One of [newBaseAmount|newLimitPrice|newOraclePriceOffset] must be provided.
     * @returns
     */
    async modifyPerpOrderByUserOrderId(userOrderId, newBaseAmount, newLimitPrice, newOraclePriceOffset) {
        return this.modifyOrderByUserOrderId({
            userOrderId,
            newBaseAmount,
            newLimitPrice,
            newOraclePriceOffset,
        });
    }
    /**
     * Modifies an open order (spot or perp) by closing it and replacing it with a new order.
     * @param orderParams.orderId: The open order to modify
     * @param orderParams.newDirection: The new direction for the order
     * @param orderParams.newBaseAmount: The new base amount for the order
     * @param orderParams.newLimitPice: The new limit price for the order
     * @param orderParams.newOraclePriceOffset: The new oracle price offset for the order
     * @param orderParams.newTriggerPrice: Optional - Thew new trigger price for the order.
     * @param orderParams.auctionDuration:
     * @param orderParams.auctionStartPrice:
     * @param orderParams.auctionEndPrice:
     * @param orderParams.reduceOnly:
     * @param orderParams.postOnly:
     * @param orderParams.bitFlags:
     * @param orderParams.policy:
     * @param orderParams.maxTs:
     * @returns
     */
    async modifyOrder(orderParams, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getModifyOrderIx(orderParams, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    /**
     * @param orderParams: The parameters for the order to modify.
     * @param subAccountId: Optional - The subaccount ID of the user to modify the order for.
     * @param userPublicKey: Optional - The public key of the user to modify the order for. This takes precedence over subAccountId.
     * @returns
     */
    async getModifyOrderIx({ orderId, newDirection, newBaseAmount, newLimitPrice, newOraclePriceOffset, newTriggerPrice, newTriggerCondition, auctionDuration, auctionStartPrice, auctionEndPrice, reduceOnly, postOnly, bitFlags, maxTs, policy, }, subAccountId, overrides) {
        var _a, _b, _c, _d, _e, _f, _g;
        const userPubKey = (_b = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.user) === null || _a === void 0 ? void 0 : _a.getUserAccountPublicKey()) !== null && _b !== void 0 ? _b : (await this.getUserAccountPublicKey(subAccountId));
        const userAccount = (_d = (_c = overrides === null || overrides === void 0 ? void 0 : overrides.user) === null || _c === void 0 ? void 0 : _c.getUserAccount()) !== null && _d !== void 0 ? _d : this.getUserAccount(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            useMarketLastSlotCache: true,
        });
        const orderParams = {
            baseAssetAmount: newBaseAmount || null,
            direction: newDirection || null,
            price: newLimitPrice || null,
            oraclePriceOffset: newOraclePriceOffset || null,
            triggerPrice: newTriggerPrice || null,
            triggerCondition: newTriggerCondition || null,
            auctionDuration: auctionDuration || null,
            auctionStartPrice: auctionStartPrice || null,
            auctionEndPrice: auctionEndPrice || null,
            reduceOnly: reduceOnly != undefined ? reduceOnly : null,
            postOnly: postOnly != undefined ? postOnly : null,
            bitFlags: bitFlags != undefined ? bitFlags : null,
            policy: policy || null,
            maxTs: maxTs || null,
        };
        const authority = (_g = (_e = overrides === null || overrides === void 0 ? void 0 : overrides.authority) !== null && _e !== void 0 ? _e : (_f = overrides === null || overrides === void 0 ? void 0 : overrides.user) === null || _f === void 0 ? void 0 : _f.getUserAccount().authority) !== null && _g !== void 0 ? _g : this.wallet.publicKey;
        return await this.program.instruction.modifyOrder(orderId, orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userPubKey,
                userStats: this.getUserStatsAccountPublicKey(),
                authority,
            },
            remainingAccounts,
        });
    }
    /**
     * Modifies an open order by closing it and replacing it with a new order.
     * @param orderParams.userOrderId: The open order to modify
     * @param orderParams.newDirection: The new direction for the order
     * @param orderParams.newBaseAmount: The new base amount for the order
     * @param orderParams.newLimitPice: The new limit price for the order
     * @param orderParams.newOraclePriceOffset: The new oracle price offset for the order
     * @param orderParams.newTriggerPrice: Optional - Thew new trigger price for the order.
     * @param orderParams.auctionDuration: Only required if order type changed to market from something else
     * @param orderParams.auctionStartPrice: Only required if order type changed to market from something else
     * @param orderParams.auctionEndPrice: Only required if order type changed to market from something else
     * @param orderParams.reduceOnly:
     * @param orderParams.postOnly:
     * @param orderParams.bitFlags:
     * @param orderParams.policy:
     * @param orderParams.maxTs:
     * @returns
     */
    async modifyOrderByUserOrderId(orderParams, txParams, subAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getModifyOrderByUserIdIx(orderParams, subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getModifyOrderByUserIdIx({ userOrderId, newDirection, newBaseAmount, newLimitPrice, newOraclePriceOffset, newTriggerPrice, newTriggerCondition, auctionDuration, auctionStartPrice, auctionEndPrice, reduceOnly, postOnly, bitFlags, maxTs, policy, }, subAccountId) {
        const user = await this.getUserAccountPublicKey(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(subAccountId)],
            useMarketLastSlotCache: true,
        });
        const orderParams = {
            baseAssetAmount: newBaseAmount || null,
            direction: newDirection || null,
            price: newLimitPrice || null,
            oraclePriceOffset: newOraclePriceOffset || null,
            triggerPrice: newTriggerPrice || null,
            triggerCondition: newTriggerCondition || null,
            auctionDuration: auctionDuration || null,
            auctionStartPrice: auctionStartPrice || null,
            auctionEndPrice: auctionEndPrice || null,
            reduceOnly: reduceOnly || false,
            postOnly: postOnly || null,
            bitFlags: bitFlags || null,
            policy: policy || null,
            maxTs: maxTs || null,
        };
        return await this.program.instruction.modifyOrderByUserId(userOrderId, orderParams, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                userStats: this.getUserStatsAccountPublicKey(),
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async settlePNLs(users, marketIndexes, opts, txParams) {
        const filterInvalidMarkets = opts === null || opts === void 0 ? void 0 : opts.filterInvalidMarkets;
        // # Filter market indexes by markets with valid oracle
        const marketIndexToSettle = filterInvalidMarkets
            ? []
            : marketIndexes;
        if (filterInvalidMarkets) {
            for (const marketIndex of marketIndexes) {
                const perpMarketAccount = this.getPerpMarketAccount(marketIndex);
                const oraclePriceData = this.getOracleDataForPerpMarket(marketIndex);
                const stateAccountAndSlot = this.accountSubscriber.getStateAccountAndSlot();
                const oracleGuardRails = stateAccountAndSlot.data.oracleGuardRails;
                const isValid = (0, oracles_1.isOracleValid)(perpMarketAccount, oraclePriceData, oracleGuardRails, stateAccountAndSlot.slot);
                if (isValid) {
                    marketIndexToSettle.push(marketIndex);
                }
            }
        }
        // # Settle filtered market indexes
        const ixs = await this.getSettlePNLsIxs(users, marketIndexToSettle);
        const tx = await this.buildTransaction(ixs, txParams !== null && txParams !== void 0 ? txParams : {
            computeUnits: 1400000,
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getSettlePNLsIxs(users, marketIndexes, revenueShareEscrowMap) {
        const ixs = [];
        for (const { settleeUserAccountPublicKey, settleeUserAccount } of users) {
            for (const marketIndex of marketIndexes) {
                ixs.push(await this.settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex, revenueShareEscrowMap));
            }
        }
        return ixs;
    }
    async settlePNL(settleeUserAccountPublicKey, settleeUserAccount, marketIndex, txParams, optionalIxs, revenueShareEscrowMap) {
        const lookupTableAccounts = await this.fetchAllLookupTableAccounts();
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex, revenueShareEscrowMap), txParams, undefined, lookupTableAccounts, undefined, undefined, optionalIxs), [], this.opts);
        return txSig;
    }
    async settlePNLIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndex, revenueShareEscrowMap) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [settleeUserAccount],
            writablePerpMarketIndexes: [marketIndex],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        if (revenueShareEscrowMap) {
            const escrow = revenueShareEscrowMap.get(settleeUserAccount.authority.toBase58());
            if (escrow) {
                const escrowPk = (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, settleeUserAccount.authority);
                const builders = new Map();
                for (const order of escrow.orders) {
                    const eligibleBuilder = (0, builder_1.isBuilderOrderCompleted)(order) &&
                        !(0, builder_1.isBuilderOrderReferral)(order) &&
                        order.feesAccrued.gt(numericConstants_1.ZERO) &&
                        order.marketIndex === marketIndex;
                    if (eligibleBuilder && !builders.has(order.builderIdx)) {
                        builders.set(order.builderIdx, escrow.approvedBuilders[order.builderIdx].authority);
                    }
                }
                if (builders.size > 0) {
                    if (!remainingAccounts.find((a) => a.pubkey.equals(escrowPk))) {
                        remainingAccounts.push({
                            pubkey: escrowPk,
                            isSigner: false,
                            isWritable: true,
                        });
                    }
                    this.addBuilderToRemainingAccounts(Array.from(builders.values()), remainingAccounts);
                }
                // Include escrow and referrer accounts if referral rewards exist for this market
                const hasReferralForMarket = escrow.orders.some((o) => (0, builder_1.isBuilderOrderReferral)(o) &&
                    o.feesAccrued.gt(numericConstants_1.ZERO) &&
                    o.marketIndex === marketIndex);
                if (hasReferralForMarket) {
                    if (!remainingAccounts.find((a) => a.pubkey.equals(escrowPk))) {
                        remainingAccounts.push({
                            pubkey: escrowPk,
                            isSigner: false,
                            isWritable: true,
                        });
                    }
                    if (!escrow.referrer.equals(web3_js_1.PublicKey.default)) {
                        this.addBuilderToRemainingAccounts([escrow.referrer], remainingAccounts);
                    }
                }
            }
            else {
                // Stale-cache fallback: if the user has any builder orders, include escrow PDA. This allows
                // the program to lazily clean up any completed builder orders.
                for (const order of settleeUserAccount.orders) {
                    if ((0, orders_1.hasBuilder)(order)) {
                        const escrowPk = (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, settleeUserAccount.authority);
                        if (!remainingAccounts.find((a) => a.pubkey.equals(escrowPk))) {
                            remainingAccounts.push({
                                pubkey: escrowPk,
                                isSigner: false,
                                isWritable: true,
                            });
                        }
                        break;
                    }
                }
            }
        }
        return await this.program.instruction.settlePnl(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: settleeUserAccountPublicKey,
                spotMarketVault: this.getQuoteSpotMarketAccount().vault,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async settleMultiplePNLs(settleeUserAccountPublicKey, settleeUserAccount, marketIndexes, mode, revenueShareEscrowMap, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.settleMultiplePNLsIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndexes, mode, undefined, revenueShareEscrowMap), txParams), [], this.opts);
        return txSig;
    }
    async settleMultiplePNLsMultipleTxs(settleeUserAccountPublicKey, settleeUserAccount, marketIndexes, mode, txParams, optionalIxs, revenueShareEscrowMap) {
        // need multiple TXs because settling more than 4 markets won't fit in a single TX
        const txsToSign = [];
        const marketIndexesInFourGroups = [];
        for (let i = 0; i < marketIndexes.length; i += 4) {
            marketIndexesInFourGroups.push(marketIndexes.slice(i, i + 4));
        }
        for (const marketIndexes of marketIndexesInFourGroups) {
            const ix = await this.settleMultiplePNLsIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndexes, mode, undefined, revenueShareEscrowMap);
            const computeUnits = Math.min(300000 * marketIndexes.length, 1400000);
            const tx = await this.buildTransaction(ix, {
                ...txParams,
                computeUnits,
            }, undefined, undefined, undefined, undefined, optionalIxs);
            txsToSign.push(tx);
        }
        const txsMap = {};
        let i = 1;
        for (const tx of txsToSign) {
            txsMap[`tx-${i}`] = tx;
            i++;
        }
        const signedTxs = (await this.txHandler.getSignedTransactionMap(txsMap, this.provider.wallet)).signedTxMap;
        const txSigs = [];
        for (const key in signedTxs) {
            const tx = signedTxs[key];
            const { txSig } = await this.sendTransaction(tx, [], this.opts, true);
            txSigs.push(txSig);
        }
        return txSigs;
    }
    async settleMultiplePNLsIx(settleeUserAccountPublicKey, settleeUserAccount, marketIndexes, mode, overrides, revenueShareEscrowMap) {
        var _a;
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [settleeUserAccount],
            writablePerpMarketIndexes: marketIndexes,
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        if (revenueShareEscrowMap) {
            const escrow = revenueShareEscrowMap.get(settleeUserAccount.authority.toBase58());
            const builders = new Map();
            if (escrow) {
                for (const order of escrow.orders) {
                    const eligibleBuilder = (0, builder_1.isBuilderOrderCompleted)(order) &&
                        !(0, builder_1.isBuilderOrderReferral)(order) &&
                        order.feesAccrued.gt(numericConstants_1.ZERO) &&
                        marketIndexes.includes(order.marketIndex);
                    if (eligibleBuilder && !builders.has(order.builderIdx)) {
                        builders.set(order.builderIdx, escrow.approvedBuilders[order.builderIdx].authority);
                    }
                }
                if (builders.size > 0) {
                    const escrowPk = (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, settleeUserAccount.authority);
                    if (!remainingAccounts.find((a) => a.pubkey.equals(escrowPk))) {
                        remainingAccounts.push({
                            pubkey: escrowPk,
                            isSigner: false,
                            isWritable: true,
                        });
                    }
                    this.addBuilderToRemainingAccounts(Array.from(builders.values()), remainingAccounts);
                }
                // Include escrow and referrer accounts when there are referral rewards
                // for any of the markets we are settling, so on-chain sweep can find them.
                const hasReferralForRequestedMarkets = escrow.orders.some((o) => (0, builder_1.isBuilderOrderReferral)(o) &&
                    o.feesAccrued.gt(numericConstants_1.ZERO) &&
                    marketIndexes.includes(o.marketIndex));
                if (hasReferralForRequestedMarkets) {
                    const escrowPk = (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, settleeUserAccount.authority);
                    if (!remainingAccounts.find((a) => a.pubkey.equals(escrowPk))) {
                        remainingAccounts.push({
                            pubkey: escrowPk,
                            isSigner: false,
                            isWritable: true,
                        });
                    }
                    // Add referrer's User and RevenueShare accounts
                    if (!escrow.referrer.equals(web3_js_1.PublicKey.default)) {
                        this.addBuilderToRemainingAccounts([escrow.referrer], remainingAccounts);
                    }
                }
            }
            else {
                // Stale-cache fallback: if the user has any builder orders, include escrow PDA. This allows
                // the program to lazily clean up any completed builder orders.
                for (const order of settleeUserAccount.orders) {
                    if ((0, orders_1.hasBuilder)(order)) {
                        const escrowPk = (0, pda_1.getRevenueShareEscrowAccountPublicKey)(this.program.programId, settleeUserAccount.authority);
                        if (!remainingAccounts.find((a) => a.pubkey.equals(escrowPk))) {
                            remainingAccounts.push({
                                pubkey: escrowPk,
                                isSigner: false,
                                isWritable: true,
                            });
                        }
                        break;
                    }
                }
            }
        }
        return await this.program.instruction.settleMultiplePnls(marketIndexes, mode, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: (_a = overrides === null || overrides === void 0 ? void 0 : overrides.authority) !== null && _a !== void 0 ? _a : this.wallet.publicKey,
                user: settleeUserAccountPublicKey,
                spotMarketVault: this.getQuoteSpotMarketAccount().vault,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getSetUserStatusToBeingLiquidatedIx(userAccountPublicKey, userAccount) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
        });
        return await this.program.instruction.setUserStatusToBeingLiquidated({
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                authority: this.wallet.publicKey,
            },
            remainingAccounts,
        });
    }
    async setUserStatusToBeingLiquidated(userAccountPublicKey, userAccount) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSetUserStatusToBeingLiquidatedIx(userAccountPublicKey, userAccount)), [], this.opts);
        return txSig;
    }
    async liquidatePerp(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidatePerpIx(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getLiquidatePerpIx(userAccountPublicKey, userAccount, marketIndex, maxBaseAssetAmount, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            useMarketLastSlotCache: true,
            writablePerpMarketIndexes: [marketIndex],
        });
        return await this.program.instruction.liquidatePerp(marketIndex, maxBaseAssetAmount, limitPrice !== null && limitPrice !== void 0 ? limitPrice : null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidatePerpWithFill(userAccountPublicKey, userAccount, marketIndex, makerInfos, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidatePerpWithFillIx(userAccountPublicKey, userAccount, marketIndex, makerInfos, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(marketIndex, slot);
        return txSig;
    }
    async getLiquidatePerpWithFillIx(userAccountPublicKey, userAccount, marketIndex, makerInfos, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [
                userAccount,
                ...makerInfos.map((makerInfo) => makerInfo.makerUserAccount),
            ],
            writablePerpMarketIndexes: [marketIndex],
        });
        for (const makerInfo of makerInfos) {
            remainingAccounts.push({
                pubkey: makerInfo.maker,
                isSigner: false,
                isWritable: true,
            });
            remainingAccounts.push({
                pubkey: makerInfo.makerStats,
                isSigner: false,
                isWritable: true,
            });
        }
        return await this.program.instruction.liquidatePerpWithFill(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidateSpot(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidateSpotIx(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.spotMarketLastSlotCache.set(assetMarketIndex, slot);
        this.spotMarketLastSlotCache.set(liabilityMarketIndex, slot);
        return txSig;
    }
    async getLiquidateSpotIx(userAccountPublicKey, userAccount, assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            useMarketLastSlotCache: true,
            writableSpotMarketIndexes: [liabilityMarketIndex, assetMarketIndex],
        });
        return await this.program.instruction.liquidateSpot(assetMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getJupiterLiquidateSpotWithSwapIxV6({ jupiterClient, liabilityMarketIndex, assetMarketIndex, swapAmount, assetTokenAccount, liabilityTokenAccount, slippageBps, swapMode, onlyDirectRoutes, quote, userAccount, userAccountPublicKey, userStatsAccountPublicKey, liquidatorSubAccountId, maxAccounts, }) {
        const liabilityMarket = this.getSpotMarketAccount(liabilityMarketIndex);
        const assetMarket = this.getSpotMarketAccount(assetMarketIndex);
        if (!quote) {
            const fetchedQuote = await jupiterClient.getQuote({
                inputMint: assetMarket.mint,
                outputMint: liabilityMarket.mint,
                amount: swapAmount,
                slippageBps,
                swapMode,
                onlyDirectRoutes,
                maxAccounts,
            });
            quote = fetchedQuote;
        }
        if (!quote) {
            throw new Error('Could not fetch swap quote. Please try again.');
        }
        const amountIn = new anchor_1.BN(quote.inAmount);
        const transaction = await jupiterClient.getSwap({
            quote,
            userPublicKey: this.provider.wallet.publicKey,
            slippageBps,
        });
        const { transactionMessage, lookupTables } = await jupiterClient.getTransactionMessageAndLookupTables({
            transaction,
        });
        const jupiterInstructions = jupiterClient.getJupiterInstructions({
            transactionMessage,
            inputMint: assetMarket.mint,
            outputMint: liabilityMarket.mint,
        });
        const preInstructions = [];
        if (!liabilityTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(liabilityMarket);
            liabilityTokenAccount = await this.getAssociatedTokenAccount(liabilityMarket.marketIndex, false, tokenProgram);
            preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(liabilityTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, liabilityMarket.mint, tokenProgram));
        }
        if (!assetTokenAccount) {
            const tokenProgram = this.getTokenProgramForSpotMarket(assetMarket);
            assetTokenAccount = await this.getAssociatedTokenAccount(assetMarket.marketIndex, false, tokenProgram);
            preInstructions.push(this.createAssociatedTokenAccountIdempotentInstruction(assetTokenAccount, this.provider.wallet.publicKey, this.provider.wallet.publicKey, assetMarket.mint, tokenProgram));
        }
        const { beginSwapIx, endSwapIx } = await this.getLiquidateSpotWithSwapIx({
            liabilityMarketIndex,
            assetMarketIndex,
            swapAmount: amountIn,
            assetTokenAccount,
            liabilityTokenAccount,
            userAccount,
            userAccountPublicKey,
            userStatsAccountPublicKey,
            liquidatorSubAccountId,
        });
        const ixs = [
            ...preInstructions,
            beginSwapIx,
            ...jupiterInstructions,
            endSwapIx,
        ];
        return { ixs, lookupTables };
    }
    /**
     * Get the drift liquidate_spot_with_swap instructions
     *
     * @param liabilityMarketIndex the market index of the token you're buying
     * @param assetMarketIndex the market index of the token you're selling
     * @param amountIn the amount of the token to sell
     * @param assetTokenAccount the token account to move the tokens being sold
     * @param liabilityTokenAccount the token account to receive the tokens being bought
     * @param userAccount
     * @param userAccountPublicKey
     * @param userStatsAccountPublicKey
     */
    async getLiquidateSpotWithSwapIx({ liabilityMarketIndex, assetMarketIndex, swapAmount: swapAmount, assetTokenAccount, liabilityTokenAccount, userAccount, userAccountPublicKey, userStatsAccountPublicKey, liquidatorSubAccountId, }) {
        const liquidatorAccountPublicKey = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const userAccounts = [userAccount];
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts,
            writableSpotMarketIndexes: [liabilityMarketIndex, assetMarketIndex],
            readableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const liabilitySpotMarket = this.getSpotMarketAccount(liabilityMarketIndex);
        const assetSpotMarket = this.getSpotMarketAccount(assetMarketIndex);
        const liabilityTokenProgram = this.getTokenProgramForSpotMarket(liabilitySpotMarket);
        const assetTokenProgram = this.getTokenProgramForSpotMarket(assetSpotMarket);
        if (!liabilityTokenProgram.equals(assetTokenProgram)) {
            remainingAccounts.push({
                pubkey: liabilityTokenProgram,
                isWritable: false,
                isSigner: false,
            });
        }
        if (this.isToken2022(liabilitySpotMarket) ||
            this.isToken2022(assetSpotMarket)) {
            remainingAccounts.push({
                pubkey: assetSpotMarket.mint,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: liabilitySpotMarket.mint,
                isWritable: false,
                isSigner: false,
            });
            if (this.isTransferHook(assetSpotMarket)) {
                this.addExtraAccountMetasToRemainingAccounts(assetSpotMarket.mint, remainingAccounts);
            }
            if (this.isTransferHook(liabilitySpotMarket)) {
                this.addExtraAccountMetasToRemainingAccounts(liabilitySpotMarket.mint, remainingAccounts);
            }
        }
        const beginSwapIx = await this.program.instruction.liquidateSpotWithSwapBegin(assetMarketIndex, liabilityMarketIndex, swapAmount, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: userStatsAccountPublicKey,
                liquidator: liquidatorAccountPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
                authority: this.wallet.publicKey,
                liabilitySpotMarketVault: liabilitySpotMarket.vault,
                assetSpotMarketVault: assetSpotMarket.vault,
                assetTokenAccount: assetTokenAccount,
                liabilityTokenAccount: liabilityTokenAccount,
                tokenProgram: assetTokenProgram,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        const endSwapIx = await this.program.instruction.liquidateSpotWithSwapEnd(assetMarketIndex, liabilityMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                userStats: userStatsAccountPublicKey,
                liquidator: liquidatorAccountPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
                authority: this.wallet.publicKey,
                liabilitySpotMarketVault: liabilitySpotMarket.vault,
                assetSpotMarketVault: assetSpotMarket.vault,
                assetTokenAccount: assetTokenAccount,
                liabilityTokenAccount: liabilityTokenAccount,
                tokenProgram: assetTokenProgram,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        return { beginSwapIx, endSwapIx };
    }
    async getInsuranceFundSwapIx({ inMarketIndex, outMarketIndex, amountIn, inTokenAccount, outTokenAccount, }) {
        const remainingAccounts = await this.getRemainingAccounts({
            userAccounts: [],
            writableSpotMarketIndexes: [inMarketIndex, outMarketIndex],
        });
        const inSpotMarket = this.getSpotMarketAccount(inMarketIndex);
        const outSpotMarket = this.getSpotMarketAccount(outMarketIndex);
        if (this.isToken2022(inSpotMarket) || this.isToken2022(outSpotMarket)) {
            remainingAccounts.push({
                pubkey: inSpotMarket.mint,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: outSpotMarket.mint,
                isWritable: false,
                isSigner: false,
            });
            if (this.isTransferHook(inSpotMarket)) {
                this.addExtraAccountMetasToRemainingAccounts(inSpotMarket.mint, remainingAccounts);
            }
            if (this.isTransferHook(outSpotMarket)) {
                this.addExtraAccountMetasToRemainingAccounts(outSpotMarket.mint, remainingAccounts);
            }
        }
        const ifRebalanceConfig = (0, pda_1.getIfRebalanceConfigPublicKey)(this.program.programId, inMarketIndex, outMarketIndex);
        const beginSwapIx = await this.program.instruction.beginInsuranceFundSwap(inMarketIndex, outMarketIndex, amountIn, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                outInsuranceFundVault: outSpotMarket.insuranceFund.vault,
                inInsuranceFundVault: inSpotMarket.insuranceFund.vault,
                outTokenAccount,
                inTokenAccount,
                ifRebalanceConfig: ifRebalanceConfig,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        const endSwapIx = await this.program.instruction.endInsuranceFundSwap(inMarketIndex, outMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                outInsuranceFundVault: outSpotMarket.insuranceFund.vault,
                inInsuranceFundVault: inSpotMarket.insuranceFund.vault,
                outTokenAccount,
                inTokenAccount,
                ifRebalanceConfig: ifRebalanceConfig,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                driftSigner: this.getStateAccount().signer,
                instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts,
        });
        return { beginSwapIx, endSwapIx };
    }
    async liquidateBorrowForPerpPnl(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidateBorrowForPerpPnlIx(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(perpMarketIndex, slot);
        this.spotMarketLastSlotCache.set(liabilityMarketIndex, slot);
        return txSig;
    }
    async getLiquidateBorrowForPerpPnlIx(userAccountPublicKey, userAccount, perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [liabilityMarketIndex],
        });
        return await this.program.instruction.liquidateBorrowForPerpPnl(perpMarketIndex, liabilityMarketIndex, maxLiabilityTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async liquidatePerpPnlForDeposit(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice, txParams, liquidatorSubAccountId) {
        const { txSig, slot } = await this.sendTransaction(await this.buildTransaction(await this.getLiquidatePerpPnlForDepositIx(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice, liquidatorSubAccountId), txParams), [], this.opts);
        this.perpMarketLastSlotCache.set(perpMarketIndex, slot);
        this.spotMarketLastSlotCache.set(assetMarketIndex, slot);
        return txSig;
    }
    async getLiquidatePerpPnlForDepositIx(userAccountPublicKey, userAccount, perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [assetMarketIndex],
        });
        return await this.program.instruction.liquidatePerpPnlForDeposit(perpMarketIndex, assetMarketIndex, maxPnlTransfer, limitPrice || null, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async resolvePerpBankruptcy(userAccountPublicKey, userAccount, marketIndex, txParams, liquidatorSubAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getResolvePerpBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getResolvePerpBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writablePerpMarketIndexes: [marketIndex],
            writableSpotMarketIndexes: [numericConstants_1.QUOTE_SPOT_MARKET_INDEX],
        });
        const spotMarket = this.getQuoteSpotMarketAccount();
        return await this.program.instruction.resolvePerpBankruptcy(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidator,
                liquidatorStats: liquidatorStatsPublicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async resolveSpotBankruptcy(userAccountPublicKey, userAccount, marketIndex, txParams, liquidatorSubAccountId) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getResolveSpotBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getResolveSpotBankruptcyIx(userAccountPublicKey, userAccount, marketIndex, liquidatorSubAccountId) {
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, userAccount.authority);
        const liquidator = await this.getUserAccountPublicKey(liquidatorSubAccountId);
        const liquidatorStatsPublicKey = this.getUserStatsAccountPublicKey();
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount(liquidatorSubAccountId), userAccount],
            writableSpotMarketIndexes: [marketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const tokenProgramId = this.getTokenProgramForSpotMarket(spotMarket);
        this.addTokenMintToRemainingAccounts(spotMarket, remainingAccounts);
        if (this.isTransferHook(spotMarket)) {
            await this.addExtraAccountMetasToRemainingAccounts(spotMarket.mint, remainingAccounts);
        }
        return await this.program.instruction.resolveSpotBankruptcy(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                user: userAccountPublicKey,
                userStats: userStatsPublicKey,
                liquidatorStats: liquidatorStatsPublicKey,
                liquidator,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: tokenProgramId,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async updateFundingRate(perpMarketIndex, oracle, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateFundingRateIx(perpMarketIndex, oracle), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateFundingRateIx(perpMarketIndex, oracle) {
        const perpMarketPublicKey = await (0, pda_1.getPerpMarketPublicKey)(this.program.programId, perpMarketIndex);
        return await this.program.instruction.updateFundingRate(perpMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                perpMarket: perpMarketPublicKey,
                oracle: oracle,
            },
        });
    }
    async updatePrelaunchOracle(perpMarketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdatePrelaunchOracleIx(perpMarketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getUpdatePrelaunchOracleIx(perpMarketIndex) {
        const perpMarket = this.getPerpMarketAccount(perpMarketIndex);
        if (!(0, types_1.isVariant)(perpMarket.amm.oracleSource, 'prelaunch')) {
            throw new Error(`Wrong oracle source ${perpMarket.amm.oracleSource}`);
        }
        return await this.program.instruction.updatePrelaunchOracle({
            accounts: {
                state: await this.getStatePublicKey(),
                perpMarket: perpMarket.pubkey,
                oracle: perpMarket.amm.oracle,
            },
        });
    }
    async updatePerpBidAskTwap(perpMarketIndex, makers, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdatePerpBidAskTwapIx(perpMarketIndex, makers), txParams), [], this.opts);
        return txSig;
    }
    async getUpdatePerpBidAskTwapIx(perpMarketIndex, makers) {
        const perpMarket = this.getPerpMarketAccount(perpMarketIndex);
        const remainingAccounts = [];
        for (const [maker, makerStats] of makers) {
            remainingAccounts.push({
                pubkey: maker,
                isWritable: false,
                isSigner: false,
            });
            remainingAccounts.push({
                pubkey: makerStats,
                isWritable: false,
                isSigner: false,
            });
        }
        return await this.program.instruction.updatePerpBidAskTwap({
            accounts: {
                state: await this.getStatePublicKey(),
                perpMarket: perpMarket.pubkey,
                oracle: perpMarket.amm.oracle,
                authority: this.wallet.publicKey,
                keeperStats: this.getUserStatsAccountPublicKey(),
            },
            remainingAccounts,
        });
    }
    async settleFundingPayment(userAccountPublicKey, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSettleFundingPaymentIx(userAccountPublicKey), txParams), [], this.opts);
        return txSig;
    }
    async getSettleFundingPaymentIx(userAccountPublicKey) {
        const userAccount = (await this.program.account.user.fetch(userAccountPublicKey));
        const writablePerpMarketIndexes = [];
        for (const position of userAccount.perpPositions) {
            if (!(0, position_1.positionIsAvailable)(position)) {
                writablePerpMarketIndexes.push(position.marketIndex);
            }
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [userAccount],
            writablePerpMarketIndexes,
        });
        return await this.program.instruction.settleFundingPayment({
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
            },
            remainingAccounts,
        });
    }
    triggerEvent(eventName, data) {
        this.eventEmitter.emit(eventName, data);
    }
    getOracleDataForPerpMarket(marketIndex) {
        return this.accountSubscriber.getOraclePriceDataAndSlotForPerpMarket(marketIndex).data;
    }
    getMMOracleDataForPerpMarket(marketIndex) {
        const perpMarket = this.getPerpMarketAccount(marketIndex);
        const oracleData = this.getOracleDataForPerpMarket(marketIndex);
        const stateAccountAndSlot = this.accountSubscriber.getStateAccountAndSlot();
        const isMMOracleActive = !perpMarket.amm.mmOracleSlot.eq(numericConstants_1.ZERO);
        const pctDiff = perpMarket.amm.mmOraclePrice
            .sub(oracleData.price)
            .abs()
            .mul(numericConstants_1.PERCENTAGE_PRECISION)
            .div(anchor_1.BN.max(oracleData.price, numericConstants_1.ONE));
        const mmOracleSequenceId = perpMarket.amm.mmOracleSequenceId;
        // Do slot check for recency if sequence ids are zero or they're too divergent
        const doSlotCheckForRecency = oracleData.sequenceId == null ||
            oracleData.sequenceId.eq(numericConstants_1.ZERO) ||
            mmOracleSequenceId.eq(numericConstants_1.ZERO) ||
            oracleData.sequenceId
                .sub(perpMarket.amm.mmOracleSequenceId)
                .abs()
                .gt(oracleData.sequenceId.div(new anchor_1.BN(10000)));
        let isExchangeOracleMoreRecent = true;
        if (doSlotCheckForRecency &&
            oracleData.slot <= perpMarket.amm.mmOracleSlot) {
            isExchangeOracleMoreRecent = false;
        }
        else if (!doSlotCheckForRecency &&
            oracleData.sequenceId < mmOracleSequenceId) {
            isExchangeOracleMoreRecent = false;
        }
        const conf = (0, utils_3.getOracleConfidenceFromMMOracleData)(perpMarket.amm.mmOraclePrice, oracleData);
        if ((0, oracles_1.isOracleTooDivergent)(perpMarket.amm, {
            price: perpMarket.amm.mmOraclePrice,
            slot: perpMarket.amm.mmOracleSlot,
            confidence: conf,
            hasSufficientNumberOfDataPoints: true,
        }, stateAccountAndSlot.data.oracleGuardRails) ||
            perpMarket.amm.mmOraclePrice.eq(numericConstants_1.ZERO) ||
            isExchangeOracleMoreRecent ||
            pctDiff.gt(numericConstants_1.PERCENTAGE_PRECISION.divn(100)) // 1% threshold
        ) {
            return { ...oracleData, isMMOracleActive };
        }
        else {
            return {
                price: perpMarket.amm.mmOraclePrice,
                slot: perpMarket.amm.mmOracleSlot,
                confidence: conf,
                hasSufficientNumberOfDataPoints: true,
                isMMOracleActive,
            };
        }
    }
    getOracleDataForSpotMarket(marketIndex) {
        return this.accountSubscriber.getOraclePriceDataAndSlotForSpotMarket(marketIndex).data;
    }
    async initializeInsuranceFundStake(marketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getInitializeInsuranceFundStakeIx(marketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getInitializeInsuranceFundStakeIx(marketIndex) {
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const accounts = {
            insuranceFundStake: ifStakeAccountPublicKey,
            spotMarket: this.getSpotMarketAccount(marketIndex).pubkey,
            userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.wallet.publicKey // only allow payer to initialize own insurance fund stake account
            ),
            authority: this.wallet.publicKey,
            payer: this.wallet.publicKey,
            rent: anchor.web3.SYSVAR_RENT_PUBKEY,
            systemProgram: anchor.web3.SystemProgram.programId,
            state: await this.getStatePublicKey(),
        };
        return await this.program.instruction.initializeInsuranceFundStake(marketIndex, {
            accounts,
        });
    }
    async getAddInsuranceFundStakeIx(marketIndex, amount, collateralAccountPublicKey) {
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const remainingAccounts = [];
        this.addTokenMintToRemainingAccounts(spotMarket, remainingAccounts);
        if (this.isTransferHook(spotMarket)) {
            await this.addExtraAccountMetasToRemainingAccounts(spotMarket.mint, remainingAccounts);
        }
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarket);
        const ix = this.program.instruction.addInsuranceFundStake(marketIndex, amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.wallet.publicKey // only allow payer to add to own insurance fund stake account
                ),
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                userTokenAccount: collateralAccountPublicKey,
                tokenProgram,
            },
            remainingAccounts,
        });
        return ix;
    }
    /**
     * Add to an insurance fund stake and optionally initialize the account
     */
    async addInsuranceFundStake({ marketIndex, amount, collateralAccountPublicKey, initializeStakeAccount, fromSubaccount, txParams, }) {
        const addIfStakeIxs = await this.getAddInsuranceFundStakeIxs({
            marketIndex,
            amount,
            collateralAccountPublicKey,
            initializeStakeAccount,
            fromSubaccount,
        });
        const additionalSigners = [];
        const tx = await this.buildTransaction(addIfStakeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, additionalSigners, this.opts);
        return txSig;
    }
    /**
     * Get instructions to add to an insurance fund stake and optionally initialize the account
     */
    async getAddInsuranceFundStakeIxs({ marketIndex, amount, collateralAccountPublicKey, initializeStakeAccount, fromSubaccount, }) {
        const addIfStakeIxs = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const createWSOLTokenAccount = isSolMarket && collateralAccountPublicKey.equals(this.wallet.publicKey);
        const tokenProgramId = this.getTokenProgramForSpotMarket(spotMarketAccount);
        // create associated token account because it may not exist
        const associatedTokenAccountPublicKey = (0, spl_token_1.getAssociatedTokenAddressSync)(spotMarketAccount.mint, this.wallet.publicKey, true, tokenProgramId);
        addIfStakeIxs.push(await (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(this.wallet.publicKey, associatedTokenAccountPublicKey, this.wallet.publicKey, spotMarketAccount.mint, tokenProgramId));
        let tokenAccount;
        if (!(await this.checkIfAccountExists((0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.wallet.publicKey // only allow payer to initialize own user stats account
        )))) {
            addIfStakeIxs.push(await this.getInitializeUserStatsIx());
        }
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(amount, true);
            tokenAccount = pubkey;
            ixs.forEach((ix) => {
                addIfStakeIxs.push(ix);
            });
        }
        else {
            tokenAccount = collateralAccountPublicKey;
        }
        if (fromSubaccount) {
            const withdrawIx = await this.getWithdrawIx(amount, marketIndex, tokenAccount);
            addIfStakeIxs.push(withdrawIx);
        }
        if (initializeStakeAccount) {
            const initializeIx = await this.getInitializeInsuranceFundStakeIx(marketIndex);
            addIfStakeIxs.push(initializeIx);
        }
        const addFundsIx = await this.getAddInsuranceFundStakeIx(marketIndex, amount, tokenAccount);
        addIfStakeIxs.push(addFundsIx);
        if (createWSOLTokenAccount) {
            addIfStakeIxs.push((0, spl_token_1.createCloseAccountInstruction)(tokenAccount, this.wallet.publicKey, this.wallet.publicKey, []));
        }
        return addIfStakeIxs;
    }
    async requestRemoveInsuranceFundStake(marketIndex, amount, txParams) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const ix = await this.program.instruction.requestRemoveInsuranceFundStake(marketIndex, amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.wallet.publicKey // only allow payer to request remove own insurance fund stake account
                ),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
            },
        });
        const tx = await this.buildTransaction(ix, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async cancelRequestRemoveInsuranceFundStake(marketIndex, txParams) {
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const ix = await this.program.instruction.cancelRequestRemoveInsuranceFundStake(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.wallet.publicKey // only allow payer to request remove own insurance fund stake account
                ),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
            },
        });
        const tx = await this.buildTransaction(ix, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async removeInsuranceFundStake(marketIndex, collateralAccountPublicKey, txParams) {
        const removeIfStakeIxs = [];
        const spotMarketAccount = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, this.wallet.publicKey, marketIndex);
        const additionalSigners = [];
        const isSolMarket = spotMarketAccount.mint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        const createWSOLTokenAccount = isSolMarket && collateralAccountPublicKey.equals(this.wallet.publicKey);
        const tokenProgramId = this.getTokenProgramForSpotMarket(spotMarketAccount);
        let tokenAccount;
        if (createWSOLTokenAccount) {
            const { ixs, pubkey } = await this.getWrappedSolAccountCreationIxs(numericConstants_1.ZERO, true);
            tokenAccount = pubkey;
            ixs.forEach((ix) => {
                removeIfStakeIxs.push(ix);
            });
        }
        else {
            tokenAccount = collateralAccountPublicKey;
            const tokenAccountExists = await this.checkIfAccountExists(tokenAccount);
            if (!tokenAccountExists) {
                const createTokenAccountIx = await this.createAssociatedTokenAccountIdempotentInstruction(tokenAccount, this.wallet.publicKey, this.wallet.publicKey, spotMarketAccount.mint, tokenProgramId);
                removeIfStakeIxs.push(createTokenAccountIx);
            }
        }
        const remainingAccounts = [];
        this.addTokenMintToRemainingAccounts(spotMarketAccount, remainingAccounts);
        if (this.isTransferHook(spotMarketAccount)) {
            await this.addExtraAccountMetasToRemainingAccounts(spotMarketAccount.mint, remainingAccounts);
        }
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarketAccount);
        const removeStakeIx = await this.program.instruction.removeInsuranceFundStake(marketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, this.wallet.publicKey // only allow payer to request remove own insurance fund stake account
                ),
                authority: this.wallet.publicKey,
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                userTokenAccount: tokenAccount,
                tokenProgram,
            },
            remainingAccounts,
        });
        removeIfStakeIxs.push(removeStakeIx);
        // Close the wrapped sol account at the end of the transaction
        if (createWSOLTokenAccount) {
            removeIfStakeIxs.push((0, spl_token_1.createCloseAccountInstruction)(tokenAccount, this.wallet.publicKey, this.wallet.publicKey, []));
        }
        const tx = await this.buildTransaction(removeIfStakeIxs, txParams);
        const { txSig } = await this.sendTransaction(tx, additionalSigners, this.opts);
        return txSig;
    }
    async updateUserQuoteAssetInsuranceStake(authority, txParams) {
        const tx = await this.buildTransaction(await this.getUpdateUserQuoteAssetInsuranceStakeIx(authority), txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserQuoteAssetInsuranceStakeIx(authority) {
        const marketIndex = numericConstants_1.QUOTE_SPOT_MARKET_INDEX;
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, authority, marketIndex);
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority);
        const ix = this.program.instruction.updateUserQuoteAssetInsuranceStake({
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: userStatsPublicKey,
                signer: this.wallet.publicKey,
                insuranceFundVault: spotMarket.insuranceFund.vault,
            },
        });
        return ix;
    }
    async updateUserGovTokenInsuranceStake(authority, txParams) {
        const ix = await this.getUpdateUserGovTokenInsuranceStakeIx(authority);
        const tx = await this.buildTransaction(ix, txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateUserGovTokenInsuranceStakeIx(authority) {
        const marketIndex = numericConstants_1.GOV_SPOT_MARKET_INDEX;
        const spotMarket = this.getSpotMarketAccount(marketIndex);
        const ifStakeAccountPublicKey = (0, pda_1.getInsuranceFundStakeAccountPublicKey)(this.program.programId, authority, marketIndex);
        const userStatsPublicKey = (0, pda_1.getUserStatsAccountPublicKey)(this.program.programId, authority);
        const ix = this.program.instruction.updateUserGovTokenInsuranceStake({
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                insuranceFundStake: ifStakeAccountPublicKey,
                userStats: userStatsPublicKey,
                signer: this.wallet.publicKey,
                insuranceFundVault: spotMarket.insuranceFund.vault,
            },
        });
        return ix;
    }
    async settleRevenueToInsuranceFund(spotMarketIndex, txParams) {
        const tx = await this.buildTransaction(await this.getSettleRevenueToInsuranceFundIx(spotMarketIndex), txParams);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getSettleRevenueToInsuranceFundIx(spotMarketIndex) {
        const spotMarketAccount = this.getSpotMarketAccount(spotMarketIndex);
        const tokenProgramId = this.getTokenProgramForSpotMarket(spotMarketAccount);
        const remainingAccounts = [];
        this.addTokenMintToRemainingAccounts(spotMarketAccount, remainingAccounts);
        if (this.isTransferHook(spotMarketAccount)) {
            await this.addExtraAccountMetasToRemainingAccounts(spotMarketAccount.mint, remainingAccounts);
        }
        const ix = await this.program.instruction.settleRevenueToInsuranceFund(spotMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarketAccount.pubkey,
                spotMarketVault: spotMarketAccount.vault,
                driftSigner: this.getSignerPublicKey(),
                insuranceFundVault: spotMarketAccount.insuranceFund.vault,
                tokenProgram: tokenProgramId,
            },
            remainingAccounts,
        });
        return ix;
    }
    async resolvePerpPnlDeficit(spotMarketIndex, perpMarketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getResolvePerpPnlDeficitIx(spotMarketIndex, perpMarketIndex), txParams), [], this.opts);
        return txSig;
    }
    async getResolvePerpPnlDeficitIx(spotMarketIndex, perpMarketIndex) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [this.getUserAccount()],
            writablePerpMarketIndexes: [perpMarketIndex],
            writableSpotMarketIndexes: [spotMarketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(spotMarketIndex);
        const tokenProgramId = this.getTokenProgramForSpotMarket(spotMarket);
        return await this.program.instruction.resolvePerpPnlDeficit(spotMarketIndex, perpMarketIndex, {
            accounts: {
                state: await this.getStatePublicKey(),
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                insuranceFundVault: spotMarket.insuranceFund.vault,
                driftSigner: this.getSignerPublicKey(),
                tokenProgram: tokenProgramId,
            },
            remainingAccounts: remainingAccounts,
        });
    }
    async getDepositIntoSpotMarketRevenuePoolIx(marketIndex, amount, userTokenAccountPublicKey) {
        const spotMarket = await this.getSpotMarketAccount(marketIndex);
        const remainingAccounts = [];
        this.addTokenMintToRemainingAccounts(spotMarket, remainingAccounts);
        if (this.isTransferHook(spotMarket)) {
            await this.addExtraAccountMetasToRemainingAccounts(spotMarket.mint, remainingAccounts);
        }
        const tokenProgram = this.getTokenProgramForSpotMarket(spotMarket);
        const ix = await this.program.instruction.depositIntoSpotMarketRevenuePool(amount, {
            accounts: {
                state: await this.getStatePublicKey(),
                spotMarket: spotMarket.pubkey,
                authority: this.wallet.publicKey,
                spotMarketVault: spotMarket.vault,
                userTokenAccount: userTokenAccountPublicKey,
                tokenProgram,
            },
        });
        return ix;
    }
    /**
     * This ix will donate your funds to drift revenue pool. It does not deposit into your user account
     * @param marketIndex
     * @param amount
     * @param userTokenAccountPublicKey
     * @returns
     */
    async depositIntoSpotMarketRevenuePool(marketIndex, amount, userTokenAccountPublicKey) {
        const ix = await this.getDepositIntoSpotMarketRevenuePoolIx(marketIndex, amount, userTokenAccountPublicKey);
        const tx = await this.buildTransaction([ix]);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    getPerpMarketExtendedInfo(marketIndex) {
        var _a, _b;
        const marketAccount = this.getPerpMarketAccount(marketIndex);
        const quoteAccount = this.getSpotMarketAccount(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const extendedInfo = {
            marketIndex,
            minOrderSize: (_a = marketAccount.amm) === null || _a === void 0 ? void 0 : _a.minOrderSize,
            marginMaintenance: marketAccount.marginRatioMaintenance,
            pnlPoolValue: (0, spotBalance_1.getTokenAmount)((_b = marketAccount.pnlPool) === null || _b === void 0 ? void 0 : _b.scaledBalance, quoteAccount, types_1.SpotBalanceType.DEPOSIT),
            contractTier: marketAccount.contractTier,
            availableInsurance: (0, market_1.calculateMarketMaxAvailableInsurance)(marketAccount, quoteAccount),
        };
        return extendedInfo;
    }
    /**
     * Calculates taker / maker fee (as a percentage, e.g. .001 = 10 basis points) for particular marketType
     * @param marketType
     * @param positionMarketIndex
     * @returns : {takerFee: number, makerFee: number} Precision None
     */
    getMarketFees(marketType, marketIndex, user, enteringHighLeverageMode) {
        var _a;
        let feeTier;
        const userHLM = ((_a = user === null || user === void 0 ? void 0 : user.isHighLeverageMode('Initial')) !== null && _a !== void 0 ? _a : false) ||
            enteringHighLeverageMode;
        if (user && !userHLM) {
            feeTier = user.getUserFeeTier(marketType);
        }
        else {
            const state = this.getStateAccount();
            feeTier = (0, types_1.isVariant)(marketType, 'perp')
                ? state.perpFeeStructure.feeTiers[0]
                : state.spotFeeStructure.feeTiers[0];
        }
        let takerFee = feeTier.feeNumerator / feeTier.feeDenominator;
        let makerFee = feeTier.makerRebateNumerator / feeTier.makerRebateDenominator;
        if (marketIndex !== undefined) {
            let marketAccount = null;
            if ((0, types_1.isVariant)(marketType, 'perp')) {
                marketAccount = this.getPerpMarketAccount(marketIndex);
            }
            else {
                marketAccount = this.getSpotMarketAccount(marketIndex);
            }
            takerFee += (takerFee * marketAccount.feeAdjustment) / 100;
            if (userHLM) {
                takerFee *= 2;
            }
            makerFee += (makerFee * marketAccount.feeAdjustment) / 100;
        }
        return {
            takerFee,
            makerFee,
        };
    }
    /**
     * Returns the market index and type for a given market name
     * E.g. "SOL-PERP" -> { marketIndex: 0, marketType: MarketType.PERP }
     *
     * @param name
     */
    getMarketIndexAndType(name) {
        name = name.toUpperCase();
        for (const perpMarketAccount of this.getPerpMarketAccounts()) {
            if ((0, userName_1.decodeName)(perpMarketAccount.name).toUpperCase() === name) {
                return {
                    marketIndex: perpMarketAccount.marketIndex,
                    marketType: types_1.MarketType.PERP,
                };
            }
        }
        for (const spotMarketAccount of this.getSpotMarketAccounts()) {
            if ((0, userName_1.decodeName)(spotMarketAccount.name).toUpperCase() === name) {
                return {
                    marketIndex: spotMarketAccount.marketIndex,
                    marketType: types_1.MarketType.SPOT,
                };
            }
        }
        return undefined;
    }
    getReceiverProgram() {
        if (this.receiverProgram === undefined) {
            this.receiverProgram = new anchor_1.Program(pyth_solana_receiver_json_1.default, pyth_1.DEFAULT_RECEIVER_PROGRAM_ID, this.provider);
        }
        return this.receiverProgram;
    }
    async getSwitchboardOnDemandProgram() {
        if (this.sbOnDemandProgram === undefined) {
            this.sbOnDemandProgram = await on_demand_1.AnchorUtils.loadProgramFromConnection(this.connection);
        }
        return this.sbOnDemandProgram;
    }
    async postPythPullOracleUpdateAtomic(vaaString, feedId) {
        const postIxs = await this.getPostPythPullOracleUpdateAtomicIxs(vaaString, feedId);
        const tx = await this.buildTransaction(postIxs);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async postMultiPythPullOracleUpdatesAtomic(vaaString, feedIds) {
        const postIxs = await this.getPostPythPullOracleUpdateAtomicIxs(vaaString, feedIds);
        const tx = await this.buildTransaction(postIxs);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getPostPythPullOracleUpdateAtomicIxs(vaaString, feedIds, numSignatures = 2) {
        const accumulatorUpdateData = (0, price_service_sdk_1.parseAccumulatorUpdateData)(Buffer.from(vaaString, 'base64'));
        const guardianSetIndex = accumulatorUpdateData.vaa.readUInt32BE(1);
        const guardianSet = (0, pyth_1.getGuardianSetPda)(guardianSetIndex, pyth_1.DEFAULT_WORMHOLE_PROGRAM_ID);
        const trimmedVaa = (0, oracles_1.trimVaaSignatures)(accumulatorUpdateData.vaa, numSignatures);
        const postIxs = [];
        if (accumulatorUpdateData.updates.length > 1) {
            const encodedParams = this.getReceiverProgram().coder.types.encode('PostMultiUpdatesAtomicParams', {
                vaa: trimmedVaa,
                merklePriceUpdates: accumulatorUpdateData.updates,
            });
            const feedIdsToUse = typeof feedIds === 'string' ? [feedIds] : feedIds;
            const pubkeys = feedIdsToUse.map((feedId) => {
                return (0, pda_1.getPythPullOraclePublicKey)(this.program.programId, (0, pythOracleUtils_1.getFeedIdUint8Array)(feedId));
            });
            const remainingAccounts = pubkeys.map((pubkey) => {
                return {
                    pubkey,
                    isSigner: false,
                    isWritable: true,
                };
            });
            postIxs.push(this.program.instruction.postMultiPythPullOracleUpdatesAtomic(encodedParams, {
                accounts: {
                    keeper: this.wallet.publicKey,
                    pythSolanaReceiver: config_1.DRIFT_ORACLE_RECEIVER_ID,
                    guardianSet,
                },
                remainingAccounts,
            }));
        }
        else {
            let feedIdToUse = typeof feedIds === 'string' ? feedIds : feedIds[0];
            feedIdToUse = (0, pythOracleUtils_1.trimFeedId)(feedIdToUse);
            postIxs.push(await this.getSinglePostPythPullOracleAtomicIx({
                vaa: trimmedVaa,
                merklePriceUpdate: accumulatorUpdateData.updates[0],
            }, feedIdToUse, guardianSet));
        }
        return postIxs;
    }
    async getSinglePostPythPullOracleAtomicIx(params, feedId, guardianSet) {
        const feedIdBuffer = (0, pythOracleUtils_1.getFeedIdUint8Array)(feedId);
        const receiverProgram = this.getReceiverProgram();
        const encodedParams = receiverProgram.coder.types.encode('PostUpdateAtomicParams', params);
        return this.program.instruction.postPythPullOracleUpdateAtomic(feedIdBuffer, encodedParams, {
            accounts: {
                keeper: this.wallet.publicKey,
                pythSolanaReceiver: config_1.DRIFT_ORACLE_RECEIVER_ID,
                guardianSet,
                priceFeed: (0, pda_1.getPythPullOraclePublicKey)(this.program.programId, feedIdBuffer),
            },
        });
    }
    async updatePythPullOracle(vaaString, feedId) {
        feedId = (0, pythOracleUtils_1.trimFeedId)(feedId);
        const accumulatorUpdateData = (0, price_service_sdk_1.parseAccumulatorUpdateData)(Buffer.from(vaaString, 'base64'));
        const guardianSetIndex = accumulatorUpdateData.vaa.readUInt32BE(1);
        const guardianSet = (0, pyth_1.getGuardianSetPda)(guardianSetIndex, pyth_1.DEFAULT_WORMHOLE_PROGRAM_ID);
        const [postIxs, encodedVaaAddress] = await this.getBuildEncodedVaaIxs(accumulatorUpdateData.vaa, guardianSet);
        for (const update of accumulatorUpdateData.updates) {
            postIxs.push(await this.getUpdatePythPullOracleIxs({
                merklePriceUpdate: update,
            }, feedId, encodedVaaAddress.publicKey));
        }
        const tx = await this.buildTransaction(postIxs);
        const { txSig } = await this.sendTransaction(tx, [encodedVaaAddress], this.opts);
        return txSig;
    }
    async getUpdatePythPullOracleIxs(params, feedId, encodedVaaAddress) {
        const feedIdBuffer = (0, pythOracleUtils_1.getFeedIdUint8Array)(feedId);
        const receiverProgram = this.getReceiverProgram();
        const encodedParams = receiverProgram.coder.types.encode('PostUpdateParams', params);
        return this.program.instruction.updatePythPullOracle(feedIdBuffer, encodedParams, {
            accounts: {
                keeper: this.wallet.publicKey,
                pythSolanaReceiver: config_1.DRIFT_ORACLE_RECEIVER_ID,
                encodedVaa: encodedVaaAddress,
                priceFeed: (0, pda_1.getPythPullOraclePublicKey)(this.program.programId, feedIdBuffer),
            },
        });
    }
    async postPythLazerOracleUpdate(feedIds, pythMessageHex) {
        const postIxs = await this.getPostPythLazerOracleUpdateIxs(feedIds, pythMessageHex, undefined, 2);
        const tx = await this.buildTransaction(postIxs);
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getPostPythLazerOracleUpdateIxs(feedIds, pythMessageHex, precedingIxs = [], overrideCustomIxIndex) {
        const pythMessageBytes = Buffer.from(pythMessageHex, 'hex');
        const verifyIx = (0, ed25519Utils_1.createMinimalEd25519VerifyIx)(overrideCustomIxIndex || precedingIxs.length + 1, 12, pythMessageBytes);
        const remainingAccountsMeta = feedIds.map((feedId) => {
            return {
                pubkey: (0, pda_1.getPythLazerOraclePublicKey)(this.program.programId, feedId),
                isSigner: false,
                isWritable: true,
            };
        });
        const ix = this.program.instruction.postPythLazerOracleUpdate(pythMessageBytes, {
            accounts: {
                keeper: this.wallet.publicKey,
                pythLazerStorage: config_1.PYTH_LAZER_STORAGE_ACCOUNT_KEY,
                ixSysvar: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
            },
            remainingAccounts: remainingAccountsMeta,
        });
        return [verifyIx, ix];
    }
    async getPostManySwitchboardOnDemandUpdatesAtomicIxs(feeds, recentSlothash, numSignatures = 3) {
        const program = await this.getSwitchboardOnDemandProgram();
        const [pullIxs, _luts, _rawResponse] = await on_demand_1.PullFeed.fetchUpdateManyLightIx(program, {
            feeds,
            numSignatures,
            recentSlothashes: recentSlothash
                ? [[new anchor_1.BN(recentSlothash.slot), recentSlothash.hash]]
                : undefined,
            chain: 'solana',
            network: this.env,
        });
        if (!pullIxs) {
            return undefined;
        }
        return pullIxs;
    }
    // @deprecated use getPostManySwitchboardOnDemandUpdatesAtomicIxs instead. This function no longer returns the required ixs due to upstream sdk changes.
    async getPostSwitchboardOnDemandUpdateAtomicIx(feed, recentSlothash, numSignatures = 3) {
        const program = await this.getSwitchboardOnDemandProgram();
        const feedAccount = new on_demand_1.PullFeed(program, feed);
        if (!this.sbProgramFeedConfigs) {
            this.sbProgramFeedConfigs = new Map();
        }
        if (!this.sbProgramFeedConfigs.has(feedAccount.pubkey.toString())) {
            const feedConfig = await feedAccount.loadConfigs();
            this.sbProgramFeedConfigs.set(feed.toString(), feedConfig);
        }
        const [pullIx, _responses, success] = await on_demand_1.PullFeed.fetchUpdateManyIx(program, {
            feeds: [feed],
            numSignatures,
            recentSlothashes: recentSlothash
                ? [[new anchor_1.BN(recentSlothash.slot), recentSlothash.hash]]
                : undefined,
        });
        if (!success) {
            return undefined;
        }
        return pullIx[0];
    }
    async postSwitchboardOnDemandUpdate(feed, recentSlothash, numSignatures = 3) {
        const pullIx = await this.getPostSwitchboardOnDemandUpdateAtomicIx(feed, recentSlothash, numSignatures);
        if (!pullIx) {
            return undefined;
        }
        const tx = await (0, on_demand_1.asV0Tx)({
            connection: this.connection,
            ixs: [pullIx],
            payer: this.wallet.publicKey,
            computeUnitLimitMultiple: 1.3,
            lookupTables: await this.fetchAllLookupTableAccounts(),
        });
        const { txSig } = await this.sendTransaction(tx, [], {
            commitment: 'processed',
            skipPreflight: true,
            maxRetries: 0,
        });
        return txSig;
    }
    async getBuildEncodedVaaIxs(vaa, guardianSet) {
        const postIxs = [];
        if (this.wormholeProgram === undefined) {
            this.wormholeProgram = new anchor_1.Program(pyth_1.WORMHOLE_CORE_BRIDGE_SOLANA_IDL, pyth_1.DEFAULT_WORMHOLE_PROGRAM_ID, this.provider);
        }
        const encodedVaaKeypair = new web3_js_1.Keypair();
        postIxs.push(await this.wormholeProgram.account.encodedVaa.createInstruction(encodedVaaKeypair, vaa.length + 46));
        // Why do we need this too?
        postIxs.push(await this.wormholeProgram.methods
            .initEncodedVaa()
            .accounts({
            encodedVaa: encodedVaaKeypair.publicKey,
        })
            .instruction());
        // Split the write into two ixs
        postIxs.push(await this.wormholeProgram.methods
            .writeEncodedVaa({
            index: 0,
            data: vaa.subarray(0, 755),
        })
            .accounts({
            draftVaa: encodedVaaKeypair.publicKey,
        })
            .instruction());
        postIxs.push(await this.wormholeProgram.methods
            .writeEncodedVaa({
            index: 755,
            data: vaa.subarray(755),
        })
            .accounts({
            draftVaa: encodedVaaKeypair.publicKey,
        })
            .instruction());
        // Verify
        postIxs.push(await this.wormholeProgram.methods
            .verifyEncodedVaaV1()
            .accounts({
            guardianSet,
            draftVaa: encodedVaaKeypair.publicKey,
        })
            .instruction());
        return [postIxs, encodedVaaKeypair];
    }
    async enableUserHighLeverageMode(subAccountId, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getEnableHighLeverageModeIx(subAccountId), txParams), [], this.opts);
        return txSig;
    }
    async getEnableHighLeverageModeIx(subAccountId, depositToTradeArgs, overrides) {
        var _a, _b, _c, _d;
        const isDepositToTradeTx = depositToTradeArgs !== undefined;
        const userAccountPublicKey = (_b = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.user) === null || _a === void 0 ? void 0 : _a.getUserAccountPublicKey()) !== null && _b !== void 0 ? _b : (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, this.wallet.publicKey, subAccountId);
        const signingAuthority = (_c = overrides === null || overrides === void 0 ? void 0 : overrides.signingAuthority) !== null && _c !== void 0 ? _c : this.wallet.publicKey;
        const userAccount = (_d = overrides === null || overrides === void 0 ? void 0 : overrides.user.getUserAccount()) !== null && _d !== void 0 ? _d : this.getUserAccount(subAccountId);
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: (depositToTradeArgs === null || depositToTradeArgs === void 0 ? void 0 : depositToTradeArgs.isMakingNewAccount) ? [] : [userAccount],
            useMarketLastSlotCache: false,
            readablePerpMarketIndex: depositToTradeArgs === null || depositToTradeArgs === void 0 ? void 0 : depositToTradeArgs.orderMarketIndex,
            readableSpotMarketIndexes: isDepositToTradeTx
                ? [depositToTradeArgs === null || depositToTradeArgs === void 0 ? void 0 : depositToTradeArgs.depositMarketIndex]
                : undefined,
        });
        const ix = await this.program.instruction.enableUserHighLeverageMode(subAccountId, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: userAccountPublicKey,
                authority: signingAuthority,
                highLeverageModeConfig: (0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId),
            },
            remainingAccounts,
        });
        return ix;
    }
    async disableUserHighLeverageMode(user, userAccount, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getDisableHighLeverageModeIx(user, userAccount), txParams), [], this.opts);
        return txSig;
    }
    async getDisableHighLeverageModeIx(user, userAccount, maintenance = false) {
        const remainingAccounts = userAccount
            ? this.getRemainingAccounts({
                userAccounts: [userAccount],
            })
            : undefined;
        const ix = await this.program.instruction.disableUserHighLeverageMode(maintenance, {
            accounts: {
                state: await this.getStatePublicKey(),
                user,
                authority: this.wallet.publicKey,
                highLeverageModeConfig: (0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId),
            },
            remainingAccounts,
        });
        return ix;
    }
    async fetchHighLeverageModeConfig() {
        const config = await this.program.account.highLeverageModeConfig.fetch((0, pda_1.getHighLeverageModeConfigPublicKey)(this.program.programId));
        return config;
    }
    async fetchProtectedMakerModeConfig() {
        const config = await this.program.account.protectedMakerModeConfig.fetch((0, pda_1.getProtectedMakerModeConfigPublicKey)(this.program.programId));
        return config;
    }
    async updateUserProtectedMakerOrders(subAccountId, protectedOrders, authority, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateUserProtectedMakerOrdersIx(subAccountId, protectedOrders, authority), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateUserProtectedMakerOrdersIx(subAccountId, protectedOrders, authority) {
        const ix = await this.program.instruction.updateUserProtectedMakerOrders(subAccountId, protectedOrders, {
            accounts: {
                state: await this.getStatePublicKey(),
                user: (0, pda_1.getUserAccountPublicKeySync)(this.program.programId, authority !== null && authority !== void 0 ? authority : this.authority, subAccountId),
                authority: this.wallet.publicKey,
                protectedMakerModeConfig: (0, pda_1.getProtectedMakerModeConfigPublicKey)(this.program.programId),
            },
        });
        return ix;
    }
    async getPauseSpotMarketDepositWithdrawIx(spotMarketIndex) {
        const spotMarket = await this.getSpotMarketAccount(spotMarketIndex);
        return this.program.instruction.pauseSpotMarketDepositWithdraw({
            accounts: {
                state: await this.getStatePublicKey(),
                keeper: this.wallet.publicKey,
                spotMarket: spotMarket.pubkey,
                spotMarketVault: spotMarket.vault,
            },
        });
    }
    async pauseSpotMarketDepositWithdraw(spotMarketIndex, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getPauseSpotMarketDepositWithdrawIx(spotMarketIndex), txParams), [], this.opts);
        return txSig;
    }
    async updateMmOracleNative(marketIndex, oraclePrice, oracleSequenceId) {
        const updateMmOracleIx = await this.getUpdateMmOracleNativeIx(marketIndex, oraclePrice, oracleSequenceId);
        const tx = await this.buildTransaction(updateMmOracleIx, {
            computeUnits: 5000,
            computeUnitsPrice: 0,
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    async getUpdateMmOracleNativeIx(marketIndex, oraclePrice, oracleSequenceId) {
        const discriminatorBuffer = (0, utils_2.createNativeInstructionDiscriminatorBuffer)(0);
        const data = Buffer.alloc(discriminatorBuffer.length + 16);
        data.set(discriminatorBuffer, 0);
        data.set(oraclePrice.toArrayLike(Buffer, 'le', 8), 5); // next 8 bytes
        data.set(oracleSequenceId.toArrayLike(Buffer, 'le', 8), 13); // next 8 bytes
        // Build the instruction manually
        return new web3_js_1.TransactionInstruction({
            programId: this.program.programId,
            keys: [
                {
                    pubkey: this.getPerpMarketAccount(marketIndex).pubkey,
                    isWritable: true,
                    isSigner: false,
                },
                {
                    pubkey: this.wallet.publicKey,
                    isWritable: false,
                    isSigner: true,
                },
                {
                    pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                    isWritable: false,
                    isSigner: false,
                },
                {
                    pubkey: await this.getStatePublicKey(),
                    isWritable: false,
                    isSigner: false,
                },
            ],
            data,
        });
    }
    async updateAmmSpreadAdjustmentNative(marketIndex, ammSpreadAdjustment) {
        const updateMmOracleIx = await this.getUpdateAmmSpreadAdjustmentNativeIx(marketIndex, ammSpreadAdjustment);
        const tx = await this.buildTransaction(updateMmOracleIx, {
            computeUnits: 1000,
            computeUnitsPrice: 0,
        });
        const { txSig } = await this.sendTransaction(tx, [], this.opts);
        return txSig;
    }
    getUpdateAmmSpreadAdjustmentNativeIx(marketIndex, ammSpreadAdjustment // i8
    ) {
        const discriminatorBuffer = (0, utils_2.createNativeInstructionDiscriminatorBuffer)(1);
        const data = Buffer.alloc(discriminatorBuffer.length + 4);
        data.set(discriminatorBuffer, 0);
        data.writeInt8(ammSpreadAdjustment, 5); // next byte
        // Build the instruction manually
        return new web3_js_1.TransactionInstruction({
            programId: this.program.programId,
            keys: [
                {
                    pubkey: this.getPerpMarketAccount(marketIndex).pubkey,
                    isWritable: true,
                    isSigner: false,
                },
                {
                    pubkey: this.wallet.publicKey,
                    isWritable: false,
                    isSigner: true,
                },
            ],
            data,
        });
    }
    async getLpPoolAccount(lpPoolId) {
        return (await this.program.account.lpPool.fetch((0, pda_1.getLpPoolPublicKey)(this.program.programId, lpPoolId)));
    }
    async getConstituentTargetBaseAccount(lpPoolId) {
        return (await this.program.account.constituentTargetBase.fetch((0, pda_1.getConstituentTargetBasePublicKey)(this.program.programId, (0, pda_1.getLpPoolPublicKey)(this.program.programId, lpPoolId))));
    }
    async getAmmCache() {
        return (await this.program.account.ammCache.fetch((0, pda_1.getAmmCachePublicKey)(this.program.programId)));
    }
    async updateLpConstituentTargetBase(lpPoolId, constituents, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateLpConstituentTargetBaseIx(lpPoolId, constituents), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateLpConstituentTargetBaseIx(lpPoolId, constituents) {
        const lpPool = (0, pda_1.getLpPoolPublicKey)(this.program.programId, lpPoolId);
        const ammConstituentMappingPublicKey = (0, pda_1.getAmmConstituentMappingPublicKey)(this.program.programId, lpPool);
        const constituentTargetBase = (0, pda_1.getConstituentTargetBasePublicKey)(this.program.programId, lpPool);
        const ammCache = (0, pda_1.getAmmCachePublicKey)(this.program.programId);
        const remainingAccounts = constituents.map((constituent) => {
            return {
                isWritable: false,
                isSigner: false,
                pubkey: constituent,
            };
        });
        return this.program.instruction.updateLpConstituentTargetBase({
            accounts: {
                keeper: this.wallet.publicKey,
                lpPool,
                ammConstituentMapping: ammConstituentMappingPublicKey,
                constituentTargetBase,
                state: await this.getStatePublicKey(),
                ammCache,
            },
            remainingAccounts,
        });
    }
    async updateLpPoolAum(lpPool, spotMarketIndexOfConstituents, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateLpPoolAumIxs(lpPool, spotMarketIndexOfConstituents), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateLpPoolAumIxs(lpPool, spotMarketIndexOfConstituents) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            readableSpotMarketIndexes: spotMarketIndexOfConstituents,
        });
        remainingAccounts.push(...spotMarketIndexOfConstituents.map((index) => {
            return {
                pubkey: (0, pda_1.getConstituentPublicKey)(this.program.programId, lpPool.pubkey, index),
                isSigner: false,
                isWritable: true,
            };
        }));
        return this.program.instruction.updateLpPoolAum({
            accounts: {
                keeper: this.wallet.publicKey,
                lpPool: lpPool.pubkey,
                state: await this.getStatePublicKey(),
                constituentTargetBase: (0, pda_1.getConstituentTargetBasePublicKey)(this.program.programId, lpPool.pubkey),
                ammCache: (0, pda_1.getAmmCachePublicKey)(this.program.programId),
            },
            remainingAccounts,
        });
    }
    async updateAmmCache(perpMarketIndexes, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateAmmCacheIx(perpMarketIndexes), txParams), [], this.opts);
        return txSig;
    }
    async getUpdateAmmCacheIx(perpMarketIndexes) {
        if (perpMarketIndexes.length > 50) {
            throw new Error('Cant update more than 50 markets at once');
        }
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            readablePerpMarketIndex: perpMarketIndexes,
        });
        return this.program.instruction.updateAmmCache({
            accounts: {
                state: await this.getStatePublicKey(),
                keeper: this.wallet.publicKey,
                ammCache: (0, pda_1.getAmmCachePublicKey)(this.program.programId),
                quoteMarket: this.getSpotMarketAccount(0).pubkey,
            },
            remainingAccounts,
        });
    }
    async updateConstituentOracleInfo(constituent) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getUpdateConstituentOracleInfoIx(constituent), undefined), [], this.opts);
        return txSig;
    }
    async getUpdateConstituentOracleInfoIx(constituent) {
        const spotMarket = this.getSpotMarketAccount(constituent.spotMarketIndex);
        return this.program.instruction.updateConstituentOracleInfo({
            accounts: {
                keeper: this.wallet.publicKey,
                constituent: constituent.pubkey,
                state: await this.getStatePublicKey(),
                oracle: spotMarket.oracle,
                spotMarket: spotMarket.pubkey,
            },
        });
    }
    async lpPoolSwap(inMarketIndex, outMarketIndex, inAmount, minOutAmount, lpPool, userAuthority, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getLpPoolSwapIx(inMarketIndex, outMarketIndex, inAmount, minOutAmount, lpPool, userAuthority), txParams), [], this.opts);
        return txSig;
    }
    async getLpPoolSwapIx(inMarketIndex, outMarketIndex, inAmount, minOutAmount, lpPool, userAuthority) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            readableSpotMarketIndexes: [inMarketIndex, outMarketIndex],
        });
        const constituentInTokenAccount = (0, pda_1.getConstituentVaultPublicKey)(this.program.programId, lpPool, inMarketIndex);
        const constituentOutTokenAccount = (0, pda_1.getConstituentVaultPublicKey)(this.program.programId, lpPool, outMarketIndex);
        const userInTokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(this.getSpotMarketAccount(inMarketIndex).mint, userAuthority);
        const userOutTokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(this.getSpotMarketAccount(outMarketIndex).mint, userAuthority);
        const inConstituent = (0, pda_1.getConstituentPublicKey)(this.program.programId, lpPool, inMarketIndex);
        const outConstituent = (0, pda_1.getConstituentPublicKey)(this.program.programId, lpPool, outMarketIndex);
        const inMarketMint = this.getSpotMarketAccount(inMarketIndex).mint;
        const outMarketMint = this.getSpotMarketAccount(outMarketIndex).mint;
        const constituentTargetBase = (0, pda_1.getConstituentTargetBasePublicKey)(this.program.programId, lpPool);
        return this.program.instruction.lpPoolSwap(inMarketIndex, outMarketIndex, inAmount, minOutAmount, {
            remainingAccounts,
            accounts: {
                state: await this.getStatePublicKey(),
                lpPool,
                constituentTargetBase,
                constituentInTokenAccount,
                constituentOutTokenAccount,
                constituentCorrelations: (0, pda_1.getConstituentCorrelationsPublicKey)(this.program.programId, lpPool),
                userInTokenAccount,
                userOutTokenAccount,
                inConstituent,
                outConstituent,
                inMarketMint,
                outMarketMint,
                authority: this.wallet.publicKey,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
        });
    }
    async viewLpPoolSwapFees(inMarketIndex, outMarketIndex, inAmount, inTargetWeight, outTargetWeight, lpPool, constituentTargetBase, constituentInTokenAccount, constituentOutTokenAccount, inConstituent, outConstituent, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getViewLpPoolSwapFeesIx(inMarketIndex, outMarketIndex, inAmount, inTargetWeight, outTargetWeight, lpPool, constituentTargetBase, constituentInTokenAccount, constituentOutTokenAccount, inConstituent, outConstituent), txParams), [], this.opts);
        return txSig;
    }
    async getViewLpPoolSwapFeesIx(inMarketIndex, outMarketIndex, inAmount, inTargetWeight, outTargetWeight, lpPool, constituentTargetBase, constituentInTokenAccount, constituentOutTokenAccount, inConstituent, outConstituent) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            readableSpotMarketIndexes: [inMarketIndex, outMarketIndex],
        });
        return this.program.instruction.viewLpPoolSwapFees(inMarketIndex, outMarketIndex, inAmount, inTargetWeight, outTargetWeight, {
            remainingAccounts,
            accounts: {
                driftSigner: this.getSignerPublicKey(),
                state: await this.getStatePublicKey(),
                lpPool,
                constituentTargetBase,
                constituentInTokenAccount,
                constituentOutTokenAccount,
                constituentCorrelations: (0, pda_1.getConstituentCorrelationsPublicKey)(this.program.programId, lpPool),
                inConstituent,
                outConstituent,
                authority: this.wallet.publicKey,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
        });
    }
    async getCreateLpPoolTokenAccountIx(lpPool) {
        const lpMint = lpPool.mint;
        const userLpTokenAccount = await (0, pda_1.getLpPoolTokenTokenAccountPublicKey)(lpMint, this.wallet.publicKey);
        return this.createAssociatedTokenAccountIdempotentInstruction(userLpTokenAccount, this.wallet.publicKey, this.wallet.publicKey, lpMint);
    }
    async createLpPoolTokenAccount(lpPool, txParams) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getCreateLpPoolTokenAccountIx(lpPool), txParams), [], this.opts);
        return txSig;
    }
    async lpPoolAddLiquidity({ inMarketIndex, inAmount, minMintAmount, lpPool, txParams, }) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getLpPoolAddLiquidityIx({
            inMarketIndex,
            inAmount,
            minMintAmount,
            lpPool,
        }), txParams), [], this.opts);
        return txSig;
    }
    async getLpPoolAddLiquidityIx({ inMarketIndex, inAmount, minMintAmount, lpPool, }) {
        const ixs = [];
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            writableSpotMarketIndexes: [inMarketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(inMarketIndex);
        const inMarketMint = spotMarket.mint;
        const isSolMarket = inMarketMint.equals(spotMarkets_1.WRAPPED_SOL_MINT);
        let wSolTokenAccount;
        if (isSolMarket) {
            const { ixs: wSolIxs, pubkey } = await this.getWrappedSolAccountCreationIxs(inAmount, true);
            wSolTokenAccount = pubkey;
            ixs.push(...wSolIxs);
        }
        const inConstituent = (0, pda_1.getConstituentPublicKey)(this.program.programId, lpPool.pubkey, inMarketIndex);
        const userInTokenAccount = wSolTokenAccount !== null && wSolTokenAccount !== void 0 ? wSolTokenAccount : (await this.getAssociatedTokenAccount(inMarketIndex, false));
        const constituentInTokenAccount = (0, pda_1.getConstituentVaultPublicKey)(this.program.programId, lpPool.pubkey, inMarketIndex);
        const lpMint = lpPool.mint;
        const userLpTokenAccount = await (0, pda_1.getLpPoolTokenTokenAccountPublicKey)(lpMint, this.wallet.publicKey);
        if (!(await this.checkIfAccountExists(userLpTokenAccount))) {
            ixs.push(this.createAssociatedTokenAccountIdempotentInstruction(userLpTokenAccount, this.wallet.publicKey, this.wallet.publicKey, lpMint));
        }
        const constituentTargetBase = (0, pda_1.getConstituentTargetBasePublicKey)(this.program.programId, lpPool.pubkey);
        if (!lpPool.whitelistMint.equals(web3_js_1.PublicKey.default)) {
            const associatedTokenPublicKey = await (0, spl_token_1.getAssociatedTokenAddress)(lpPool.whitelistMint, this.wallet.publicKey);
            remainingAccounts.push({
                pubkey: associatedTokenPublicKey,
                isWritable: false,
                isSigner: false,
            });
        }
        const lpPoolAddLiquidityIx = this.program.instruction.lpPoolAddLiquidity(inMarketIndex, inAmount, minMintAmount, {
            remainingAccounts,
            accounts: {
                state: await this.getStatePublicKey(),
                lpPool: lpPool.pubkey,
                authority: this.wallet.publicKey,
                inMarketMint,
                inConstituent,
                userInTokenAccount,
                constituentInTokenAccount,
                userLpTokenAccount,
                lpMint,
                lpPoolTokenVault: (0, pda_1.getLpPoolTokenVaultPublicKey)(this.program.programId, lpPool.pubkey),
                constituentTargetBase,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            },
        });
        ixs.push(lpPoolAddLiquidityIx);
        if (isSolMarket && wSolTokenAccount) {
            ixs.push((0, spl_token_1.createCloseAccountInstruction)(wSolTokenAccount, this.wallet.publicKey, this.wallet.publicKey));
        }
        return [...ixs];
    }
    async viewLpPoolAddLiquidityFees({ inMarketIndex, inAmount, lpPool, txParams, }) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getViewLpPoolAddLiquidityFeesIx({
            inMarketIndex,
            inAmount,
            lpPool,
        }), txParams), [], this.opts);
        return txSig;
    }
    async getViewLpPoolAddLiquidityFeesIx({ inMarketIndex, inAmount, lpPool, }) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            readableSpotMarketIndexes: [inMarketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(inMarketIndex);
        const inMarketMint = spotMarket.mint;
        const inConstituent = (0, pda_1.getConstituentPublicKey)(this.program.programId, lpPool.pubkey, inMarketIndex);
        const lpMint = lpPool.mint;
        const constituentTargetBase = (0, pda_1.getConstituentTargetBasePublicKey)(this.program.programId, lpPool.pubkey);
        return this.program.instruction.viewLpPoolAddLiquidityFees(inMarketIndex, inAmount, {
            accounts: {
                state: await this.getStatePublicKey(),
                lpPool: lpPool.pubkey,
                authority: this.wallet.publicKey,
                inMarketMint,
                inConstituent,
                lpMint,
                constituentTargetBase,
            },
            remainingAccounts,
        });
    }
    async lpPoolRemoveLiquidity({ outMarketIndex, lpToBurn, minAmountOut, lpPool, txParams, }) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getLpPoolRemoveLiquidityIx({
            outMarketIndex,
            lpToBurn,
            minAmountOut,
            lpPool,
        }), txParams), [], this.opts);
        return txSig;
    }
    async getLpPoolRemoveLiquidityIx({ outMarketIndex, lpToBurn, minAmountOut, lpPool, }) {
        const ixs = [];
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            writableSpotMarketIndexes: [outMarketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(outMarketIndex);
        const outMarketMint = spotMarket.mint;
        const outConstituent = (0, pda_1.getConstituentPublicKey)(this.program.programId, lpPool.pubkey, outMarketIndex);
        if (outMarketMint.equals(spotMarkets_1.WRAPPED_SOL_MINT)) {
            ixs.push((0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(this.wallet.publicKey, await this.getAssociatedTokenAccount(outMarketIndex, false), this.wallet.publicKey, spotMarkets_1.WRAPPED_SOL_MINT));
        }
        const userOutTokenAccount = await this.getAssociatedTokenAccount(outMarketIndex, false);
        const constituentOutTokenAccount = (0, pda_1.getConstituentVaultPublicKey)(this.program.programId, lpPool.pubkey, outMarketIndex);
        const lpMint = lpPool.mint;
        const userLpTokenAccount = await (0, spl_token_1.getAssociatedTokenAddress)(lpMint, this.wallet.publicKey, true);
        const constituentTargetBase = (0, pda_1.getConstituentTargetBasePublicKey)(this.program.programId, lpPool.pubkey);
        ixs.push(this.program.instruction.lpPoolRemoveLiquidity(outMarketIndex, lpToBurn, minAmountOut, {
            remainingAccounts,
            accounts: {
                driftSigner: this.getSignerPublicKey(),
                state: await this.getStatePublicKey(),
                lpPool: lpPool.pubkey,
                authority: this.wallet.publicKey,
                outMarketMint,
                outConstituent,
                userOutTokenAccount,
                constituentOutTokenAccount,
                userLpTokenAccount,
                spotMarketTokenAccount: spotMarket.vault,
                lpMint,
                lpPoolTokenVault: (0, pda_1.getLpPoolTokenVaultPublicKey)(this.program.programId, lpPool.pubkey),
                constituentTargetBase,
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                ammCache: (0, pda_1.getAmmCachePublicKey)(this.program.programId),
            },
        }));
        return ixs;
    }
    async viewLpPoolRemoveLiquidityFees({ outMarketIndex, lpToBurn, lpPool, txParams, }) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getViewLpPoolRemoveLiquidityFeesIx({
            outMarketIndex,
            lpToBurn,
            lpPool,
        }), txParams), [], this.opts);
        return txSig;
    }
    async getViewLpPoolRemoveLiquidityFeesIx({ outMarketIndex, lpToBurn, lpPool, }) {
        const remainingAccounts = this.getRemainingAccounts({
            userAccounts: [],
            writableSpotMarketIndexes: [outMarketIndex],
        });
        const spotMarket = this.getSpotMarketAccount(outMarketIndex);
        const outMarketMint = spotMarket.mint;
        const outConstituent = (0, pda_1.getConstituentPublicKey)(this.program.programId, lpPool.pubkey, outMarketIndex);
        const lpMint = lpPool.mint;
        const constituentTargetBase = (0, pda_1.getConstituentTargetBasePublicKey)(this.program.programId, lpPool.pubkey);
        return this.program.instruction.viewLpPoolRemoveLiquidityFees(outMarketIndex, lpToBurn, {
            remainingAccounts,
            accounts: {
                state: await this.getStatePublicKey(),
                lpPool: lpPool.pubkey,
                authority: this.wallet.publicKey,
                outMarketMint,
                outConstituent,
                lpMint,
                constituentTargetBase,
            },
        });
    }
    async getAllLpPoolAddLiquidityIxs({ inMarketIndex, inAmount, minMintAmount, lpPool, }, constituentMap, includeUpdateConstituentOracleInfo = true, view = false) {
        const ixs = [];
        ixs.push(...(await this.getAllUpdateLpPoolAumIxs(lpPool, constituentMap, includeUpdateConstituentOracleInfo)));
        if (view) {
            ixs.push(await this.getViewLpPoolAddLiquidityFeesIx({
                inMarketIndex,
                inAmount,
                lpPool,
            }));
        }
        else {
            ixs.push(...(await this.getLpPoolAddLiquidityIx({
                inMarketIndex,
                inAmount,
                minMintAmount,
                lpPool,
            })));
        }
        return ixs;
    }
    async getAllLpPoolRemoveLiquidityIxs({ outMarketIndex, lpToBurn, minAmountOut, lpPool, }, constituentMap, includeUpdateConstituentOracleInfo = true, view = false) {
        const ixs = [];
        ixs.push(...(await this.getAllSettlePerpToLpPoolIxs(lpPool.lpPoolId, this.getPerpMarketAccounts()
            .filter((marketAccount) => marketAccount.lpStatus > 0)
            .map((marketAccount) => marketAccount.marketIndex))));
        ixs.push(...(await this.getAllUpdateLpPoolAumIxs(lpPool, constituentMap, includeUpdateConstituentOracleInfo)));
        if (view) {
            ixs.push(await this.getViewLpPoolRemoveLiquidityFeesIx({
                outMarketIndex,
                lpToBurn,
                lpPool,
            }));
        }
        else {
            ixs.push(...(await this.getLpPoolRemoveLiquidityIx({
                outMarketIndex,
                lpToBurn,
                minAmountOut,
                lpPool,
            })));
        }
        return ixs;
    }
    async getAllUpdateLpPoolAumIxs(lpPool, constituentMap, includeUpdateConstituentOracleInfo = true) {
        const ixs = [];
        const constituents = Array.from(constituentMap.values());
        if (includeUpdateConstituentOracleInfo) {
            for (const constituent of constituents) {
                ixs.push(await this.getUpdateConstituentOracleInfoIx(constituent));
            }
        }
        const spotMarketIndexes = constituents.map((constituent) => constituent.spotMarketIndex);
        ixs.push(await this.getUpdateLpPoolAumIxs(lpPool, spotMarketIndexes));
        return ixs;
    }
    async getAllUpdateConstituentTargetBaseIxs(perpMarketIndexes, lpPool, constituentMap, includeUpdateConstituentOracleInfo = true) {
        const ixs = [];
        ixs.push(await this.getUpdateAmmCacheIx(perpMarketIndexes));
        const constituents = Array.from(constituentMap.values());
        if (includeUpdateConstituentOracleInfo) {
            for (const constituent of constituents) {
                ixs.push(await this.getUpdateConstituentOracleInfoIx(constituent));
            }
        }
        ixs.push(await this.getUpdateLpConstituentTargetBaseIx(lpPool.lpPoolId, Array.from(constituentMap.values()).map((constituent) => constituent.pubkey)));
        ixs.push(...(await this.getAllUpdateLpPoolAumIxs(lpPool, constituentMap, false)));
        return ixs;
    }
    async getAllLpPoolSwapIxs(lpPool, constituentMap, inMarketIndex, outMarketIndex, inAmount, minOutAmount, userAuthority) {
        const ixs = [];
        ixs.push(...(await this.getAllUpdateLpPoolAumIxs(lpPool, constituentMap)));
        ixs.push(await this.getLpPoolSwapIx(inMarketIndex, outMarketIndex, inAmount, minOutAmount, lpPool.pubkey, userAuthority));
        return ixs;
    }
    async settlePerpToLpPool(lpPoolId, perpMarketIndexes) {
        const { txSig } = await this.sendTransaction(await this.buildTransaction(await this.getSettlePerpToLpPoolIx(lpPoolId, perpMarketIndexes), undefined), [], this.opts);
        return txSig;
    }
    async getSettlePerpToLpPoolIx(lpPoolId, perpMarketIndexes) {
        const remainingAccounts = [];
        remainingAccounts.push(...perpMarketIndexes.map((index) => {
            return {
                pubkey: this.getPerpMarketAccount(index).pubkey,
                isSigner: false,
                isWritable: true,
            };
        }));
        const quoteSpotMarketAccount = this.getQuoteSpotMarketAccount();
        const lpPool = (0, pda_1.getLpPoolPublicKey)(this.program.programId, lpPoolId);
        return this.program.instruction.settlePerpToLpPool({
            accounts: {
                driftSigner: this.getSignerPublicKey(),
                state: await this.getStatePublicKey(),
                keeper: this.wallet.publicKey,
                ammCache: (0, pda_1.getAmmCachePublicKey)(this.program.programId),
                quoteMarket: quoteSpotMarketAccount.pubkey,
                constituent: (0, pda_1.getConstituentPublicKey)(this.program.programId, lpPool, 0),
                constituentQuoteTokenAccount: (0, pda_1.getConstituentVaultPublicKey)(this.program.programId, lpPool, 0),
                lpPool,
                quoteTokenVault: quoteSpotMarketAccount.vault,
                tokenProgram: this.getTokenProgramForSpotMarket(quoteSpotMarketAccount),
            },
            remainingAccounts,
        });
    }
    async getAllSettlePerpToLpPoolIxs(lpPoolId, marketIndexes) {
        const ixs = [];
        ixs.push(await this.getUpdateAmmCacheIx(marketIndexes));
        ixs.push(await this.getSettlePerpToLpPoolIx(lpPoolId, marketIndexes));
        return ixs;
    }
    /**
     * Below here are the transaction sending functions
     */
    handleSignedTransaction(signedTxs) {
        if (this.enableMetricsEvents && this.metricsEventEmitter) {
            this.metricsEventEmitter.emit('txSigned', signedTxs);
        }
    }
    handlePreSignedTransaction() {
        if (this.enableMetricsEvents && this.metricsEventEmitter) {
            this.metricsEventEmitter.emit('preTxSigned');
        }
    }
    isVersionedTransaction(tx) {
        return (0, utils_2.isVersionedTransaction)(tx);
    }
    /**
     * Send a transaction.
     *
     * @param tx
     * @param additionalSigners
     * @param opts :: Will fallback to DriftClient's opts if not provided
     * @param preSigned
     * @returns
     */
    sendTransaction(tx, additionalSigners, opts, preSigned) {
        const isVersionedTx = this.isVersionedTransaction(tx);
        if (isVersionedTx) {
            return this.txSender.sendVersionedTransaction(tx, additionalSigners, opts !== null && opts !== void 0 ? opts : this.opts, preSigned);
        }
        else {
            return this.txSender.send(tx, additionalSigners, opts !== null && opts !== void 0 ? opts : this.opts, preSigned);
        }
    }
    async buildTransaction(instructions, txParams, txVersion, lookupTables, forceVersionedTransaction, recentBlockhash, optionalIxs) {
        return this.txHandler.buildTransaction({
            instructions,
            txVersion: txVersion !== null && txVersion !== void 0 ? txVersion : this.txVersion,
            txParams: txParams !== null && txParams !== void 0 ? txParams : this.txParams,
            connection: this.connection,
            preFlightCommitment: this.opts.preflightCommitment,
            fetchAllMarketLookupTableAccounts: this.fetchAllLookupTableAccounts.bind(this),
            lookupTables,
            forceVersionedTransaction,
            recentBlockhash,
            optionalIxs,
        });
    }
    async buildBulkTransactions(instructions, txParams, txVersion, lookupTables, forceVersionedTransaction) {
        return this.txHandler.buildBulkTransactions({
            instructions,
            txVersion: txVersion !== null && txVersion !== void 0 ? txVersion : this.txVersion,
            txParams: txParams !== null && txParams !== void 0 ? txParams : this.txParams,
            connection: this.connection,
            preFlightCommitment: this.opts.preflightCommitment,
            fetchAllMarketLookupTableAccounts: this.fetchAllLookupTableAccounts.bind(this),
            lookupTables,
            forceVersionedTransaction,
        });
    }
    async buildTransactionsMap(instructionsMap, txParams, txVersion, lookupTables, forceVersionedTransaction) {
        return this.txHandler.buildTransactionsMap({
            instructionsMap,
            txVersion: txVersion !== null && txVersion !== void 0 ? txVersion : this.txVersion,
            txParams: txParams !== null && txParams !== void 0 ? txParams : this.txParams,
            connection: this.connection,
            preFlightCommitment: this.opts.preflightCommitment,
            fetchAllMarketLookupTableAccounts: this.fetchAllLookupTableAccounts.bind(this),
            lookupTables,
            forceVersionedTransaction,
        });
    }
    async buildAndSignTransactionsMap(instructionsMap, txParams, txVersion, lookupTables, forceVersionedTransaction) {
        return this.txHandler.buildAndSignTransactionMap({
            instructionsMap,
            txVersion: txVersion !== null && txVersion !== void 0 ? txVersion : this.txVersion,
            txParams: txParams !== null && txParams !== void 0 ? txParams : this.txParams,
            connection: this.connection,
            preFlightCommitment: this.opts.preflightCommitment,
            fetchAllMarketLookupTableAccounts: this.fetchAllLookupTableAccounts.bind(this),
            lookupTables,
            forceVersionedTransaction,
        });
    }
    isOrderIncreasingPosition(orderParams, subAccountId) {
        const userAccount = this.getUserAccount(subAccountId);
        const perpPosition = userAccount.perpPositions.find((p) => p.marketIndex === orderParams.marketIndex);
        if (!perpPosition)
            return true;
        const currentBase = perpPosition.baseAssetAmount;
        if (currentBase.eq(numericConstants_1.ZERO))
            return true;
        const orderBaseAmount = (0, types_1.isVariant)(orderParams.direction, 'long')
            ? orderParams.baseAssetAmount
            : orderParams.baseAssetAmount.neg();
        return currentBase.add(orderBaseAmount).abs().gt(currentBase.abs());
    }
}
exports.DriftClient = DriftClient;
