"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
const types_1 = require("./types");
const position_1 = require("./math/position");
const numericConstants_1 = require("./constants/numericConstants");
const bigNum_1 = require("./factory/bigNum");
const anchor_1 = require("@coral-xyz/anchor");
const position_2 = require("./math/position");
const market_1 = require("./math/market");
const margin_1 = require("./math/margin");
const spotMarket_1 = require("./math/spotMarket");
const utils_1 = require("./math/utils");
const spotBalance_1 = require("./math/spotBalance");
const trade_1 = require("./math/trade");
const types_2 = require("./types");
const orders_1 = require("./math/orders");
const websocketProgramUserAccountSubscriber_1 = require("./accounts/websocketProgramUserAccountSubscriber");
const spotBalance_2 = require("./math/spotBalance");
const margin_2 = require("./math/margin");
const pollingUserAccountSubscriber_1 = require("./accounts/pollingUserAccountSubscriber");
const webSocketUserAccountSubscriber_1 = require("./accounts/webSocketUserAccountSubscriber");
const spotPosition_1 = require("./math/spotPosition");
const oracles_1 = require("./math/oracles");
const tiers_1 = require("./math/tiers");
const strictOraclePrice_1 = require("./oracles/strictOraclePrice");
const fuel_1 = require("./math/fuel");
const grpcUserAccountSubscriber_1 = require("./accounts/grpcUserAccountSubscriber");
const marginCalculation_1 = require("./marginCalculation");
class User {
    get isSubscribed() {
        return this._isSubscribed && this.accountSubscriber.isSubscribed;
    }
    set isSubscribed(val) {
        this._isSubscribed = val;
    }
    constructor(config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this._isSubscribed = false;
        this.driftClient = config.driftClient;
        this.userAccountPublicKey = config.userAccountPublicKey;
        if (((_a = config.accountSubscription) === null || _a === void 0 ? void 0 : _a.type) === 'polling') {
            this.accountSubscriber = new pollingUserAccountSubscriber_1.PollingUserAccountSubscriber(config.driftClient.connection, config.userAccountPublicKey, config.accountSubscription.accountLoader, this.driftClient.program.account.user.coder.accounts.decodeUnchecked.bind(this.driftClient.program.account.user.coder.accounts));
        }
        else if (((_b = config.accountSubscription) === null || _b === void 0 ? void 0 : _b.type) === 'custom') {
            this.accountSubscriber = config.accountSubscription.userAccountSubscriber;
        }
        else if (((_c = config.accountSubscription) === null || _c === void 0 ? void 0 : _c.type) === 'grpc') {
            if (config.accountSubscription.grpcMultiUserAccountSubscriber) {
                this.accountSubscriber =
                    config.accountSubscription.grpcMultiUserAccountSubscriber.forUser(config.userAccountPublicKey);
            }
            else {
                this.accountSubscriber = new grpcUserAccountSubscriber_1.grpcUserAccountSubscriber(config.accountSubscription.grpcConfigs, config.driftClient.program, config.userAccountPublicKey, {
                    resubTimeoutMs: (_d = config.accountSubscription) === null || _d === void 0 ? void 0 : _d.resubTimeoutMs,
                    logResubMessages: (_e = config.accountSubscription) === null || _e === void 0 ? void 0 : _e.logResubMessages,
                });
            }
        }
        else {
            if (((_f = config.accountSubscription) === null || _f === void 0 ? void 0 : _f.type) === 'websocket' &&
                ((_g = config.accountSubscription) === null || _g === void 0 ? void 0 : _g.programUserAccountSubscriber)) {
                this.accountSubscriber = new websocketProgramUserAccountSubscriber_1.WebSocketProgramUserAccountSubscriber(config.driftClient.program, config.userAccountPublicKey, config.accountSubscription.programUserAccountSubscriber);
            }
            else {
                this.accountSubscriber = new webSocketUserAccountSubscriber_1.WebSocketUserAccountSubscriber(config.driftClient.program, config.userAccountPublicKey, {
                    resubTimeoutMs: (_h = config.accountSubscription) === null || _h === void 0 ? void 0 : _h.resubTimeoutMs,
                    logResubMessages: (_j = config.accountSubscription) === null || _j === void 0 ? void 0 : _j.logResubMessages,
                }, (_k = config.accountSubscription) === null || _k === void 0 ? void 0 : _k.commitment);
            }
        }
        this.eventEmitter = this.accountSubscriber.eventEmitter;
    }
    /**
     * Subscribe to User state accounts
     * @returns SusbcriptionSuccess result
     */
    async subscribe(userAccount) {
        this.isSubscribed = await this.accountSubscriber.subscribe(userAccount);
        return this.isSubscribed;
    }
    /**
     *	Forces the accountSubscriber to fetch account updates from rpc
     */
    async fetchAccounts() {
        await this.accountSubscriber.fetch();
    }
    async unsubscribe() {
        this.eventEmitter.removeAllListeners();
        await this.accountSubscriber.unsubscribe();
        this.isSubscribed = false;
    }
    getUserAccount() {
        return this.accountSubscriber.getUserAccountAndSlot().data;
    }
    async forceGetUserAccount() {
        await this.fetchAccounts();
        return this.accountSubscriber.getUserAccountAndSlot().data;
    }
    getUserAccountAndSlot() {
        return this.accountSubscriber.getUserAccountAndSlot();
    }
    getPerpPositionForUserAccount(userAccount, marketIndex) {
        return this.getActivePerpPositionsForUserAccount(userAccount).find((position) => position.marketIndex === marketIndex);
    }
    /**
     * Gets the user's current position for a given perp market. If the user has no position returns undefined
     * @param marketIndex
     * @returns userPerpPosition
     */
    getPerpPosition(marketIndex) {
        const userAccount = this.getUserAccount();
        return this.getPerpPositionForUserAccount(userAccount, marketIndex);
    }
    getPerpPositionOrEmpty(marketIndex) {
        var _a;
        const userAccount = this.getUserAccount();
        return ((_a = this.getPerpPositionForUserAccount(userAccount, marketIndex)) !== null && _a !== void 0 ? _a : this.getEmptyPosition(marketIndex));
    }
    getPerpPositionAndSlot(marketIndex) {
        const userAccount = this.getUserAccountAndSlot();
        const perpPosition = this.getPerpPositionForUserAccount(userAccount.data, marketIndex);
        return {
            data: perpPosition,
            slot: userAccount.slot,
        };
    }
    getSpotPositionForUserAccount(userAccount, marketIndex) {
        return userAccount.spotPositions.find((position) => position.marketIndex === marketIndex);
    }
    /**
     * Gets the user's current position for a given spot market. If the user has no position returns undefined
     * @param marketIndex
     * @returns userSpotPosition
     */
    getSpotPosition(marketIndex) {
        const userAccount = this.getUserAccount();
        return this.getSpotPositionForUserAccount(userAccount, marketIndex);
    }
    getSpotPositionAndSlot(marketIndex) {
        const userAccount = this.getUserAccountAndSlot();
        const spotPosition = this.getSpotPositionForUserAccount(userAccount.data, marketIndex);
        return {
            data: spotPosition,
            slot: userAccount.slot,
        };
    }
    getEmptySpotPosition(marketIndex) {
        return {
            marketIndex,
            scaledBalance: numericConstants_1.ZERO,
            balanceType: types_2.SpotBalanceType.DEPOSIT,
            cumulativeDeposits: numericConstants_1.ZERO,
            openAsks: numericConstants_1.ZERO,
            openBids: numericConstants_1.ZERO,
            openOrders: 0,
        };
    }
    /**
     * Returns the token amount for a given market. The spot market precision is based on the token mint decimals.
     * Positive if it is a deposit, negative if it is a borrow.
     *
     * @param marketIndex
     */
    getTokenAmount(marketIndex) {
        const spotPosition = this.getSpotPosition(marketIndex);
        if (spotPosition === undefined) {
            return numericConstants_1.ZERO;
        }
        const spotMarket = this.driftClient.getSpotMarketAccount(marketIndex);
        return (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_2.getTokenAmount)(spotPosition.scaledBalance, spotMarket, spotPosition.balanceType), spotPosition.balanceType);
    }
    getEmptyPosition(marketIndex) {
        return {
            baseAssetAmount: numericConstants_1.ZERO,
            remainderBaseAssetAmount: 0,
            lastCumulativeFundingRate: numericConstants_1.ZERO,
            marketIndex,
            quoteAssetAmount: numericConstants_1.ZERO,
            quoteEntryAmount: numericConstants_1.ZERO,
            quoteBreakEvenAmount: numericConstants_1.ZERO,
            openOrders: 0,
            openBids: numericConstants_1.ZERO,
            openAsks: numericConstants_1.ZERO,
            settledPnl: numericConstants_1.ZERO,
            lpShares: numericConstants_1.ZERO,
            lastQuoteAssetAmountPerLp: numericConstants_1.ZERO,
            perLpBase: 0,
            maxMarginRatio: 0,
            isolatedPositionScaledBalance: numericConstants_1.ZERO,
            positionFlag: 0,
        };
    }
    isPositionEmpty(position) {
        return position.baseAssetAmount.eq(numericConstants_1.ZERO) && position.openOrders === 0;
    }
    getIsolatePerpPositionTokenAmount(perpMarketIndex) {
        var _a;
        const perpPosition = this.getPerpPosition(perpMarketIndex);
        if (!perpPosition)
            return numericConstants_1.ZERO;
        const perpMarket = this.driftClient.getPerpMarketAccount(perpMarketIndex);
        const spotMarket = this.driftClient.getSpotMarketAccount(perpMarket.quoteSpotMarketIndex);
        if (perpPosition === undefined) {
            return numericConstants_1.ZERO;
        }
        return (0, spotBalance_2.getTokenAmount)((_a = perpPosition.isolatedPositionScaledBalance) !== null && _a !== void 0 ? _a : numericConstants_1.ZERO, //TODO remove ? later
        spotMarket, types_2.SpotBalanceType.DEPOSIT);
    }
    getClonedPosition(position) {
        const clonedPosition = Object.assign({}, position);
        return clonedPosition;
    }
    getOrderForUserAccount(userAccount, orderId) {
        return userAccount.orders.find((order) => order.orderId === orderId);
    }
    /**
     * @param orderId
     * @returns Order
     */
    getOrder(orderId) {
        const userAccount = this.getUserAccount();
        return this.getOrderForUserAccount(userAccount, orderId);
    }
    getOrderAndSlot(orderId) {
        const userAccount = this.getUserAccountAndSlot();
        const order = this.getOrderForUserAccount(userAccount.data, orderId);
        return {
            data: order,
            slot: userAccount.slot,
        };
    }
    getOrderByUserIdForUserAccount(userAccount, userOrderId) {
        return userAccount.orders.find((order) => order.userOrderId === userOrderId);
    }
    /**
     * @param userOrderId
     * @returns Order
     */
    getOrderByUserOrderId(userOrderId) {
        const userAccount = this.getUserAccount();
        return this.getOrderByUserIdForUserAccount(userAccount, userOrderId);
    }
    getOrderByUserOrderIdAndSlot(userOrderId) {
        const userAccount = this.getUserAccountAndSlot();
        const order = this.getOrderByUserIdForUserAccount(userAccount.data, userOrderId);
        return {
            data: order,
            slot: userAccount.slot,
        };
    }
    getOpenOrdersForUserAccount(userAccount) {
        return userAccount === null || userAccount === void 0 ? void 0 : userAccount.orders.filter((order) => (0, types_1.isVariant)(order.status, 'open'));
    }
    getOpenOrders() {
        const userAccount = this.getUserAccount();
        return this.getOpenOrdersForUserAccount(userAccount);
    }
    getOpenOrdersAndSlot() {
        const userAccount = this.getUserAccountAndSlot();
        const openOrders = this.getOpenOrdersForUserAccount(userAccount.data);
        return {
            data: openOrders,
            slot: userAccount.slot,
        };
    }
    getUserAccountPublicKey() {
        return this.userAccountPublicKey;
    }
    async exists() {
        const userAccountRPCResponse = await this.driftClient.connection.getParsedAccountInfo(this.userAccountPublicKey);
        return userAccountRPCResponse.value !== null;
    }
    /**
     * calculates the total open bids/asks in a perp market (including lps)
     * @returns : open bids
     * @returns : open asks
     */
    getPerpBidAsks(marketIndex) {
        const position = this.getPerpPosition(marketIndex);
        const totalOpenBids = position.openBids;
        const totalOpenAsks = position.openAsks;
        return [totalOpenBids, totalOpenAsks];
    }
    /**
     * calculates Buying Power = free collateral / initial margin ratio
     * @returns : Precision QUOTE_PRECISION
     */
    getPerpBuyingPower(marketIndex, collateralBuffer = numericConstants_1.ZERO, enterHighLeverageMode = undefined, maxMarginRatio = undefined, positionType = 'cross') {
        const perpPosition = this.getPerpPositionOrEmpty(marketIndex);
        const perpMarket = this.driftClient.getPerpMarketAccount(marketIndex);
        const oraclePriceData = this.getOracleDataForPerpMarket(marketIndex);
        const worstCaseBaseAssetAmount = perpPosition
            ? (0, margin_2.calculateWorstCaseBaseAssetAmount)(perpPosition, perpMarket, oraclePriceData.price)
            : numericConstants_1.ZERO;
        let freeCollateral = numericConstants_1.ZERO;
        // if position is isolated, we always add on available quote from the cross account
        if (positionType === 'isolated') {
            const { totalAssetValue: quoteSpotMarketAssetValue, totalLiabilityValue: quoteSpotMarketLiabilityValue, } = this.getSpotMarketAssetAndLiabilityValue(perpMarket.quoteSpotMarketIndex, 'Initial', undefined, undefined, true);
            freeCollateral = quoteSpotMarketAssetValue.sub(quoteSpotMarketLiabilityValue);
        }
        // adding free collateral from the cross account or from within isolated margin calc for this marketIndex
        freeCollateral = freeCollateral.add(this.getFreeCollateral('Initial', enterHighLeverageMode, positionType === 'isolated' ? marketIndex : undefined).sub(collateralBuffer));
        return this.getPerpBuyingPowerFromFreeCollateralAndBaseAssetAmount(marketIndex, freeCollateral, worstCaseBaseAssetAmount, enterHighLeverageMode, maxMarginRatio || perpPosition.maxMarginRatio);
    }
    getPerpBuyingPowerFromFreeCollateralAndBaseAssetAmount(marketIndex, freeCollateral, baseAssetAmount, enterHighLeverageMode = undefined, perpMarketMaxMarginRatio = undefined) {
        const maxMarginRatio = Math.max(perpMarketMaxMarginRatio, this.getUserAccount().maxMarginRatio);
        const marginRatio = (0, market_1.calculateMarketMarginRatio)(this.driftClient.getPerpMarketAccount(marketIndex), baseAssetAmount, 'Initial', maxMarginRatio, enterHighLeverageMode || this.isHighLeverageMode('Initial'));
        return freeCollateral.mul(numericConstants_1.MARGIN_PRECISION).div(new anchor_1.BN(marginRatio));
    }
    /**
     * calculates Free Collateral = Total collateral - margin requirement
     * @returns : Precision QUOTE_PRECISION
     */
    getFreeCollateral(marginCategory = 'Initial', enterHighLeverageMode = false, perpMarketIndex) {
        const calc = this.getMarginCalculation(marginCategory, {
            enteringHighLeverage: enterHighLeverageMode,
            strict: marginCategory === 'Initial',
        });
        if (perpMarketIndex !== undefined) {
            // getIsolatedFreeCollateral will throw if no existing isolated position but we are fetching for potential new position, so we wrap in a try/catch
            try {
                return calc.getIsolatedFreeCollateral(perpMarketIndex);
            }
            catch (error) {
                return numericConstants_1.ZERO;
            }
        }
        else {
            return calc.getCrossFreeCollateral();
        }
    }
    getMarginRequirement(marginCategory, liquidationBuffer, strict, includeOpenOrders, enteringHighLeverage, perpMarketIndex) {
        const liquidationBufferMap = new Map();
        if (liquidationBuffer && perpMarketIndex !== undefined) {
            liquidationBufferMap.set(perpMarketIndex, liquidationBuffer);
        }
        else if (liquidationBuffer) {
            liquidationBufferMap.set('cross', liquidationBuffer);
        }
        const marginCalc = this.getMarginCalculation(marginCategory, {
            strict,
            includeOpenOrders,
            enteringHighLeverage,
            liquidationBufferMap,
        });
        // If perpMarketIndex is provided, compute only for that market index
        if (perpMarketIndex !== undefined) {
            const isolatedMarginCalculation = marginCalc.isolatedMarginCalculations.get(perpMarketIndex);
            if (!isolatedMarginCalculation)
                return numericConstants_1.ZERO;
            const { marginRequirement, marginRequirementPlusBuffer } = isolatedMarginCalculation;
            if (liquidationBuffer === null || liquidationBuffer === void 0 ? void 0 : liquidationBuffer.gt(numericConstants_1.ZERO)) {
                return marginRequirementPlusBuffer;
            }
            return marginRequirement;
        }
        // Default: Cross margin requirement
        if (liquidationBuffer === null || liquidationBuffer === void 0 ? void 0 : liquidationBuffer.gt(numericConstants_1.ZERO)) {
            return marginCalc.marginRequirementPlusBuffer;
        }
        return marginCalc.marginRequirement;
    }
    /**
     * @returns The initial margin requirement in USDC. : QUOTE_PRECISION
     */
    getInitialMarginRequirement(enterHighLeverageMode = false, perpMarketIndex) {
        return this.getMarginRequirement('Initial', undefined, true, undefined, enterHighLeverageMode, perpMarketIndex);
    }
    /**
     * @returns The maintenance margin requirement in USDC. : QUOTE_PRECISION
     */
    getMaintenanceMarginRequirement(liquidationBuffer, perpMarketIndex) {
        return this.getMarginRequirement('Maintenance', liquidationBuffer, false, // strict default
        true, // includeOpenOrders default
        false, // enteringHighLeverage default
        perpMarketIndex);
    }
    getActivePerpPositionsForUserAccount(userAccount) {
        return userAccount.perpPositions.filter((pos) => {
            var _a;
            return !pos.baseAssetAmount.eq(numericConstants_1.ZERO) ||
                !pos.quoteAssetAmount.eq(numericConstants_1.ZERO) ||
                !(pos.openOrders == 0) ||
                ((_a = pos.isolatedPositionScaledBalance) === null || _a === void 0 ? void 0 : _a.gt(numericConstants_1.ZERO));
        });
    }
    getActivePerpPositions() {
        const userAccount = this.getUserAccount();
        return this.getActivePerpPositionsForUserAccount(userAccount);
    }
    getActivePerpPositionsAndSlot() {
        const userAccount = this.getUserAccountAndSlot();
        const positions = this.getActivePerpPositionsForUserAccount(userAccount.data);
        return {
            data: positions,
            slot: userAccount.slot,
        };
    }
    getActiveSpotPositionsForUserAccount(userAccount) {
        return userAccount.spotPositions.filter((pos) => !(0, spotPosition_1.isSpotPositionAvailable)(pos));
    }
    getActiveSpotPositions() {
        const userAccount = this.getUserAccount();
        return this.getActiveSpotPositionsForUserAccount(userAccount);
    }
    getActiveSpotPositionsAndSlot() {
        const userAccount = this.getUserAccountAndSlot();
        const positions = this.getActiveSpotPositionsForUserAccount(userAccount.data);
        return {
            data: positions,
            slot: userAccount.slot,
        };
    }
    /**
     * calculates unrealized position price pnl
     * @returns : Precision QUOTE_PRECISION
     */
    getUnrealizedPNL(withFunding, marketIndex, withWeightMarginCategory, strict = false, liquidationBuffer) {
        return this.getActivePerpPositions()
            .filter((pos) => marketIndex !== undefined ? pos.marketIndex === marketIndex : true)
            .reduce((unrealizedPnl, perpPosition) => {
            const market = this.driftClient.getPerpMarketAccount(perpPosition.marketIndex);
            const oraclePriceData = this.getMMOracleDataForPerpMarket(market.marketIndex);
            const quoteSpotMarket = this.driftClient.getSpotMarketAccount(market.quoteSpotMarketIndex);
            const quoteOraclePriceData = this.getOracleDataForSpotMarket(market.quoteSpotMarketIndex);
            let positionUnrealizedPnl = (0, position_2.calculatePositionPNL)(market, perpPosition, withFunding, oraclePriceData);
            let quotePrice;
            if (strict && positionUnrealizedPnl.gt(numericConstants_1.ZERO)) {
                quotePrice = anchor_1.BN.min(quoteOraclePriceData.price, quoteSpotMarket.historicalOracleData.lastOraclePriceTwap5Min);
            }
            else if (strict && positionUnrealizedPnl.lt(numericConstants_1.ZERO)) {
                quotePrice = anchor_1.BN.max(quoteOraclePriceData.price, quoteSpotMarket.historicalOracleData.lastOraclePriceTwap5Min);
            }
            else {
                quotePrice = quoteOraclePriceData.price;
            }
            positionUnrealizedPnl = positionUnrealizedPnl
                .mul(quotePrice)
                .div(numericConstants_1.PRICE_PRECISION);
            if (withWeightMarginCategory !== undefined) {
                if (positionUnrealizedPnl.gt(numericConstants_1.ZERO)) {
                    positionUnrealizedPnl = positionUnrealizedPnl
                        .mul((0, market_1.calculateUnrealizedAssetWeight)(market, quoteSpotMarket, positionUnrealizedPnl, withWeightMarginCategory, oraclePriceData))
                        .div(new anchor_1.BN(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION));
                }
                if (liquidationBuffer && positionUnrealizedPnl.lt(numericConstants_1.ZERO)) {
                    positionUnrealizedPnl = positionUnrealizedPnl.add(positionUnrealizedPnl.mul(liquidationBuffer).div(numericConstants_1.MARGIN_PRECISION));
                }
            }
            return unrealizedPnl.add(positionUnrealizedPnl);
        }, numericConstants_1.ZERO);
    }
    /**
     * calculates unrealized funding payment pnl
     * @returns : Precision QUOTE_PRECISION
     */
    getUnrealizedFundingPNL(marketIndex) {
        return this.getUserAccount()
            .perpPositions.filter((pos) => marketIndex !== undefined ? pos.marketIndex === marketIndex : true)
            .reduce((pnl, perpPosition) => {
            const market = this.driftClient.getPerpMarketAccount(perpPosition.marketIndex);
            return pnl.add((0, position_1.calculateUnsettledFundingPnl)(market, perpPosition));
        }, numericConstants_1.ZERO);
    }
    getFuelBonus(now, includeSettled = true, includeUnsettled = true, givenUserStats) {
        const userAccount = this.getUserAccount();
        const result = {
            insuranceFuel: numericConstants_1.ZERO,
            takerFuel: numericConstants_1.ZERO,
            makerFuel: numericConstants_1.ZERO,
            depositFuel: numericConstants_1.ZERO,
            borrowFuel: numericConstants_1.ZERO,
            positionFuel: numericConstants_1.ZERO,
        };
        const userStats = givenUserStats !== null && givenUserStats !== void 0 ? givenUserStats : this.driftClient.getUserStats();
        const userStatsAccount = userStats.getAccount();
        if (includeSettled) {
            result.takerFuel = result.takerFuel.add(new anchor_1.BN(userStatsAccount.fuelTaker));
            result.makerFuel = result.makerFuel.add(new anchor_1.BN(userStatsAccount.fuelMaker));
            result.depositFuel = result.depositFuel.add(new anchor_1.BN(userStatsAccount.fuelDeposits));
            result.borrowFuel = result.borrowFuel.add(new anchor_1.BN(userStatsAccount.fuelBorrows));
            result.positionFuel = result.positionFuel.add(new anchor_1.BN(userStatsAccount.fuelPositions));
        }
        if (includeUnsettled) {
            const fuelBonusNumerator = anchor_1.BN.max(now.sub(anchor_1.BN.max(new anchor_1.BN(userAccount.lastFuelBonusUpdateTs), numericConstants_1.FUEL_START_TS)), numericConstants_1.ZERO);
            if (fuelBonusNumerator.gt(numericConstants_1.ZERO)) {
                for (const spotPosition of this.getActiveSpotPositions()) {
                    const spotMarketAccount = this.driftClient.getSpotMarketAccount(spotPosition.marketIndex);
                    const tokenAmount = this.getTokenAmount(spotPosition.marketIndex);
                    const oraclePriceData = this.getOracleDataForSpotMarket(spotPosition.marketIndex);
                    const twap5min = (0, oracles_1.calculateLiveOracleTwap)(spotMarketAccount.historicalOracleData, oraclePriceData, now, numericConstants_1.FIVE_MINUTE // 5MIN
                    );
                    const strictOraclePrice = new strictOraclePrice_1.StrictOraclePrice(oraclePriceData.price, twap5min);
                    const signedTokenValue = (0, spotBalance_1.getStrictTokenValue)(tokenAmount, spotMarketAccount.decimals, strictOraclePrice);
                    if (signedTokenValue.gt(numericConstants_1.ZERO)) {
                        result.depositFuel = result.depositFuel.add((0, fuel_1.calculateSpotFuelBonus)(spotMarketAccount, signedTokenValue, fuelBonusNumerator));
                    }
                    else {
                        result.borrowFuel = result.borrowFuel.add((0, fuel_1.calculateSpotFuelBonus)(spotMarketAccount, signedTokenValue, fuelBonusNumerator));
                    }
                }
                for (const perpPosition of this.getActivePerpPositions()) {
                    const oraclePriceData = this.getMMOracleDataForPerpMarket(perpPosition.marketIndex);
                    const perpMarketAccount = this.driftClient.getPerpMarketAccount(perpPosition.marketIndex);
                    const baseAssetValue = this.getPerpPositionValue(perpPosition.marketIndex, oraclePriceData, false);
                    result.positionFuel = result.positionFuel.add((0, fuel_1.calculatePerpFuelBonus)(perpMarketAccount, baseAssetValue, fuelBonusNumerator));
                }
            }
        }
        result.insuranceFuel = userStats.getInsuranceFuelBonus(now, includeSettled, includeUnsettled);
        return result;
    }
    getSpotMarketAssetAndLiabilityValue(marketIndex, marginCategory, liquidationBuffer, includeOpenOrders, strict = false, now) {
        now = now || new anchor_1.BN(new Date().getTime() / 1000);
        let netQuoteValue = numericConstants_1.ZERO;
        let totalAssetValue = numericConstants_1.ZERO;
        let totalLiabilityValue = numericConstants_1.ZERO;
        for (const spotPosition of this.getUserAccount().spotPositions) {
            const countForBase = marketIndex === undefined || spotPosition.marketIndex === marketIndex;
            const countForQuote = marketIndex === undefined ||
                marketIndex === numericConstants_1.QUOTE_SPOT_MARKET_INDEX ||
                (includeOpenOrders && spotPosition.openOrders !== 0);
            if ((0, spotPosition_1.isSpotPositionAvailable)(spotPosition) ||
                (!countForBase && !countForQuote)) {
                continue;
            }
            const spotMarketAccount = this.driftClient.getSpotMarketAccount(spotPosition.marketIndex);
            const oraclePriceData = this.getOracleDataForSpotMarket(spotPosition.marketIndex);
            let twap5min;
            if (strict) {
                twap5min = (0, oracles_1.calculateLiveOracleTwap)(spotMarketAccount.historicalOracleData, oraclePriceData, now, numericConstants_1.FIVE_MINUTE // 5MIN
                );
            }
            const strictOraclePrice = new strictOraclePrice_1.StrictOraclePrice(oraclePriceData.price, twap5min);
            if (spotPosition.marketIndex === numericConstants_1.QUOTE_SPOT_MARKET_INDEX &&
                countForQuote) {
                const tokenAmount = (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_2.getTokenAmount)(spotPosition.scaledBalance, spotMarketAccount, spotPosition.balanceType), spotPosition.balanceType);
                if ((0, types_1.isVariant)(spotPosition.balanceType, 'borrow')) {
                    const weightedTokenValue = this.getSpotLiabilityValue(tokenAmount, strictOraclePrice, spotMarketAccount, marginCategory, liquidationBuffer).abs();
                    netQuoteValue = netQuoteValue.sub(weightedTokenValue);
                }
                else {
                    const weightedTokenValue = this.getSpotAssetValue(tokenAmount, strictOraclePrice, spotMarketAccount, marginCategory);
                    netQuoteValue = netQuoteValue.add(weightedTokenValue);
                }
                continue;
            }
            if (!includeOpenOrders && countForBase) {
                if ((0, types_1.isVariant)(spotPosition.balanceType, 'borrow')) {
                    const tokenAmount = (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_2.getTokenAmount)(spotPosition.scaledBalance, spotMarketAccount, spotPosition.balanceType), types_2.SpotBalanceType.BORROW);
                    const liabilityValue = this.getSpotLiabilityValue(tokenAmount, strictOraclePrice, spotMarketAccount, marginCategory, liquidationBuffer).abs();
                    totalLiabilityValue = totalLiabilityValue.add(liabilityValue);
                    continue;
                }
                else {
                    const tokenAmount = (0, spotBalance_2.getTokenAmount)(spotPosition.scaledBalance, spotMarketAccount, spotPosition.balanceType);
                    const assetValue = this.getSpotAssetValue(tokenAmount, strictOraclePrice, spotMarketAccount, marginCategory);
                    totalAssetValue = totalAssetValue.add(assetValue);
                    continue;
                }
            }
            const { tokenAmount: worstCaseTokenAmount, ordersValue: worstCaseQuoteTokenAmount, } = (0, spotPosition_1.getWorstCaseTokenAmounts)(spotPosition, spotMarketAccount, strictOraclePrice, marginCategory, this.getUserAccount().maxMarginRatio);
            if (worstCaseTokenAmount.gt(numericConstants_1.ZERO) && countForBase) {
                const baseAssetValue = this.getSpotAssetValue(worstCaseTokenAmount, strictOraclePrice, spotMarketAccount, marginCategory);
                totalAssetValue = totalAssetValue.add(baseAssetValue);
            }
            if (worstCaseTokenAmount.lt(numericConstants_1.ZERO) && countForBase) {
                const baseLiabilityValue = this.getSpotLiabilityValue(worstCaseTokenAmount, strictOraclePrice, spotMarketAccount, marginCategory, liquidationBuffer).abs();
                totalLiabilityValue = totalLiabilityValue.add(baseLiabilityValue);
            }
            if (worstCaseQuoteTokenAmount.gt(numericConstants_1.ZERO) && countForQuote) {
                netQuoteValue = netQuoteValue.add(worstCaseQuoteTokenAmount);
            }
            if (worstCaseQuoteTokenAmount.lt(numericConstants_1.ZERO) && countForQuote) {
                let weight = numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION;
                if (marginCategory === 'Initial') {
                    weight = anchor_1.BN.max(weight, new anchor_1.BN(this.getUserAccount().maxMarginRatio));
                }
                const weightedTokenValue = worstCaseQuoteTokenAmount
                    .abs()
                    .mul(weight)
                    .div(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION);
                netQuoteValue = netQuoteValue.sub(weightedTokenValue);
            }
            totalLiabilityValue = totalLiabilityValue.add(new anchor_1.BN(spotPosition.openOrders).mul(numericConstants_1.OPEN_ORDER_MARGIN_REQUIREMENT));
        }
        if (marketIndex === undefined || marketIndex === numericConstants_1.QUOTE_SPOT_MARKET_INDEX) {
            if (netQuoteValue.gt(numericConstants_1.ZERO)) {
                totalAssetValue = totalAssetValue.add(netQuoteValue);
            }
            else {
                totalLiabilityValue = totalLiabilityValue.add(netQuoteValue.abs());
            }
        }
        return { totalAssetValue, totalLiabilityValue };
    }
    getSpotMarketLiabilityValue(marketIndex, marginCategory, liquidationBuffer, includeOpenOrders, strict = false, now) {
        const { totalLiabilityValue } = this.getSpotMarketAssetAndLiabilityValue(marketIndex, marginCategory, liquidationBuffer, includeOpenOrders, strict, now);
        return totalLiabilityValue;
    }
    getSpotLiabilityValue(tokenAmount, strictOraclePrice, spotMarketAccount, marginCategory, liquidationBuffer) {
        return (0, spotBalance_2.getSpotLiabilityValue)(tokenAmount, strictOraclePrice, spotMarketAccount, this.getUserAccount().maxMarginRatio, marginCategory, liquidationBuffer);
    }
    getSpotMarketAssetValue(marketIndex, marginCategory, includeOpenOrders, strict = false, now) {
        const { totalAssetValue } = this.getSpotMarketAssetAndLiabilityValue(marketIndex, marginCategory, undefined, includeOpenOrders, strict, now);
        return totalAssetValue;
    }
    getSpotAssetValue(tokenAmount, strictOraclePrice, spotMarketAccount, marginCategory) {
        return (0, spotBalance_2.getSpotAssetValue)(tokenAmount, strictOraclePrice, spotMarketAccount, this.getUserAccount().maxMarginRatio, marginCategory);
    }
    getSpotPositionValue(marketIndex, marginCategory, includeOpenOrders, strict = false, now) {
        const { totalAssetValue, totalLiabilityValue } = this.getSpotMarketAssetAndLiabilityValue(marketIndex, marginCategory, undefined, includeOpenOrders, strict, now);
        return totalAssetValue.sub(totalLiabilityValue);
    }
    getNetSpotMarketValue(withWeightMarginCategory) {
        const { totalAssetValue, totalLiabilityValue } = this.getSpotMarketAssetAndLiabilityValue(undefined, withWeightMarginCategory);
        return totalAssetValue.sub(totalLiabilityValue);
    }
    /**
     * calculates TotalCollateral: collateral + unrealized pnl
     * @returns : Precision QUOTE_PRECISION
     */
    getTotalCollateral(marginCategory = 'Initial', strict = false, includeOpenOrders = true, liquidationBuffer, perpMarketIndex) {
        const liquidationBufferMap = (() => {
            if (liquidationBuffer && perpMarketIndex !== undefined) {
                return new Map([[perpMarketIndex, liquidationBuffer]]);
            }
            else if (liquidationBuffer) {
                return new Map([['cross', liquidationBuffer]]);
            }
            return new Map();
        })();
        const marginCalc = this.getMarginCalculation(marginCategory, {
            strict,
            includeOpenOrders,
            liquidationBufferMap,
        });
        if (perpMarketIndex !== undefined) {
            const { totalCollateral, totalCollateralBuffer } = marginCalc.isolatedMarginCalculations.get(perpMarketIndex);
            if (liquidationBuffer === null || liquidationBuffer === void 0 ? void 0 : liquidationBuffer.gt(numericConstants_1.ZERO)) {
                return totalCollateralBuffer;
            }
            return totalCollateral;
        }
        if (liquidationBuffer === null || liquidationBuffer === void 0 ? void 0 : liquidationBuffer.gt(numericConstants_1.ZERO)) {
            return marginCalc.totalCollateralBuffer;
        }
        return marginCalc.totalCollateral;
    }
    getLiquidationBuffer() {
        const liquidationBufferMap = new Map();
        if (this.isBeingLiquidated()) {
            liquidationBufferMap.set('cross', new anchor_1.BN(this.driftClient.getStateAccount().liquidationMarginBufferRatio));
        }
        for (const position of this.getActivePerpPositions()) {
            if (position.positionFlag &
                (types_2.PositionFlag.BeingLiquidated | types_2.PositionFlag.Bankruptcy)) {
                liquidationBufferMap.set(position.marketIndex, new anchor_1.BN(this.driftClient.getStateAccount().liquidationMarginBufferRatio));
            }
        }
        return liquidationBufferMap;
    }
    /**
     * calculates User Health by comparing total collateral and maint. margin requirement
     * @returns : number (value from [0, 100])
     */
    getHealth(perpMarketIndex) {
        if (this.isCrossMarginBeingLiquidated() && !perpMarketIndex) {
            return 0;
        }
        if (perpMarketIndex &&
            this.isIsolatedPositionBeingLiquidated(perpMarketIndex)) {
            return 0;
        }
        const marginCalc = this.getMarginCalculation('Maintenance');
        let totalCollateral;
        let maintenanceMarginReq;
        if (perpMarketIndex) {
            const isolatedMarginCalc = marginCalc.isolatedMarginCalculations.get(perpMarketIndex);
            if (isolatedMarginCalc) {
                totalCollateral = isolatedMarginCalc.totalCollateral;
                maintenanceMarginReq = isolatedMarginCalc.marginRequirement;
            }
        }
        else {
            totalCollateral = marginCalc.totalCollateral;
            maintenanceMarginReq = marginCalc.marginRequirement;
        }
        let health;
        if (maintenanceMarginReq.eq(numericConstants_1.ZERO) && totalCollateral.gte(numericConstants_1.ZERO)) {
            health = 100;
        }
        else if (totalCollateral.lte(numericConstants_1.ZERO)) {
            health = 0;
        }
        else {
            health = Math.round(Math.min(100, Math.max(0, (1 - maintenanceMarginReq.toNumber() / totalCollateral.toNumber()) *
                100)));
        }
        return health;
    }
    calculateWeightedPerpPositionLiability(perpPosition, marginCategory, liquidationBuffer, includeOpenOrders, strict = false, enteringHighLeverage = undefined) {
        const market = this.driftClient.getPerpMarketAccount(perpPosition.marketIndex);
        let valuationPrice = this.getOracleDataForPerpMarket(market.marketIndex).price;
        if ((0, types_1.isVariant)(market.status, 'settlement')) {
            valuationPrice = market.expiryPrice;
        }
        let baseAssetAmount;
        let liabilityValue;
        if (includeOpenOrders) {
            const { worstCaseBaseAssetAmount, worstCaseLiabilityValue } = (0, margin_1.calculateWorstCasePerpLiabilityValue)(perpPosition, market, valuationPrice);
            baseAssetAmount = worstCaseBaseAssetAmount;
            liabilityValue = worstCaseLiabilityValue;
        }
        else {
            baseAssetAmount = perpPosition.baseAssetAmount;
            liabilityValue = (0, margin_1.calculatePerpLiabilityValue)(baseAssetAmount, valuationPrice, (0, types_1.isVariant)(market.contractType, 'prediction'));
        }
        if (marginCategory) {
            const userCustomMargin = Math.max(perpPosition.maxMarginRatio, this.getUserAccount().maxMarginRatio);
            let marginRatio = new anchor_1.BN((0, market_1.calculateMarketMarginRatio)(market, baseAssetAmount.abs(), marginCategory, enteringHighLeverage === false
                ? Math.max(market.marginRatioInitial, userCustomMargin)
                : userCustomMargin, this.isHighLeverageMode(marginCategory) ||
                enteringHighLeverage === true));
            if (liquidationBuffer !== undefined) {
                marginRatio = marginRatio.add(liquidationBuffer);
            }
            if ((0, types_1.isVariant)(market.status, 'settlement')) {
                marginRatio = numericConstants_1.ZERO;
            }
            const quoteSpotMarket = this.driftClient.getSpotMarketAccount(market.quoteSpotMarketIndex);
            const quoteOraclePriceData = this.driftClient.getOracleDataForSpotMarket(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
            let quotePrice;
            if (strict) {
                quotePrice = anchor_1.BN.max(quoteOraclePriceData.price, quoteSpotMarket.historicalOracleData.lastOraclePriceTwap5Min);
            }
            else {
                quotePrice = quoteOraclePriceData.price;
            }
            liabilityValue = liabilityValue
                .mul(quotePrice)
                .div(numericConstants_1.PRICE_PRECISION)
                .mul(marginRatio)
                .div(numericConstants_1.MARGIN_PRECISION);
            if (includeOpenOrders) {
                liabilityValue = liabilityValue.add(new anchor_1.BN(perpPosition.openOrders).mul(numericConstants_1.OPEN_ORDER_MARGIN_REQUIREMENT));
            }
        }
        return liabilityValue;
    }
    /**
     * calculates position value of a single perp market in margin system
     * @returns : Precision QUOTE_PRECISION
     */
    getPerpMarketLiabilityValue(marketIndex, marginCategory, liquidationBuffer, includeOpenOrders, strict = false) {
        const perpPosition = this.getPerpPosition(marketIndex);
        return this.calculateWeightedPerpPositionLiability(perpPosition, marginCategory, liquidationBuffer, includeOpenOrders, strict);
    }
    /**
     * calculates sum of position value across all positions in margin system
     * @returns : Precision QUOTE_PRECISION
     */
    getTotalPerpPositionLiability(marginCategory, liquidationBuffer, includeOpenOrders, strict = false, enteringHighLeverage = undefined) {
        return this.getActivePerpPositions().reduce((totalPerpValue, perpPosition) => {
            const baseAssetValue = this.calculateWeightedPerpPositionLiability(perpPosition, marginCategory, liquidationBuffer, includeOpenOrders, strict, enteringHighLeverage);
            return totalPerpValue.add(baseAssetValue);
        }, numericConstants_1.ZERO);
    }
    /**
     * calculates position value based on oracle
     * @returns : Precision QUOTE_PRECISION
     */
    getPerpPositionValue(marketIndex, oraclePriceData, includeOpenOrders = false) {
        const userPosition = this.getPerpPositionOrEmpty(marketIndex);
        const market = this.driftClient.getPerpMarketAccount(userPosition.marketIndex);
        return (0, margin_2.calculateBaseAssetValueWithOracle)(market, userPosition, oraclePriceData, includeOpenOrders);
    }
    /**
     * calculates position liabiltiy value in margin system
     * @returns : Precision QUOTE_PRECISION
     */
    getPerpLiabilityValue(marketIndex, oraclePriceData, includeOpenOrders = false) {
        const userPosition = this.getPerpPositionOrEmpty(marketIndex);
        const market = this.driftClient.getPerpMarketAccount(userPosition.marketIndex);
        if (includeOpenOrders) {
            return (0, margin_1.calculateWorstCasePerpLiabilityValue)(userPosition, market, oraclePriceData.price).worstCaseLiabilityValue;
        }
        else {
            return (0, margin_1.calculatePerpLiabilityValue)(userPosition.baseAssetAmount, oraclePriceData.price, (0, types_1.isVariant)(market.contractType, 'prediction'));
        }
    }
    getPositionSide(currentPosition) {
        if (currentPosition.baseAssetAmount.gt(numericConstants_1.ZERO)) {
            return types_2.PositionDirection.LONG;
        }
        else if (currentPosition.baseAssetAmount.lt(numericConstants_1.ZERO)) {
            return types_2.PositionDirection.SHORT;
        }
        else {
            return undefined;
        }
    }
    /**
     * calculates average exit price (optionally for closing up to 100% of position)
     * @returns : Precision PRICE_PRECISION
     */
    getPositionEstimatedExitPriceAndPnl(position, amountToClose, useAMMClose = false) {
        const market = this.driftClient.getPerpMarketAccount(position.marketIndex);
        const entryPrice = (0, position_1.calculateEntryPrice)(position);
        const oraclePriceData = this.getMMOracleDataForPerpMarket(position.marketIndex);
        if (amountToClose) {
            if (amountToClose.eq(numericConstants_1.ZERO)) {
                return [(0, market_1.calculateReservePrice)(market, oraclePriceData), numericConstants_1.ZERO];
            }
            position = {
                baseAssetAmount: amountToClose,
                lastCumulativeFundingRate: position.lastCumulativeFundingRate,
                marketIndex: position.marketIndex,
                quoteAssetAmount: position.quoteAssetAmount,
            };
        }
        let baseAssetValue;
        if (useAMMClose) {
            baseAssetValue = (0, position_2.calculateBaseAssetValue)(market, position, oraclePriceData);
        }
        else {
            baseAssetValue = (0, margin_2.calculateBaseAssetValueWithOracle)(market, position, oraclePriceData);
        }
        if (position.baseAssetAmount.eq(numericConstants_1.ZERO)) {
            return [numericConstants_1.ZERO, numericConstants_1.ZERO];
        }
        const exitPrice = baseAssetValue
            .mul(numericConstants_1.AMM_TO_QUOTE_PRECISION_RATIO)
            .mul(numericConstants_1.PRICE_PRECISION)
            .div(position.baseAssetAmount.abs());
        const pnlPerBase = exitPrice.sub(entryPrice);
        const pnl = pnlPerBase
            .mul(position.baseAssetAmount)
            .div(numericConstants_1.PRICE_PRECISION)
            .div(numericConstants_1.AMM_TO_QUOTE_PRECISION_RATIO);
        return [exitPrice, pnl];
    }
    /**
     * calculates current user leverage which is (total liability size) / (net asset value)
     * @returns : Precision TEN_THOUSAND
     */
    getLeverage(includeOpenOrders = true, perpMarketIndex) {
        return this.calculateLeverageFromComponents(this.getLeverageComponents(includeOpenOrders, undefined, perpMarketIndex));
    }
    calculateLeverageFromComponents({ perpLiabilityValue, perpPnl, spotAssetValue, spotLiabilityValue, }) {
        const totalLiabilityValue = perpLiabilityValue.add(spotLiabilityValue);
        const totalAssetValue = spotAssetValue.add(perpPnl);
        const netAssetValue = totalAssetValue.sub(spotLiabilityValue);
        if (netAssetValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.ZERO;
        }
        return totalLiabilityValue.mul(numericConstants_1.TEN_THOUSAND).div(netAssetValue);
    }
    getLeverageComponents(includeOpenOrders = true, marginCategory = undefined, perpMarketIndex) {
        var _a;
        if (perpMarketIndex) {
            const perpPosition = this.getPerpPositionOrEmpty(perpMarketIndex);
            const perpLiability = this.calculateWeightedPerpPositionLiability(perpPosition, marginCategory, undefined, includeOpenOrders);
            const perpMarket = this.driftClient.getPerpMarketAccount(perpPosition.marketIndex);
            const oraclePriceData = this.getOracleDataForPerpMarket(perpPosition.marketIndex);
            const quoteSpotMarket = this.driftClient.getSpotMarketAccount(perpMarket.quoteSpotMarketIndex);
            const quoteOraclePriceData = this.getOracleDataForSpotMarket(perpMarket.quoteSpotMarketIndex);
            const strictOracle = new strictOraclePrice_1.StrictOraclePrice(quoteOraclePriceData.price, quoteOraclePriceData.twap);
            const positionUnrealizedPnl = (0, position_2.calculatePositionPNL)(perpMarket, perpPosition, true, oraclePriceData);
            const tokenAmount = (0, spotBalance_2.getTokenAmount)((_a = perpPosition.isolatedPositionScaledBalance) !== null && _a !== void 0 ? _a : numericConstants_1.ZERO, quoteSpotMarket, types_2.SpotBalanceType.DEPOSIT);
            const spotAssetValue = (0, spotBalance_1.getStrictTokenValue)(tokenAmount, quoteSpotMarket.decimals, strictOracle);
            return {
                perpLiabilityValue: perpLiability,
                perpPnl: positionUnrealizedPnl,
                spotAssetValue,
                spotLiabilityValue: numericConstants_1.ZERO,
            };
        }
        const perpLiability = this.getTotalPerpPositionLiability(marginCategory, undefined, includeOpenOrders);
        const perpPnl = this.getUnrealizedPNL(true, undefined, marginCategory);
        const { totalAssetValue: spotAssetValue, totalLiabilityValue: spotLiabilityValue, } = this.getSpotMarketAssetAndLiabilityValue(undefined, marginCategory, undefined, includeOpenOrders);
        return {
            perpLiabilityValue: perpLiability,
            perpPnl,
            spotAssetValue,
            spotLiabilityValue,
        };
    }
    isDustDepositPosition(spotMarketAccount) {
        const marketIndex = spotMarketAccount.marketIndex;
        const spotPosition = this.getSpotPosition(spotMarketAccount.marketIndex);
        if ((0, spotPosition_1.isSpotPositionAvailable)(spotPosition)) {
            return false;
        }
        const depositAmount = this.getTokenAmount(spotMarketAccount.marketIndex);
        if (depositAmount.lte(numericConstants_1.ZERO)) {
            return false;
        }
        const oraclePriceData = this.getOracleDataForSpotMarket(marketIndex);
        const strictOraclePrice = new strictOraclePrice_1.StrictOraclePrice(oraclePriceData.price, oraclePriceData.twap);
        const balanceValue = this.getSpotAssetValue(depositAmount, strictOraclePrice, spotMarketAccount);
        if (balanceValue.lt(numericConstants_1.DUST_POSITION_SIZE)) {
            return true;
        }
        return false;
    }
    getSpotMarketAccountsWithDustPosition() {
        const spotMarketAccounts = this.driftClient.getSpotMarketAccounts();
        const dustPositionAccounts = [];
        for (const spotMarketAccount of spotMarketAccounts) {
            const isDust = this.isDustDepositPosition(spotMarketAccount);
            if (isDust) {
                dustPositionAccounts.push(spotMarketAccount);
            }
        }
        return dustPositionAccounts;
    }
    getTotalLiabilityValue(marginCategory) {
        return this.getTotalPerpPositionLiability(marginCategory, undefined, true).add(this.getSpotMarketLiabilityValue(undefined, marginCategory, undefined, true));
    }
    getTotalAssetValue(marginCategory) {
        return this.getSpotMarketAssetValue(undefined, marginCategory, true).add(this.getUnrealizedPNL(true, undefined, marginCategory));
    }
    getNetUsdValue() {
        const netSpotValue = this.getNetSpotMarketValue();
        const unrealizedPnl = this.getUnrealizedPNL(true, undefined, undefined);
        return netSpotValue.add(unrealizedPnl);
    }
    /**
     * Calculates the all time P&L of the user.
     *
     * Net withdraws + Net spot market value + Net unrealized P&L -
     */
    getTotalAllTimePnl() {
        const netUsdValue = this.getNetUsdValue();
        const totalDeposits = this.getUserAccount().totalDeposits;
        const totalWithdraws = this.getUserAccount().totalWithdraws;
        const totalPnl = netUsdValue.add(totalWithdraws).sub(totalDeposits);
        return totalPnl;
    }
    /**
     * calculates max allowable leverage exceeding hitting requirement category
     * for large sizes where imf factor activates, result is a lower bound
     * @param marginCategory {Initial, Maintenance}
     * @param isLp if calculating max leveraging for adding lp, need to add buffer
     * @param enterHighLeverageMode can pass this as true to calculate max leverage if the user was to enter high leverage mode
     * @returns : Precision TEN_THOUSAND
     */
    getMaxLeverageForPerp(perpMarketIndex, _marginCategory = 'Initial', isLp = false, enterHighLeverageMode = undefined) {
        const market = this.driftClient.getPerpMarketAccount(perpMarketIndex);
        const marketPrice = this.driftClient.getOracleDataForPerpMarket(perpMarketIndex).price;
        const { perpLiabilityValue, perpPnl, spotAssetValue, spotLiabilityValue } = this.getLeverageComponents();
        const totalAssetValue = spotAssetValue.add(perpPnl);
        const netAssetValue = totalAssetValue.sub(spotLiabilityValue);
        if (netAssetValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.ZERO;
        }
        const totalLiabilityValue = perpLiabilityValue.add(spotLiabilityValue);
        const lpBuffer = isLp
            ? marketPrice.mul(market.amm.orderStepSize).div(numericConstants_1.AMM_RESERVE_PRECISION)
            : numericConstants_1.ZERO;
        // absolute max fesible size (upper bound)
        const maxSizeQuote = anchor_1.BN.max(anchor_1.BN.min(this.getMaxTradeSizeUSDCForPerp(perpMarketIndex, types_2.PositionDirection.LONG, false, enterHighLeverageMode || this.isHighLeverageMode('Initial')).tradeSize, this.getMaxTradeSizeUSDCForPerp(perpMarketIndex, types_2.PositionDirection.SHORT, false, enterHighLeverageMode || this.isHighLeverageMode('Initial')).tradeSize).sub(lpBuffer), numericConstants_1.ZERO);
        return totalLiabilityValue
            .add(maxSizeQuote)
            .mul(numericConstants_1.TEN_THOUSAND)
            .div(netAssetValue);
    }
    /**
     * calculates max allowable leverage exceeding hitting requirement category
     * @param spotMarketIndex
     * @param direction
     * @returns : Precision TEN_THOUSAND
     */
    getMaxLeverageForSpot(spotMarketIndex, direction) {
        const { perpLiabilityValue, perpPnl, spotAssetValue, spotLiabilityValue } = this.getLeverageComponents();
        const totalLiabilityValue = perpLiabilityValue.add(spotLiabilityValue);
        const totalAssetValue = spotAssetValue.add(perpPnl);
        const netAssetValue = totalAssetValue.sub(spotLiabilityValue);
        if (netAssetValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.ZERO;
        }
        const currentQuoteAssetValue = this.getSpotMarketAssetValue(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const currentQuoteLiabilityValue = this.getSpotMarketLiabilityValue(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        const currentQuoteValue = currentQuoteAssetValue.sub(currentQuoteLiabilityValue);
        const currentSpotMarketAssetValue = this.getSpotMarketAssetValue(spotMarketIndex);
        const currentSpotMarketLiabilityValue = this.getSpotMarketLiabilityValue(spotMarketIndex);
        const currentSpotMarketNetValue = currentSpotMarketAssetValue.sub(currentSpotMarketLiabilityValue);
        const tradeQuoteAmount = this.getMaxTradeSizeUSDCForSpot(spotMarketIndex, direction, currentQuoteAssetValue, currentSpotMarketNetValue);
        let assetValueToAdd = numericConstants_1.ZERO;
        let liabilityValueToAdd = numericConstants_1.ZERO;
        const newQuoteNetValue = (0, types_1.isVariant)(direction, 'short')
            ? currentQuoteValue.add(tradeQuoteAmount)
            : currentQuoteValue.sub(tradeQuoteAmount);
        const newQuoteAssetValue = anchor_1.BN.max(newQuoteNetValue, numericConstants_1.ZERO);
        const newQuoteLiabilityValue = anchor_1.BN.min(newQuoteNetValue, numericConstants_1.ZERO).abs();
        assetValueToAdd = assetValueToAdd.add(newQuoteAssetValue.sub(currentQuoteAssetValue));
        liabilityValueToAdd = liabilityValueToAdd.add(newQuoteLiabilityValue.sub(currentQuoteLiabilityValue));
        const newSpotMarketNetValue = (0, types_1.isVariant)(direction, 'long')
            ? currentSpotMarketNetValue.add(tradeQuoteAmount)
            : currentSpotMarketNetValue.sub(tradeQuoteAmount);
        const newSpotMarketAssetValue = anchor_1.BN.max(newSpotMarketNetValue, numericConstants_1.ZERO);
        const newSpotMarketLiabilityValue = anchor_1.BN.min(newSpotMarketNetValue, numericConstants_1.ZERO).abs();
        assetValueToAdd = assetValueToAdd.add(newSpotMarketAssetValue.sub(currentSpotMarketAssetValue));
        liabilityValueToAdd = liabilityValueToAdd.add(newSpotMarketLiabilityValue.sub(currentSpotMarketLiabilityValue));
        const finalTotalAssetValue = totalAssetValue.add(assetValueToAdd);
        const finalTotalSpotLiability = spotLiabilityValue.add(liabilityValueToAdd);
        const finalTotalLiabilityValue = totalLiabilityValue.add(liabilityValueToAdd);
        const finalNetAssetValue = finalTotalAssetValue.sub(finalTotalSpotLiability);
        return finalTotalLiabilityValue.mul(numericConstants_1.TEN_THOUSAND).div(finalNetAssetValue);
    }
    /**
     * calculates margin ratio: 1 / leverage
     * @returns : Precision TEN_THOUSAND
     */
    getMarginRatio() {
        const { perpLiabilityValue, perpPnl, spotAssetValue, spotLiabilityValue } = this.getLeverageComponents();
        const totalLiabilityValue = perpLiabilityValue.add(spotLiabilityValue);
        const totalAssetValue = spotAssetValue.add(perpPnl);
        if (totalLiabilityValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.BN_MAX;
        }
        const netAssetValue = totalAssetValue.sub(spotLiabilityValue);
        return netAssetValue.mul(numericConstants_1.TEN_THOUSAND).div(totalLiabilityValue);
    }
    canBeLiquidated() {
        // Deprecated signature retained for backward compatibility in type only
        // but implementation now delegates to the new Map-based API and returns cross margin status.
        const map = this.getLiquidationStatuses();
        const cross = map.get('cross');
        const isolatedPositions = new Map(Array.from(map.entries())
            .filter((e) => e[0] !== 'cross')
            .map(([key, value]) => [key, value]));
        return cross
            ? { ...cross, isolatedPositions }
            : {
                canBeLiquidated: false,
                marginRequirement: numericConstants_1.ZERO,
                totalCollateral: numericConstants_1.ZERO,
                isolatedPositions,
            };
    }
    /**
     * New API: Returns liquidation status for cross and each isolated perp position.
     * Map keys:
     *  - 'cross' for cross margin
     *  - marketIndex (number) for each isolated perp position
     */
    getLiquidationStatuses(marginCalc) {
        // If not provided, use buffer-aware calc for canBeLiquidated checks
        if (!marginCalc) {
            const liquidationBufferMap = this.getLiquidationBuffer();
            marginCalc = this.getMarginCalculation('Maintenance', {
                liquidationBufferMap,
            });
        }
        const result = new Map();
        // Cross margin status
        const crossTotalCollateral = marginCalc.totalCollateral;
        const crossMarginRequirement = marginCalc.marginRequirement;
        result.set('cross', {
            canBeLiquidated: crossTotalCollateral.lt(crossMarginRequirement),
            marginRequirement: crossMarginRequirement,
            totalCollateral: crossTotalCollateral,
        });
        // Isolated positions status
        for (const [marketIndex, isoCalc,] of marginCalc.isolatedMarginCalculations) {
            const isoTotalCollateral = isoCalc.totalCollateral;
            const isoMarginRequirement = isoCalc.marginRequirement;
            result.set(marketIndex, {
                canBeLiquidated: isoTotalCollateral.lt(isoMarginRequirement),
                marginRequirement: isoMarginRequirement,
                totalCollateral: isoTotalCollateral,
            });
        }
        return result;
    }
    isBeingLiquidated() {
        return (this.isCrossMarginBeingLiquidated() ||
            this.hasIsolatedPositionBeingLiquidated());
    }
    isCrossMarginBeingLiquidated() {
        return ((this.getUserAccount().status &
            (types_1.UserStatus.BEING_LIQUIDATED | types_1.UserStatus.BANKRUPT)) >
            0);
    }
    /** Returns true if cross margin is currently below maintenance requirement (no buffer). */
    canCrossMarginBeLiquidated(marginCalc) {
        const calc = marginCalc !== null && marginCalc !== void 0 ? marginCalc : this.getMarginCalculation('Maintenance');
        return calc.totalCollateral.lt(calc.marginRequirement);
    }
    hasIsolatedPositionBeingLiquidated() {
        return this.getActivePerpPositions().some((position) => (position.positionFlag &
            (types_2.PositionFlag.BeingLiquidated | types_2.PositionFlag.Bankruptcy)) >
            0);
    }
    isIsolatedPositionBeingLiquidated(perpMarketIndex) {
        const position = this.getActivePerpPositions().find((position) => position.marketIndex === perpMarketIndex);
        return (((position === null || position === void 0 ? void 0 : position.positionFlag) &
            (types_2.PositionFlag.BeingLiquidated | types_2.PositionFlag.Bankruptcy)) >
            0);
    }
    /** Returns true if any isolated perp position is currently below its maintenance requirement (no buffer). */
    getLiquidatableIsolatedPositions(marginCalc) {
        const liquidatableIsolatedPositions = [];
        const calc = marginCalc !== null && marginCalc !== void 0 ? marginCalc : this.getMarginCalculation('Maintenance');
        for (const [marketIndex, isoCalc] of calc.isolatedMarginCalculations) {
            if (this.canIsolatedPositionMarginBeLiquidated(isoCalc)) {
                liquidatableIsolatedPositions.push(marketIndex);
            }
        }
        return liquidatableIsolatedPositions;
    }
    canIsolatedPositionMarginBeLiquidated(isolatedMarginCalculation) {
        return isolatedMarginCalculation.totalCollateral.lt(isolatedMarginCalculation.marginRequirement);
    }
    hasStatus(status) {
        return (this.getUserAccount().status & status) > 0;
    }
    isBankrupt() {
        return (this.getUserAccount().status & types_1.UserStatus.BANKRUPT) > 0;
    }
    isHighLeverageMode(marginCategory) {
        return ((0, types_1.isVariant)(this.getUserAccount().marginMode, 'highLeverage') ||
            (marginCategory === 'Maintenance' &&
                (0, types_1.isVariant)(this.getUserAccount().marginMode, 'highLeverageMaintenance')));
    }
    /**
     * Checks if any user position cumulative funding differs from respective market cumulative funding
     * @returns
     */
    needsToSettleFundingPayment() {
        for (const userPosition of this.getUserAccount().perpPositions) {
            if (userPosition.baseAssetAmount.eq(numericConstants_1.ZERO)) {
                continue;
            }
            const market = this.driftClient.getPerpMarketAccount(userPosition.marketIndex);
            if (market.amm.cumulativeFundingRateLong.eq(userPosition.lastCumulativeFundingRate) ||
                market.amm.cumulativeFundingRateShort.eq(userPosition.lastCumulativeFundingRate)) {
                continue;
            }
            return true;
        }
        return false;
    }
    /**
     * Calculate the liquidation price of a spot position
     * @param marketIndex
     * @returns Precision : PRICE_PRECISION
     */
    spotLiquidationPrice(marketIndex, positionBaseSizeChange = numericConstants_1.ZERO) {
        const currentSpotPosition = this.getSpotPosition(marketIndex);
        if (!currentSpotPosition) {
            return new anchor_1.BN(-1);
        }
        const totalCollateral = this.getTotalCollateral('Maintenance');
        const maintenanceMarginRequirement = this.getMaintenanceMarginRequirement();
        const freeCollateral = anchor_1.BN.max(numericConstants_1.ZERO, totalCollateral.sub(maintenanceMarginRequirement));
        const market = this.driftClient.getSpotMarketAccount(marketIndex);
        let signedTokenAmount = (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_2.getTokenAmount)(currentSpotPosition.scaledBalance, market, currentSpotPosition.balanceType), currentSpotPosition.balanceType);
        signedTokenAmount = signedTokenAmount.add(positionBaseSizeChange);
        if (signedTokenAmount.eq(numericConstants_1.ZERO)) {
            return new anchor_1.BN(-1);
        }
        let freeCollateralDelta = this.calculateFreeCollateralDeltaForSpot(market, signedTokenAmount);
        const oracle = market.oracle;
        const perpMarketWithSameOracle = this.driftClient
            .getPerpMarketAccounts()
            .find((market) => market.amm.oracle.equals(oracle));
        const oraclePrice = this.driftClient.getOracleDataForSpotMarket(marketIndex).price;
        if (perpMarketWithSameOracle) {
            const perpPosition = this.getPerpPositionOrEmpty(perpMarketWithSameOracle.marketIndex);
            if (perpPosition) {
                let freeCollateralDeltaForPerp = this.calculateFreeCollateralDeltaForPerp(perpMarketWithSameOracle, perpPosition, numericConstants_1.ZERO, oraclePrice);
                if (freeCollateralDeltaForPerp) {
                    const { numerator, denominator } = (0, oracles_1.getMultipleBetweenOracleSources)(market.oracleSource, perpMarketWithSameOracle.amm.oracleSource);
                    freeCollateralDeltaForPerp = freeCollateralDeltaForPerp
                        .mul(numerator)
                        .div(denominator);
                }
                freeCollateralDelta = freeCollateralDelta.add(freeCollateralDeltaForPerp || numericConstants_1.ZERO);
            }
        }
        if (freeCollateralDelta.eq(numericConstants_1.ZERO)) {
            return new anchor_1.BN(-1);
        }
        const liqPriceDelta = freeCollateral
            .mul(numericConstants_1.QUOTE_PRECISION)
            .div(freeCollateralDelta);
        const liqPrice = oraclePrice.sub(liqPriceDelta);
        if (liqPrice.lt(numericConstants_1.ZERO)) {
            return new anchor_1.BN(-1);
        }
        return liqPrice;
    }
    /**
     * Calculate the liquidation price of a perp position, with optional parameter to calculate the liquidation price after a trade
     * @param marketIndex
     * @param positionBaseSizeChange // change in position size to calculate liquidation price for : Precision 10^9
     * @param estimatedEntryPrice
     * @param marginCategory // allow Initial to be passed in if we are trying to calculate price for DLP de-risking
     * @param includeOpenOrders
     * @param offsetCollateral // allows calculating the liquidation price after this offset collateral is added to the user's account (e.g. : what will the liquidation price be for this position AFTER I deposit $x worth of collateral)
     * @returns Precision : PRICE_PRECISION
     */
    liquidationPrice(marketIndex, positionBaseSizeChange = numericConstants_1.ZERO, estimatedEntryPrice = numericConstants_1.ZERO, marginCategory = 'Maintenance', includeOpenOrders = false, offsetCollateral = numericConstants_1.ZERO, enteringHighLeverage = false, marginType) {
        const market = this.driftClient.getPerpMarketAccount(marketIndex);
        const oracle = this.driftClient.getPerpMarketAccount(marketIndex).amm.oracle;
        const oraclePrice = this.driftClient.getOracleDataForPerpMarket(marketIndex).price;
        const currentPerpPosition = this.getPerpPositionOrEmpty(marketIndex);
        if (marginType === 'Isolated') {
            const marginCalculation = this.getMarginCalculation(marginCategory, {
                strict: false,
                includeOpenOrders,
                enteringHighLeverage,
            });
            const isolatedMarginCalculation = marginCalculation.isolatedMarginCalculations.get(marketIndex);
            if (!isolatedMarginCalculation)
                return new anchor_1.BN(-1);
            const { totalCollateral, marginRequirement } = isolatedMarginCalculation;
            const freeCollateral = anchor_1.BN.max(numericConstants_1.ZERO, totalCollateral.sub(marginRequirement)).add(offsetCollateral);
            const freeCollateralDelta = this.calculateFreeCollateralDeltaForPerp(market, currentPerpPosition, positionBaseSizeChange, oraclePrice, marginCategory, includeOpenOrders, enteringHighLeverage);
            if (!freeCollateralDelta || freeCollateralDelta.eq(numericConstants_1.ZERO)) {
                return new anchor_1.BN(-1);
            }
            const liqPriceDelta = freeCollateral
                .mul(numericConstants_1.QUOTE_PRECISION)
                .div(freeCollateralDelta);
            const liqPrice = oraclePrice.sub(liqPriceDelta);
            if (liqPrice.lt(numericConstants_1.ZERO)) {
                return new anchor_1.BN(-1);
            }
            return liqPrice;
        }
        const totalCollateral = this.getTotalCollateral(marginCategory, false, includeOpenOrders);
        const marginRequirement = this.getMarginRequirement(marginCategory, undefined, false, includeOpenOrders, enteringHighLeverage);
        let freeCollateral = anchor_1.BN.max(numericConstants_1.ZERO, totalCollateral.sub(marginRequirement)).add(offsetCollateral);
        positionBaseSizeChange = (0, orders_1.standardizeBaseAssetAmount)(positionBaseSizeChange, market.amm.orderStepSize);
        const freeCollateralChangeFromNewPosition = this.calculateEntriesEffectOnFreeCollateral(market, oraclePrice, currentPerpPosition, positionBaseSizeChange, estimatedEntryPrice, includeOpenOrders, enteringHighLeverage);
        freeCollateral = freeCollateral.add(freeCollateralChangeFromNewPosition);
        let freeCollateralDelta = this.calculateFreeCollateralDeltaForPerp(market, currentPerpPosition, positionBaseSizeChange, oraclePrice, marginCategory, includeOpenOrders, enteringHighLeverage);
        if (!freeCollateralDelta) {
            return new anchor_1.BN(-1);
        }
        const spotMarketWithSameOracle = this.driftClient
            .getSpotMarketAccounts()
            .find((market) => market.oracle.equals(oracle));
        if (spotMarketWithSameOracle) {
            const spotPosition = this.getSpotPosition(spotMarketWithSameOracle.marketIndex);
            if (spotPosition) {
                const signedTokenAmount = (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_2.getTokenAmount)(spotPosition.scaledBalance, spotMarketWithSameOracle, spotPosition.balanceType), spotPosition.balanceType);
                let spotFreeCollateralDelta = this.calculateFreeCollateralDeltaForSpot(spotMarketWithSameOracle, signedTokenAmount, marginCategory);
                if (spotFreeCollateralDelta) {
                    const { numerator, denominator } = (0, oracles_1.getMultipleBetweenOracleSources)(market.amm.oracleSource, spotMarketWithSameOracle.oracleSource);
                    spotFreeCollateralDelta = spotFreeCollateralDelta
                        .mul(numerator)
                        .div(denominator);
                }
                freeCollateralDelta = freeCollateralDelta.add(spotFreeCollateralDelta || numericConstants_1.ZERO);
            }
        }
        if (freeCollateralDelta.eq(numericConstants_1.ZERO)) {
            return new anchor_1.BN(-1);
        }
        const liqPriceDelta = freeCollateral
            .mul(numericConstants_1.QUOTE_PRECISION)
            .div(freeCollateralDelta);
        const liqPrice = oraclePrice.sub(liqPriceDelta);
        if (liqPrice.lt(numericConstants_1.ZERO)) {
            return new anchor_1.BN(-1);
        }
        return liqPrice;
    }
    calculateEntriesEffectOnFreeCollateral(market, oraclePrice, perpPosition, positionBaseSizeChange, estimatedEntryPrice, includeOpenOrders, enteringHighLeverage = undefined, marginCategory = 'Maintenance') {
        let freeCollateralChange = numericConstants_1.ZERO;
        // update free collateral to account for change in pnl from new position
        if (!estimatedEntryPrice.eq(numericConstants_1.ZERO) &&
            !positionBaseSizeChange.eq(numericConstants_1.ZERO) &&
            marginCategory === 'Maintenance') {
            const costBasis = oraclePrice
                .mul(positionBaseSizeChange.abs())
                .div(numericConstants_1.BASE_PRECISION);
            const newPositionValue = estimatedEntryPrice
                .mul(positionBaseSizeChange.abs())
                .div(numericConstants_1.BASE_PRECISION);
            if (positionBaseSizeChange.gt(numericConstants_1.ZERO)) {
                freeCollateralChange = costBasis.sub(newPositionValue);
            }
            else {
                freeCollateralChange = newPositionValue.sub(costBasis);
            }
            // assume worst fee tier
            const takerFeeTier = this.driftClient.getStateAccount().perpFeeStructure.feeTiers[0];
            const takerFee = newPositionValue
                .muln(takerFeeTier.feeNumerator)
                .divn(takerFeeTier.feeDenominator);
            freeCollateralChange = freeCollateralChange.sub(takerFee);
        }
        const calculateMarginRequirement = (perpPosition) => {
            let baseAssetAmount;
            let liabilityValue;
            if (includeOpenOrders) {
                const { worstCaseBaseAssetAmount, worstCaseLiabilityValue } = (0, margin_1.calculateWorstCasePerpLiabilityValue)(perpPosition, market, oraclePrice);
                baseAssetAmount = worstCaseBaseAssetAmount;
                liabilityValue = worstCaseLiabilityValue;
            }
            else {
                baseAssetAmount = perpPosition.baseAssetAmount;
                liabilityValue = (0, margin_1.calculatePerpLiabilityValue)(baseAssetAmount, oraclePrice, (0, types_1.isVariant)(market.contractType, 'prediction'));
            }
            const userCustomMargin = Math.max(perpPosition.maxMarginRatio, this.getUserAccount().maxMarginRatio);
            const marginRatio = (0, market_1.calculateMarketMarginRatio)(market, baseAssetAmount.abs(), marginCategory, enteringHighLeverage === false
                ? Math.max(market.marginRatioInitial, userCustomMargin)
                : userCustomMargin, this.isHighLeverageMode(marginCategory) || enteringHighLeverage === true);
            return liabilityValue.mul(new anchor_1.BN(marginRatio)).div(numericConstants_1.MARGIN_PRECISION);
        };
        const freeCollateralConsumptionBefore = calculateMarginRequirement(perpPosition);
        const perpPositionAfter = Object.assign({}, perpPosition);
        perpPositionAfter.baseAssetAmount = perpPositionAfter.baseAssetAmount.add(positionBaseSizeChange);
        const freeCollateralConsumptionAfter = calculateMarginRequirement(perpPositionAfter);
        return freeCollateralChange.sub(freeCollateralConsumptionAfter.sub(freeCollateralConsumptionBefore));
    }
    calculateFreeCollateralDeltaForPerp(market, perpPosition, positionBaseSizeChange, oraclePrice, marginCategory = 'Maintenance', includeOpenOrders = false, enteringHighLeverage = undefined) {
        const baseAssetAmount = includeOpenOrders
            ? (0, margin_2.calculateWorstCaseBaseAssetAmount)(perpPosition, market, oraclePrice)
            : perpPosition.baseAssetAmount;
        // zero if include orders == false
        const orderBaseAssetAmount = baseAssetAmount.sub(perpPosition.baseAssetAmount);
        const proposedBaseAssetAmount = baseAssetAmount.add(positionBaseSizeChange);
        const userCustomMargin = Math.max(perpPosition.maxMarginRatio, this.getUserAccount().maxMarginRatio);
        const marginRatio = (0, market_1.calculateMarketMarginRatio)(market, proposedBaseAssetAmount.abs(), marginCategory, enteringHighLeverage === false
            ? Math.max(market.marginRatioInitial, userCustomMargin)
            : userCustomMargin, this.isHighLeverageMode(marginCategory) || enteringHighLeverage === true);
        const marginRatioQuotePrecision = new anchor_1.BN(marginRatio)
            .mul(numericConstants_1.QUOTE_PRECISION)
            .div(numericConstants_1.MARGIN_PRECISION);
        if (proposedBaseAssetAmount.eq(numericConstants_1.ZERO)) {
            return undefined;
        }
        let freeCollateralDelta = numericConstants_1.ZERO;
        if ((0, types_1.isVariant)(market.contractType, 'prediction')) {
            // for prediction market, increase in pnl and margin requirement will net out for position
            // open order margin requirement will change with price though
            if (orderBaseAssetAmount.gt(numericConstants_1.ZERO)) {
                freeCollateralDelta = marginRatioQuotePrecision.neg();
            }
            else if (orderBaseAssetAmount.lt(numericConstants_1.ZERO)) {
                freeCollateralDelta = marginRatioQuotePrecision;
            }
        }
        else {
            if (proposedBaseAssetAmount.gt(numericConstants_1.ZERO)) {
                freeCollateralDelta = numericConstants_1.QUOTE_PRECISION.sub(marginRatioQuotePrecision)
                    .mul(proposedBaseAssetAmount)
                    .div(numericConstants_1.BASE_PRECISION);
            }
            else {
                freeCollateralDelta = numericConstants_1.QUOTE_PRECISION.neg()
                    .sub(marginRatioQuotePrecision)
                    .mul(proposedBaseAssetAmount.abs())
                    .div(numericConstants_1.BASE_PRECISION);
            }
            if (!orderBaseAssetAmount.eq(numericConstants_1.ZERO)) {
                freeCollateralDelta = freeCollateralDelta.sub(marginRatioQuotePrecision
                    .mul(orderBaseAssetAmount.abs())
                    .div(numericConstants_1.BASE_PRECISION));
            }
        }
        return freeCollateralDelta;
    }
    calculateFreeCollateralDeltaForSpot(market, signedTokenAmount, marginCategory = 'Maintenance') {
        const tokenPrecision = new anchor_1.BN(Math.pow(10, market.decimals));
        if (signedTokenAmount.gt(numericConstants_1.ZERO)) {
            const assetWeight = (0, spotBalance_2.calculateAssetWeight)(signedTokenAmount, this.driftClient.getOracleDataForSpotMarket(market.marketIndex).price, market, marginCategory);
            return numericConstants_1.QUOTE_PRECISION.mul(assetWeight)
                .div(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION)
                .mul(signedTokenAmount)
                .div(tokenPrecision);
        }
        else {
            const liabilityWeight = (0, spotBalance_2.calculateLiabilityWeight)(signedTokenAmount.abs(), market, marginCategory);
            return numericConstants_1.QUOTE_PRECISION.neg()
                .mul(liabilityWeight)
                .div(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION)
                .mul(signedTokenAmount.abs())
                .div(tokenPrecision);
        }
    }
    /**
     * Calculates the estimated liquidation price for a position after closing a quote amount of the position.
     * @param positionMarketIndex
     * @param closeQuoteAmount
     * @returns : Precision PRICE_PRECISION
     */
    liquidationPriceAfterClose(positionMarketIndex, closeQuoteAmount, estimatedEntryPrice = numericConstants_1.ZERO) {
        const currentPosition = this.getPerpPositionOrEmpty(positionMarketIndex);
        const closeBaseAmount = currentPosition.baseAssetAmount
            .mul(closeQuoteAmount)
            .div(currentPosition.quoteAssetAmount.abs())
            .add(currentPosition.baseAssetAmount
            .mul(closeQuoteAmount)
            .mod(currentPosition.quoteAssetAmount.abs()))
            .neg();
        return this.liquidationPrice(positionMarketIndex, closeBaseAmount, estimatedEntryPrice);
    }
    getMarginUSDCRequiredForTrade(targetMarketIndex, baseSize, estEntryPrice, perpMarketMaxMarginRatio) {
        const maxMarginRatio = Math.max(perpMarketMaxMarginRatio, this.getUserAccount().maxMarginRatio);
        return (0, margin_2.calculateMarginUSDCRequiredForTrade)(this.driftClient, targetMarketIndex, baseSize, maxMarginRatio, undefined, estEntryPrice);
    }
    getCollateralDepositRequiredForTrade(targetMarketIndex, baseSize, collateralIndex, perpMarketMaxMarginRatio) {
        const maxMarginRatio = Math.max(perpMarketMaxMarginRatio, this.getUserAccount().maxMarginRatio);
        return (0, margin_2.calculateCollateralDepositRequiredForTrade)(this.driftClient, targetMarketIndex, baseSize, collateralIndex, maxMarginRatio, false // assume user cant be high leverage if they havent created user account ?
        );
    }
    /**
     * Separates the max trade size into two parts:
     * - tradeSize: The maximum trade size for target direction
     * - oppositeSideTradeSize: the trade size for closing the opposite direction
     * @param targetMarketIndex
     * @param tradeSide
     * @param isLp
     * @returns { tradeSize: BN, oppositeSideTradeSize: BN} : Precision QUOTE_PRECISION
     */
    getMaxTradeSizeUSDCForPerp(targetMarketIndex, tradeSide, isLp = false, enterHighLeverageMode = undefined, maxMarginRatio = undefined, positionType = 'cross') {
        let tradeSize = numericConstants_1.ZERO;
        let oppositeSideTradeSize = numericConstants_1.ZERO;
        const currentPosition = this.getPerpPositionOrEmpty(targetMarketIndex);
        const targetSide = (0, types_1.isVariant)(tradeSide, 'short') ? 'short' : 'long';
        const currentPositionSide = (currentPosition === null || currentPosition === void 0 ? void 0 : currentPosition.baseAssetAmount.isNeg())
            ? 'short'
            : 'long';
        const targetingSameSide = !currentPosition
            ? true
            : targetSide === currentPositionSide;
        const oracleData = this.getMMOracleDataForPerpMarket(targetMarketIndex);
        const marketAccount = this.driftClient.getPerpMarketAccount(targetMarketIndex);
        const lpBuffer = isLp
            ? oracleData.price
                .mul(marketAccount.amm.orderStepSize)
                .div(numericConstants_1.AMM_RESERVE_PRECISION)
            : numericConstants_1.ZERO;
        // add any position we have on the opposite side of the current trade, because we can "flip" the size of this position without taking any extra leverage.
        const oppositeSizeLiabilityValue = targetingSameSide
            ? numericConstants_1.ZERO
            : (0, margin_1.calculatePerpLiabilityValue)(currentPosition.baseAssetAmount, oracleData.price, (0, types_1.isVariant)(marketAccount.contractType, 'prediction'));
        const maxPositionSize = this.getPerpBuyingPower(targetMarketIndex, lpBuffer, enterHighLeverageMode, maxMarginRatio, positionType);
        if (maxPositionSize.gte(numericConstants_1.ZERO)) {
            if (oppositeSizeLiabilityValue.eq(numericConstants_1.ZERO)) {
                // case 1 : Regular trade where current total position less than max, and no opposite position to account for
                // do nothing
                tradeSize = maxPositionSize;
            }
            else {
                // case 2 : trade where current total position less than max, but need to account for flipping the current position over to the other side
                tradeSize = maxPositionSize.add(oppositeSizeLiabilityValue);
                oppositeSideTradeSize = oppositeSizeLiabilityValue;
            }
        }
        else {
            // current leverage is greater than max leverage - can only reduce position size
            if (!targetingSameSide) {
                const market = this.driftClient.getPerpMarketAccount(targetMarketIndex);
                const perpLiabilityValue = (0, margin_1.calculatePerpLiabilityValue)(currentPosition.baseAssetAmount, oracleData.price, (0, types_1.isVariant)(market.contractType, 'prediction'));
                const totalCollateral = this.getTotalCollateral();
                const marginRequirement = this.getInitialMarginRequirement(enterHighLeverageMode);
                const marginRatio = Math.max(currentPosition.maxMarginRatio, this.getUserAccount().maxMarginRatio);
                const marginFreedByClosing = perpLiabilityValue
                    .mul(new anchor_1.BN(marginRatio))
                    .div(numericConstants_1.MARGIN_PRECISION);
                const marginRequirementAfterClosing = marginRequirement.sub(marginFreedByClosing);
                if (marginRequirementAfterClosing.gt(totalCollateral)) {
                    oppositeSideTradeSize = perpLiabilityValue;
                }
                else {
                    const freeCollateralAfterClose = totalCollateral.sub(marginRequirementAfterClosing);
                    const buyingPowerAfterClose = this.getPerpBuyingPowerFromFreeCollateralAndBaseAssetAmount(targetMarketIndex, freeCollateralAfterClose, numericConstants_1.ZERO, currentPosition.maxMarginRatio);
                    oppositeSideTradeSize = perpLiabilityValue;
                    tradeSize = buyingPowerAfterClose;
                }
            }
            else {
                // do nothing if targetting same side
                tradeSize = maxPositionSize;
            }
        }
        const freeCollateral = this.getFreeCollateral('Initial', enterHighLeverageMode);
        let baseTradeSize = targetSide === 'long'
            ? tradeSize.mul(numericConstants_1.BASE_PRECISION).div(oracleData.price)
            : tradeSize.mul(numericConstants_1.BASE_PRECISION).div(oracleData.price).neg();
        let freeCollateralChangeFromNewPosition = this.calculateEntriesEffectOnFreeCollateral(marketAccount, oracleData.price, currentPosition, baseTradeSize, oracleData.price, false, enterHighLeverageMode, 'Initial');
        while (freeCollateralChangeFromNewPosition.isNeg() &&
            freeCollateralChangeFromNewPosition.abs().gt(freeCollateral)) {
            tradeSize = tradeSize.mul(new anchor_1.BN(99)).div(new anchor_1.BN(100));
            baseTradeSize =
                targetSide === 'long'
                    ? tradeSize.mul(numericConstants_1.BASE_PRECISION).div(oracleData.price)
                    : tradeSize.mul(numericConstants_1.BASE_PRECISION).div(oracleData.price).neg();
            freeCollateralChangeFromNewPosition =
                this.calculateEntriesEffectOnFreeCollateral(marketAccount, oracleData.price, currentPosition, baseTradeSize, oracleData.price, false, enterHighLeverageMode, 'Initial');
        }
        return { tradeSize, oppositeSideTradeSize };
    }
    /**
     * Get the maximum trade size for a given market, taking into account the user's current leverage, positions, collateral, etc.
     *
     * @param targetMarketIndex
     * @param direction
     * @param currentQuoteAssetValue
     * @param currentSpotMarketNetValue
     * @returns tradeSizeAllowed : Precision QUOTE_PRECISION
     */
    getMaxTradeSizeUSDCForSpot(targetMarketIndex, direction, currentQuoteAssetValue, currentSpotMarketNetValue) {
        const market = this.driftClient.getSpotMarketAccount(targetMarketIndex);
        const oraclePrice = this.driftClient.getOracleDataForSpotMarket(targetMarketIndex).price;
        currentQuoteAssetValue = this.getSpotMarketAssetValue(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        currentSpotMarketNetValue =
            currentSpotMarketNetValue !== null && currentSpotMarketNetValue !== void 0 ? currentSpotMarketNetValue : this.getSpotPositionValue(targetMarketIndex);
        let freeCollateral = this.getFreeCollateral();
        const marginRatio = (0, spotMarket_1.calculateSpotMarketMarginRatio)(market, oraclePrice, 'Initial', numericConstants_1.ZERO, (0, types_1.isVariant)(direction, 'long')
            ? types_2.SpotBalanceType.DEPOSIT
            : types_2.SpotBalanceType.BORROW, this.getUserAccount().maxMarginRatio);
        let tradeAmount = numericConstants_1.ZERO;
        if (this.getUserAccount().isMarginTradingEnabled) {
            // if the user is buying/selling and already short/long, need to account for closing out short/long
            if ((0, types_1.isVariant)(direction, 'long') && currentSpotMarketNetValue.lt(numericConstants_1.ZERO)) {
                tradeAmount = currentSpotMarketNetValue.abs();
                const marginRatio = (0, spotMarket_1.calculateSpotMarketMarginRatio)(market, oraclePrice, 'Initial', this.getTokenAmount(targetMarketIndex).abs(), types_2.SpotBalanceType.BORROW, this.getUserAccount().maxMarginRatio);
                freeCollateral = freeCollateral.add(tradeAmount.mul(new anchor_1.BN(marginRatio)).div(numericConstants_1.MARGIN_PRECISION));
            }
            else if ((0, types_1.isVariant)(direction, 'short') &&
                currentSpotMarketNetValue.gt(numericConstants_1.ZERO)) {
                tradeAmount = currentSpotMarketNetValue;
                const marginRatio = (0, spotMarket_1.calculateSpotMarketMarginRatio)(market, oraclePrice, 'Initial', this.getTokenAmount(targetMarketIndex), types_2.SpotBalanceType.DEPOSIT, this.getUserAccount().maxMarginRatio);
                freeCollateral = freeCollateral.add(tradeAmount.mul(new anchor_1.BN(marginRatio)).div(numericConstants_1.MARGIN_PRECISION));
            }
            tradeAmount = tradeAmount.add(freeCollateral.mul(numericConstants_1.MARGIN_PRECISION).div(new anchor_1.BN(marginRatio)));
        }
        else if ((0, types_1.isVariant)(direction, 'long')) {
            tradeAmount = anchor_1.BN.min(currentQuoteAssetValue, freeCollateral.mul(numericConstants_1.MARGIN_PRECISION).div(new anchor_1.BN(marginRatio)));
        }
        else {
            tradeAmount = anchor_1.BN.max(numericConstants_1.ZERO, currentSpotMarketNetValue);
        }
        return tradeAmount;
    }
    /**
     * Calculates the max amount of token that can be swapped from inMarket to outMarket
     * Assumes swap happens at oracle price
     *
     * @param inMarketIndex
     * @param outMarketIndex
     * @param calculateSwap function to similate in to out swa
     * @param iterationLimit how long to run appromixation before erroring out
     */
    getMaxSwapAmount({ inMarketIndex, outMarketIndex, calculateSwap, iterationLimit = 1000, }) {
        const inMarket = this.driftClient.getSpotMarketAccount(inMarketIndex);
        const outMarket = this.driftClient.getSpotMarketAccount(outMarketIndex);
        const inOraclePriceData = this.getOracleDataForSpotMarket(inMarketIndex);
        const inOraclePrice = inOraclePriceData.price;
        const outOraclePriceData = this.getOracleDataForSpotMarket(outMarketIndex);
        const outOraclePrice = outOraclePriceData.price;
        const inStrictOraclePrice = new strictOraclePrice_1.StrictOraclePrice(inOraclePrice);
        const outStrictOraclePrice = new strictOraclePrice_1.StrictOraclePrice(outOraclePrice);
        const inPrecision = new anchor_1.BN(10 ** inMarket.decimals);
        const outPrecision = new anchor_1.BN(10 ** outMarket.decimals);
        const inSpotPosition = this.getSpotPosition(inMarketIndex) ||
            this.getEmptySpotPosition(inMarketIndex);
        const outSpotPosition = this.getSpotPosition(outMarketIndex) ||
            this.getEmptySpotPosition(outMarketIndex);
        const freeCollateral = this.getFreeCollateral();
        const inContributionInitial = this.calculateSpotPositionFreeCollateralContribution(inSpotPosition, inStrictOraclePrice);
        const { totalAssetValue: inTotalAssetValueInitial, totalLiabilityValue: inTotalLiabilityValueInitial, } = this.calculateSpotPositionLeverageContribution(inSpotPosition, inStrictOraclePrice);
        const outContributionInitial = this.calculateSpotPositionFreeCollateralContribution(outSpotPosition, outStrictOraclePrice);
        const { totalAssetValue: outTotalAssetValueInitial, totalLiabilityValue: outTotalLiabilityValueInitial, } = this.calculateSpotPositionLeverageContribution(outSpotPosition, outStrictOraclePrice);
        const initialContribution = inContributionInitial.add(outContributionInitial);
        const { perpLiabilityValue, perpPnl, spotAssetValue, spotLiabilityValue } = this.getLeverageComponents();
        if (!calculateSwap) {
            calculateSwap = (inSwap) => {
                return inSwap
                    .mul(outPrecision)
                    .mul(inOraclePrice)
                    .div(outOraclePrice)
                    .div(inPrecision);
            };
        }
        let inSwap = numericConstants_1.ZERO;
        let outSwap = numericConstants_1.ZERO;
        const inTokenAmount = this.getTokenAmount(inMarketIndex);
        const outTokenAmount = this.getTokenAmount(outMarketIndex);
        const inAssetWeight = (0, spotBalance_2.calculateAssetWeight)(inTokenAmount, inOraclePriceData.price, inMarket, 'Initial');
        const outAssetWeight = (0, spotBalance_2.calculateAssetWeight)(outTokenAmount, outOraclePriceData.price, outMarket, 'Initial');
        const outSaferThanIn = 
        // selling asset to close borrow
        (inTokenAmount.gt(numericConstants_1.ZERO) && outTokenAmount.lt(numericConstants_1.ZERO)) ||
            // buying asset with higher initial asset weight
            inAssetWeight.lte(outAssetWeight);
        if (freeCollateral.lt(numericConstants_1.PRICE_PRECISION.divn(100))) {
            if (outSaferThanIn && inTokenAmount.gt(numericConstants_1.ZERO)) {
                inSwap = inTokenAmount;
                outSwap = calculateSwap(inSwap);
            }
        }
        else {
            let minSwap = numericConstants_1.ZERO;
            let maxSwap = anchor_1.BN.max(freeCollateral.mul(inPrecision).mul(new anchor_1.BN(100)).div(inOraclePrice), // 100x current free collateral
            inTokenAmount.abs().mul(new anchor_1.BN(10)) // 10x current position
            );
            inSwap = maxSwap.div(numericConstants_1.TWO);
            const error = freeCollateral.div(new anchor_1.BN(10000));
            let i = 0;
            let freeCollateralAfter = freeCollateral;
            while (freeCollateralAfter.gt(error) || freeCollateralAfter.isNeg()) {
                outSwap = calculateSwap(inSwap);
                const inPositionAfter = this.cloneAndUpdateSpotPosition(inSpotPosition, inSwap.neg(), inMarket);
                const outPositionAfter = this.cloneAndUpdateSpotPosition(outSpotPosition, outSwap, outMarket);
                const inContributionAfter = this.calculateSpotPositionFreeCollateralContribution(inPositionAfter, inStrictOraclePrice);
                const outContributionAfter = this.calculateSpotPositionFreeCollateralContribution(outPositionAfter, outStrictOraclePrice);
                const contributionAfter = inContributionAfter.add(outContributionAfter);
                const contributionDelta = contributionAfter.sub(initialContribution);
                freeCollateralAfter = freeCollateral.add(contributionDelta);
                if (freeCollateralAfter.gt(error)) {
                    minSwap = inSwap;
                    inSwap = minSwap.add(maxSwap).div(numericConstants_1.TWO);
                }
                else if (freeCollateralAfter.isNeg()) {
                    maxSwap = inSwap;
                    inSwap = minSwap.add(maxSwap).div(numericConstants_1.TWO);
                }
                if (i++ > iterationLimit) {
                    console.log('getMaxSwapAmount iteration limit reached');
                    break;
                }
            }
        }
        const inPositionAfter = this.cloneAndUpdateSpotPosition(inSpotPosition, inSwap.neg(), inMarket);
        const outPositionAfter = this.cloneAndUpdateSpotPosition(outSpotPosition, outSwap, outMarket);
        const { totalAssetValue: inTotalAssetValueAfter, totalLiabilityValue: inTotalLiabilityValueAfter, } = this.calculateSpotPositionLeverageContribution(inPositionAfter, inStrictOraclePrice);
        const { totalAssetValue: outTotalAssetValueAfter, totalLiabilityValue: outTotalLiabilityValueAfter, } = this.calculateSpotPositionLeverageContribution(outPositionAfter, outStrictOraclePrice);
        const spotAssetValueDelta = inTotalAssetValueAfter
            .add(outTotalAssetValueAfter)
            .sub(inTotalAssetValueInitial)
            .sub(outTotalAssetValueInitial);
        const spotLiabilityValueDelta = inTotalLiabilityValueAfter
            .add(outTotalLiabilityValueAfter)
            .sub(inTotalLiabilityValueInitial)
            .sub(outTotalLiabilityValueInitial);
        const spotAssetValueAfter = spotAssetValue.add(spotAssetValueDelta);
        const spotLiabilityValueAfter = spotLiabilityValue.add(spotLiabilityValueDelta);
        const leverage = this.calculateLeverageFromComponents({
            perpLiabilityValue,
            perpPnl,
            spotAssetValue: spotAssetValueAfter,
            spotLiabilityValue: spotLiabilityValueAfter,
        });
        return { inAmount: inSwap, outAmount: outSwap, leverage };
    }
    cloneAndUpdateSpotPosition(position, tokenAmount, market) {
        const clonedPosition = Object.assign({}, position);
        if (tokenAmount.eq(numericConstants_1.ZERO)) {
            return clonedPosition;
        }
        const preTokenAmount = (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_2.getTokenAmount)(position.scaledBalance, market, position.balanceType), position.balanceType);
        if ((0, utils_1.sigNum)(preTokenAmount).eq((0, utils_1.sigNum)(tokenAmount))) {
            const scaledBalanceDelta = (0, spotBalance_1.getBalance)(tokenAmount.abs(), market, position.balanceType);
            clonedPosition.scaledBalance =
                clonedPosition.scaledBalance.add(scaledBalanceDelta);
            return clonedPosition;
        }
        const updateDirection = tokenAmount.isNeg()
            ? types_2.SpotBalanceType.BORROW
            : types_2.SpotBalanceType.DEPOSIT;
        if (tokenAmount.abs().gte(preTokenAmount.abs())) {
            clonedPosition.scaledBalance = (0, spotBalance_1.getBalance)(tokenAmount.abs().sub(preTokenAmount.abs()), market, updateDirection);
            clonedPosition.balanceType = updateDirection;
        }
        else {
            const scaledBalanceDelta = (0, spotBalance_1.getBalance)(tokenAmount.abs(), market, position.balanceType);
            clonedPosition.scaledBalance =
                clonedPosition.scaledBalance.sub(scaledBalanceDelta);
        }
        return clonedPosition;
    }
    calculateSpotPositionFreeCollateralContribution(spotPosition, strictOraclePrice) {
        const marginCategory = 'Initial';
        const spotMarketAccount = this.driftClient.getSpotMarketAccount(spotPosition.marketIndex);
        const { freeCollateralContribution } = (0, spotPosition_1.getWorstCaseTokenAmounts)(spotPosition, spotMarketAccount, strictOraclePrice, marginCategory, this.getUserAccount().maxMarginRatio);
        return freeCollateralContribution;
    }
    calculateSpotPositionLeverageContribution(spotPosition, strictOraclePrice) {
        let totalAssetValue = numericConstants_1.ZERO;
        let totalLiabilityValue = numericConstants_1.ZERO;
        const spotMarketAccount = this.driftClient.getSpotMarketAccount(spotPosition.marketIndex);
        const { tokenValue, ordersValue } = (0, spotPosition_1.getWorstCaseTokenAmounts)(spotPosition, spotMarketAccount, strictOraclePrice, 'Initial', this.getUserAccount().maxMarginRatio);
        if (tokenValue.gte(numericConstants_1.ZERO)) {
            totalAssetValue = tokenValue;
        }
        else {
            totalLiabilityValue = tokenValue.abs();
        }
        if (ordersValue.gt(numericConstants_1.ZERO)) {
            totalAssetValue = totalAssetValue.add(ordersValue);
        }
        else {
            totalLiabilityValue = totalLiabilityValue.add(ordersValue.abs());
        }
        return {
            totalAssetValue,
            totalLiabilityValue,
        };
    }
    /**
     * Estimates what the user leverage will be after swap
     * @param inMarketIndex
     * @param outMarketIndex
     * @param inAmount
     * @param outAmount
     */
    accountLeverageAfterSwap({ inMarketIndex, outMarketIndex, inAmount, outAmount, }) {
        const inMarket = this.driftClient.getSpotMarketAccount(inMarketIndex);
        const outMarket = this.driftClient.getSpotMarketAccount(outMarketIndex);
        const inOraclePriceData = this.getOracleDataForSpotMarket(inMarketIndex);
        const inOraclePrice = inOraclePriceData.price;
        const outOraclePriceData = this.getOracleDataForSpotMarket(outMarketIndex);
        const outOraclePrice = outOraclePriceData.price;
        const inStrictOraclePrice = new strictOraclePrice_1.StrictOraclePrice(inOraclePrice);
        const outStrictOraclePrice = new strictOraclePrice_1.StrictOraclePrice(outOraclePrice);
        const inSpotPosition = this.getSpotPosition(inMarketIndex) ||
            this.getEmptySpotPosition(inMarketIndex);
        const outSpotPosition = this.getSpotPosition(outMarketIndex) ||
            this.getEmptySpotPosition(outMarketIndex);
        const { totalAssetValue: inTotalAssetValueInitial, totalLiabilityValue: inTotalLiabilityValueInitial, } = this.calculateSpotPositionLeverageContribution(inSpotPosition, inStrictOraclePrice);
        const { totalAssetValue: outTotalAssetValueInitial, totalLiabilityValue: outTotalLiabilityValueInitial, } = this.calculateSpotPositionLeverageContribution(outSpotPosition, outStrictOraclePrice);
        const { perpLiabilityValue, perpPnl, spotAssetValue, spotLiabilityValue } = this.getLeverageComponents();
        const inPositionAfter = this.cloneAndUpdateSpotPosition(inSpotPosition, inAmount.abs().neg(), inMarket);
        const outPositionAfter = this.cloneAndUpdateSpotPosition(outSpotPosition, outAmount.abs(), outMarket);
        const { totalAssetValue: inTotalAssetValueAfter, totalLiabilityValue: inTotalLiabilityValueAfter, } = this.calculateSpotPositionLeverageContribution(inPositionAfter, inStrictOraclePrice);
        const { totalAssetValue: outTotalAssetValueAfter, totalLiabilityValue: outTotalLiabilityValueAfter, } = this.calculateSpotPositionLeverageContribution(outPositionAfter, outStrictOraclePrice);
        const spotAssetValueDelta = inTotalAssetValueAfter
            .add(outTotalAssetValueAfter)
            .sub(inTotalAssetValueInitial)
            .sub(outTotalAssetValueInitial);
        const spotLiabilityValueDelta = inTotalLiabilityValueAfter
            .add(outTotalLiabilityValueAfter)
            .sub(inTotalLiabilityValueInitial)
            .sub(outTotalLiabilityValueInitial);
        const spotAssetValueAfter = spotAssetValue.add(spotAssetValueDelta);
        const spotLiabilityValueAfter = spotLiabilityValue.add(spotLiabilityValueDelta);
        return this.calculateLeverageFromComponents({
            perpLiabilityValue,
            perpPnl,
            spotAssetValue: spotAssetValueAfter,
            spotLiabilityValue: spotLiabilityValueAfter,
        });
    }
    // TODO - should this take the price impact of the trade into account for strict accuracy?
    /**
     * Returns the leverage ratio for the account after adding (or subtracting) the given quote size to the given position
     * @param targetMarketIndex
     * @param: targetMarketType
     * @param tradeQuoteAmount
     * @param tradeSide
     * @param includeOpenOrders
     * @returns leverageRatio : Precision TEN_THOUSAND
     */
    accountLeverageRatioAfterTrade(targetMarketIndex, targetMarketType, tradeQuoteAmount, tradeSide, includeOpenOrders = true) {
        const tradeIsPerp = (0, types_1.isVariant)(targetMarketType, 'perp');
        if (!tradeIsPerp) {
            // calculate new asset/liability values for base and quote market to find new account leverage
            const totalLiabilityValue = this.getTotalLiabilityValue();
            const totalAssetValue = this.getTotalAssetValue();
            const spotLiabilityValue = this.getSpotMarketLiabilityValue(undefined, undefined, undefined, includeOpenOrders);
            const currentQuoteAssetValue = this.getSpotMarketAssetValue(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, undefined, includeOpenOrders);
            const currentQuoteLiabilityValue = this.getSpotMarketLiabilityValue(numericConstants_1.QUOTE_SPOT_MARKET_INDEX, undefined, undefined, includeOpenOrders);
            const currentQuoteValue = currentQuoteAssetValue.sub(currentQuoteLiabilityValue);
            const currentSpotMarketAssetValue = this.getSpotMarketAssetValue(targetMarketIndex, undefined, includeOpenOrders);
            const currentSpotMarketLiabilityValue = this.getSpotMarketLiabilityValue(targetMarketIndex, undefined, undefined, includeOpenOrders);
            const currentSpotMarketNetValue = currentSpotMarketAssetValue.sub(currentSpotMarketLiabilityValue);
            let assetValueToAdd = numericConstants_1.ZERO;
            let liabilityValueToAdd = numericConstants_1.ZERO;
            const newQuoteNetValue = tradeSide == types_2.PositionDirection.SHORT
                ? currentQuoteValue.add(tradeQuoteAmount)
                : currentQuoteValue.sub(tradeQuoteAmount);
            const newQuoteAssetValue = anchor_1.BN.max(newQuoteNetValue, numericConstants_1.ZERO);
            const newQuoteLiabilityValue = anchor_1.BN.min(newQuoteNetValue, numericConstants_1.ZERO).abs();
            assetValueToAdd = assetValueToAdd.add(newQuoteAssetValue.sub(currentQuoteAssetValue));
            liabilityValueToAdd = liabilityValueToAdd.add(newQuoteLiabilityValue.sub(currentQuoteLiabilityValue));
            const newSpotMarketNetValue = tradeSide == types_2.PositionDirection.LONG
                ? currentSpotMarketNetValue.add(tradeQuoteAmount)
                : currentSpotMarketNetValue.sub(tradeQuoteAmount);
            const newSpotMarketAssetValue = anchor_1.BN.max(newSpotMarketNetValue, numericConstants_1.ZERO);
            const newSpotMarketLiabilityValue = anchor_1.BN.min(newSpotMarketNetValue, numericConstants_1.ZERO).abs();
            assetValueToAdd = assetValueToAdd.add(newSpotMarketAssetValue.sub(currentSpotMarketAssetValue));
            liabilityValueToAdd = liabilityValueToAdd.add(newSpotMarketLiabilityValue.sub(currentSpotMarketLiabilityValue));
            const totalAssetValueAfterTrade = totalAssetValue.add(assetValueToAdd);
            const totalSpotLiabilityValueAfterTrade = spotLiabilityValue.add(liabilityValueToAdd);
            const totalLiabilityValueAfterTrade = totalLiabilityValue.add(liabilityValueToAdd);
            const netAssetValueAfterTrade = totalAssetValueAfterTrade.sub(totalSpotLiabilityValueAfterTrade);
            if (netAssetValueAfterTrade.eq(numericConstants_1.ZERO)) {
                return numericConstants_1.ZERO;
            }
            const newLeverage = totalLiabilityValueAfterTrade
                .mul(numericConstants_1.TEN_THOUSAND)
                .div(netAssetValueAfterTrade);
            return newLeverage;
        }
        const currentPosition = this.getPerpPositionOrEmpty(targetMarketIndex);
        const perpMarket = this.driftClient.getPerpMarketAccount(targetMarketIndex);
        const oracleData = this.getOracleDataForPerpMarket(targetMarketIndex);
        let { 
        // eslint-disable-next-line prefer-const
        worstCaseBaseAssetAmount: worstCaseBase, worstCaseLiabilityValue: currentPositionQuoteAmount, } = (0, margin_1.calculateWorstCasePerpLiabilityValue)(currentPosition, perpMarket, oracleData.price);
        // current side is short if position base asset amount is negative OR there is no position open but open orders are short
        const currentSide = currentPosition.baseAssetAmount.isNeg() ||
            (currentPosition.baseAssetAmount.eq(numericConstants_1.ZERO) && worstCaseBase.isNeg())
            ? types_2.PositionDirection.SHORT
            : types_2.PositionDirection.LONG;
        if (currentSide === types_2.PositionDirection.SHORT)
            currentPositionQuoteAmount = currentPositionQuoteAmount.neg();
        if (tradeSide === types_2.PositionDirection.SHORT)
            tradeQuoteAmount = tradeQuoteAmount.neg();
        const currentPerpPositionAfterTrade = currentPositionQuoteAmount
            .add(tradeQuoteAmount)
            .abs();
        const totalPositionAfterTradeExcludingTargetMarket = this.getTotalPerpPositionValueExcludingMarket(targetMarketIndex, undefined, undefined, includeOpenOrders);
        const totalAssetValue = this.getTotalAssetValue();
        const totalPerpPositionLiability = currentPerpPositionAfterTrade
            .add(totalPositionAfterTradeExcludingTargetMarket)
            .abs();
        const totalSpotLiability = this.getSpotMarketLiabilityValue(undefined, undefined, undefined, includeOpenOrders);
        const totalLiabilitiesAfterTrade = totalPerpPositionLiability.add(totalSpotLiability);
        const netAssetValue = totalAssetValue.sub(totalSpotLiability);
        if (netAssetValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.ZERO;
        }
        const newLeverage = totalLiabilitiesAfterTrade
            .mul(numericConstants_1.TEN_THOUSAND)
            .div(netAssetValue);
        return newLeverage;
    }
    getUserFeeTier(marketType, now) {
        const state = this.driftClient.getStateAccount();
        const feeTierIndex = 0;
        if ((0, types_1.isVariant)(marketType, 'perp')) {
            if (this.isHighLeverageMode('Initial')) {
                return state.perpFeeStructure.feeTiers[0];
            }
            const userStatsAccount = this.driftClient
                .getUserStats()
                .getAccount();
            const total30dVolume = (0, trade_1.getUser30dRollingVolumeEstimate)(userStatsAccount, now);
            const stakedGovAssetAmount = userStatsAccount.ifStakedGovTokenAmount;
            const volumeThresholds = [
                new anchor_1.BN(2000000).mul(numericConstants_1.QUOTE_PRECISION),
                new anchor_1.BN(10000000).mul(numericConstants_1.QUOTE_PRECISION),
                new anchor_1.BN(20000000).mul(numericConstants_1.QUOTE_PRECISION),
                new anchor_1.BN(80000000).mul(numericConstants_1.QUOTE_PRECISION),
                new anchor_1.BN(200000000).mul(numericConstants_1.QUOTE_PRECISION),
            ];
            const stakeThresholds = [
                new anchor_1.BN(1000 - 1).mul(numericConstants_1.QUOTE_PRECISION),
                new anchor_1.BN(10000 - 1).mul(numericConstants_1.QUOTE_PRECISION),
                new anchor_1.BN(50000 - 1).mul(numericConstants_1.QUOTE_PRECISION),
                new anchor_1.BN(100000 - 1).mul(numericConstants_1.QUOTE_PRECISION),
                new anchor_1.BN(250000 - 5).mul(numericConstants_1.QUOTE_PRECISION),
            ];
            const stakeBenefitFrac = [0, 5, 10, 20, 30, 40];
            let feeTierIndex = 5;
            for (let i = 0; i < volumeThresholds.length; i++) {
                if (total30dVolume.lt(volumeThresholds[i])) {
                    feeTierIndex = i;
                    break;
                }
            }
            let stakeBenefitIndex = 5;
            for (let i = 0; i < stakeThresholds.length; i++) {
                if (stakedGovAssetAmount.lt(stakeThresholds[i])) {
                    stakeBenefitIndex = i;
                    break;
                }
            }
            const stakeBenefit = stakeBenefitFrac[stakeBenefitIndex];
            const tier = { ...state.perpFeeStructure.feeTiers[feeTierIndex] };
            if (stakeBenefit > 0) {
                tier.feeNumerator = (tier.feeNumerator * (100 - stakeBenefit)) / 100;
                tier.makerRebateNumerator =
                    (tier.makerRebateNumerator * (100 + stakeBenefit)) / 100;
            }
            return tier;
        }
        return state.spotFeeStructure.feeTiers[feeTierIndex];
    }
    /**
     * Calculates how much perp fee will be taken for a given sized trade
     * @param quoteAmount
     * @returns feeForQuote : Precision QUOTE_PRECISION
     */
    calculateFeeForQuoteAmount(quoteAmount, marketIndex, enteringHighLeverageMode) {
        if (marketIndex !== undefined) {
            const takerFeeMultiplier = this.driftClient.getMarketFees(types_2.MarketType.PERP, marketIndex, this, enteringHighLeverageMode).takerFee;
            const feeAmountNum = bigNum_1.BigNum.from(quoteAmount, numericConstants_1.QUOTE_PRECISION_EXP).toNum() *
                takerFeeMultiplier;
            return bigNum_1.BigNum.fromPrint(feeAmountNum.toString(), numericConstants_1.QUOTE_PRECISION_EXP).val;
        }
        else {
            const feeTier = this.getUserFeeTier(types_2.MarketType.PERP);
            return quoteAmount
                .mul(new anchor_1.BN(feeTier.feeNumerator))
                .div(new anchor_1.BN(feeTier.feeDenominator));
        }
    }
    /**
     * Calculates a user's max withdrawal amounts for a spot market. If reduceOnly is true,
     * it will return the max withdrawal amount without opening a liability for the user
     * @param marketIndex
     * @returns withdrawalLimit : Precision is the token precision for the chosen SpotMarket
     */
    getWithdrawalLimit(marketIndex, reduceOnly) {
        const nowTs = new anchor_1.BN(Math.floor(Date.now() / 1000));
        const spotMarket = this.driftClient.getSpotMarketAccount(marketIndex);
        // eslint-disable-next-line prefer-const
        let { borrowLimit, withdrawLimit } = (0, spotBalance_2.calculateWithdrawLimit)(spotMarket, nowTs);
        const freeCollateral = this.getFreeCollateral();
        const initialMarginRequirement = this.getInitialMarginRequirement();
        const oracleData = this.getOracleDataForSpotMarket(marketIndex);
        const { numeratorScale, denominatorScale } = spotMarket.decimals > 6
            ? {
                numeratorScale: new anchor_1.BN(10).pow(new anchor_1.BN(spotMarket.decimals - 6)),
                denominatorScale: new anchor_1.BN(1),
            }
            : {
                numeratorScale: new anchor_1.BN(1),
                denominatorScale: new anchor_1.BN(10).pow(new anchor_1.BN(6 - spotMarket.decimals)),
            };
        const { canBypass, depositAmount: userDepositAmount } = this.canBypassWithdrawLimits(marketIndex);
        if (canBypass) {
            withdrawLimit = anchor_1.BN.max(withdrawLimit, userDepositAmount);
        }
        const assetWeight = (0, spotBalance_2.calculateAssetWeight)(userDepositAmount, oracleData.price, spotMarket, 'Initial');
        let amountWithdrawable;
        if (assetWeight.eq(numericConstants_1.ZERO)) {
            amountWithdrawable = userDepositAmount;
        }
        else if (initialMarginRequirement.eq(numericConstants_1.ZERO)) {
            amountWithdrawable = userDepositAmount;
        }
        else {
            amountWithdrawable = (0, utils_1.divCeil)((0, utils_1.divCeil)(freeCollateral.mul(numericConstants_1.MARGIN_PRECISION), assetWeight).mul(numericConstants_1.PRICE_PRECISION), oracleData.price)
                .mul(numeratorScale)
                .div(denominatorScale);
        }
        const maxWithdrawValue = anchor_1.BN.min(anchor_1.BN.min(amountWithdrawable, userDepositAmount), withdrawLimit.abs());
        if (reduceOnly) {
            return anchor_1.BN.max(maxWithdrawValue, numericConstants_1.ZERO);
        }
        else {
            const weightedAssetValue = this.getSpotMarketAssetValue(marketIndex, 'Initial', false);
            const freeCollatAfterWithdraw = userDepositAmount.gt(numericConstants_1.ZERO)
                ? freeCollateral.sub(weightedAssetValue)
                : freeCollateral;
            const maxLiabilityAllowed = freeCollatAfterWithdraw
                .mul(numericConstants_1.MARGIN_PRECISION)
                .div(new anchor_1.BN(spotMarket.initialLiabilityWeight))
                .mul(numericConstants_1.PRICE_PRECISION)
                .div(oracleData.price)
                .mul(numeratorScale)
                .div(denominatorScale);
            const maxBorrowValue = anchor_1.BN.min(maxWithdrawValue.add(maxLiabilityAllowed), borrowLimit.abs());
            return anchor_1.BN.max(maxBorrowValue, numericConstants_1.ZERO);
        }
    }
    canBypassWithdrawLimits(marketIndex) {
        const spotMarket = this.driftClient.getSpotMarketAccount(marketIndex);
        const maxDepositAmount = spotMarket.withdrawGuardThreshold.div(new anchor_1.BN(10));
        const position = this.getSpotPosition(marketIndex);
        const netDeposits = this.getUserAccount().totalDeposits.sub(this.getUserAccount().totalWithdraws);
        if (!position) {
            return {
                canBypass: false,
                maxDepositAmount,
                depositAmount: numericConstants_1.ZERO,
                netDeposits,
            };
        }
        if ((0, types_1.isVariant)(position.balanceType, 'borrow')) {
            return {
                canBypass: false,
                maxDepositAmount,
                netDeposits,
                depositAmount: numericConstants_1.ZERO,
            };
        }
        const depositAmount = (0, spotBalance_2.getTokenAmount)(position.scaledBalance, spotMarket, types_2.SpotBalanceType.DEPOSIT);
        if (netDeposits.lt(numericConstants_1.ZERO)) {
            return {
                canBypass: false,
                maxDepositAmount,
                depositAmount,
                netDeposits,
            };
        }
        return {
            canBypass: depositAmount.lt(maxDepositAmount),
            maxDepositAmount,
            netDeposits,
            depositAmount,
        };
    }
    canMakeIdle(slot) {
        const userAccount = this.getUserAccount();
        if (userAccount.idle) {
            return false;
        }
        const { totalAssetValue, totalLiabilityValue } = this.getSpotMarketAssetAndLiabilityValue();
        const equity = totalAssetValue.sub(totalLiabilityValue);
        let slotsBeforeIdle;
        if (equity.lt(numericConstants_1.QUOTE_PRECISION.muln(1000))) {
            slotsBeforeIdle = new anchor_1.BN(9000); // 1 hour
        }
        else {
            slotsBeforeIdle = new anchor_1.BN(1512000); // 1 week
        }
        const userLastActiveSlot = userAccount.lastActiveSlot;
        const slotsSinceLastActive = slot.sub(userLastActiveSlot);
        if (slotsSinceLastActive.lt(slotsBeforeIdle)) {
            return false;
        }
        if (this.isBeingLiquidated()) {
            return false;
        }
        for (const perpPosition of userAccount.perpPositions) {
            if (!(0, position_1.positionIsAvailable)(perpPosition)) {
                return false;
            }
        }
        for (const spotPosition of userAccount.spotPositions) {
            if ((0, types_1.isVariant)(spotPosition.balanceType, 'borrow') &&
                spotPosition.scaledBalance.gt(numericConstants_1.ZERO)) {
                return false;
            }
            if (spotPosition.openOrders !== 0) {
                return false;
            }
        }
        for (const order of userAccount.orders) {
            if ((0, types_1.isVariant)(order.status, 'open')) {
                return false;
            }
        }
        return true;
    }
    getSafestTiers() {
        let safestPerpTier = 4;
        let safestSpotTier = 4;
        for (const perpPosition of this.getActivePerpPositions()) {
            safestPerpTier = Math.min(safestPerpTier, (0, tiers_1.getPerpMarketTierNumber)(this.driftClient.getPerpMarketAccount(perpPosition.marketIndex)));
        }
        for (const spotPosition of this.getActiveSpotPositions()) {
            if ((0, types_1.isVariant)(spotPosition.balanceType, 'deposit')) {
                continue;
            }
            safestSpotTier = Math.min(safestSpotTier, (0, tiers_1.getSpotMarketTierNumber)(this.driftClient.getSpotMarketAccount(spotPosition.marketIndex)));
        }
        return {
            perpTier: safestPerpTier,
            spotTier: safestSpotTier,
        };
    }
    getPerpPositionHealth({ marginCategory, perpPosition, oraclePriceData, quoteOraclePriceData, includeOpenOrders = true, }) {
        const perpMarket = this.driftClient.getPerpMarketAccount(perpPosition.marketIndex);
        const _oraclePriceData = oraclePriceData ||
            this.driftClient.getOracleDataForPerpMarket(perpMarket.marketIndex);
        const oraclePrice = _oraclePriceData.price;
        let worstCaseBaseAmount;
        let worstCaseLiabilityValue;
        if (includeOpenOrders) {
            const worstCaseIncludeOrders = (0, margin_1.calculateWorstCasePerpLiabilityValue)(perpPosition, perpMarket, oraclePrice);
            worstCaseBaseAmount = worstCaseIncludeOrders.worstCaseBaseAssetAmount;
            worstCaseLiabilityValue = worstCaseIncludeOrders.worstCaseLiabilityValue;
        }
        else {
            worstCaseBaseAmount = perpPosition.baseAssetAmount;
            worstCaseLiabilityValue = (0, margin_1.calculatePerpLiabilityValue)(perpPosition.baseAssetAmount, oraclePrice, (0, types_1.isVariant)(perpMarket.contractType, 'prediction'));
        }
        const userCustomMargin = Math.max(perpPosition.maxMarginRatio, this.getUserAccount().maxMarginRatio);
        const marginRatio = new anchor_1.BN((0, market_1.calculateMarketMarginRatio)(perpMarket, worstCaseBaseAmount.abs(), marginCategory, userCustomMargin, this.isHighLeverageMode(marginCategory)));
        const _quoteOraclePriceData = quoteOraclePriceData ||
            this.driftClient.getOracleDataForSpotMarket(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
        let marginRequirement = worstCaseLiabilityValue
            .mul(_quoteOraclePriceData.price)
            .div(numericConstants_1.PRICE_PRECISION)
            .mul(marginRatio)
            .div(numericConstants_1.MARGIN_PRECISION);
        marginRequirement = marginRequirement.add(new anchor_1.BN(perpPosition.openOrders).mul(numericConstants_1.OPEN_ORDER_MARGIN_REQUIREMENT));
        return {
            marketIndex: perpMarket.marketIndex,
            size: worstCaseBaseAmount,
            value: worstCaseLiabilityValue,
            weight: marginRatio,
            weightedValue: marginRequirement,
        };
    }
    getHealthComponents({ marginCategory, }) {
        const healthComponents = {
            deposits: [],
            borrows: [],
            perpPositions: [],
            perpPnl: [],
        };
        for (const perpPosition of this.getActivePerpPositions()) {
            const perpMarket = this.driftClient.getPerpMarketAccount(perpPosition.marketIndex);
            const oraclePriceData = this.driftClient.getOracleDataForPerpMarket(perpMarket.marketIndex);
            const quoteOraclePriceData = this.driftClient.getOracleDataForSpotMarket(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
            healthComponents.perpPositions.push(this.getPerpPositionHealth({
                marginCategory,
                perpPosition,
                oraclePriceData,
                quoteOraclePriceData,
            }));
            const quoteSpotMarket = this.driftClient.getSpotMarketAccount(perpMarket.quoteSpotMarketIndex);
            const positionUnrealizedPnl = (0, position_2.calculatePositionPNL)(perpMarket, perpPosition, true, oraclePriceData);
            let pnlWeight;
            if (positionUnrealizedPnl.gt(numericConstants_1.ZERO)) {
                pnlWeight = (0, market_1.calculateUnrealizedAssetWeight)(perpMarket, quoteSpotMarket, positionUnrealizedPnl, marginCategory, oraclePriceData);
            }
            else {
                pnlWeight = numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION;
            }
            const pnlValue = positionUnrealizedPnl
                .mul(quoteOraclePriceData.price)
                .div(numericConstants_1.PRICE_PRECISION);
            const wegithedPnlValue = pnlValue
                .mul(pnlWeight)
                .div(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION);
            healthComponents.perpPnl.push({
                marketIndex: perpMarket.marketIndex,
                size: positionUnrealizedPnl,
                value: pnlValue,
                weight: pnlWeight,
                weightedValue: wegithedPnlValue,
            });
        }
        let netQuoteValue = numericConstants_1.ZERO;
        for (const spotPosition of this.getActiveSpotPositions()) {
            const spotMarketAccount = this.driftClient.getSpotMarketAccount(spotPosition.marketIndex);
            const oraclePriceData = this.getOracleDataForSpotMarket(spotPosition.marketIndex);
            const strictOraclePrice = new strictOraclePrice_1.StrictOraclePrice(oraclePriceData.price);
            if (spotPosition.marketIndex === numericConstants_1.QUOTE_SPOT_MARKET_INDEX) {
                const tokenAmount = (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_2.getTokenAmount)(spotPosition.scaledBalance, spotMarketAccount, spotPosition.balanceType), spotPosition.balanceType);
                netQuoteValue = netQuoteValue.add(tokenAmount);
                continue;
            }
            const { tokenAmount: worstCaseTokenAmount, tokenValue: tokenValue, weight, weightedTokenValue: weightedTokenValue, ordersValue: ordersValue, } = (0, spotPosition_1.getWorstCaseTokenAmounts)(spotPosition, spotMarketAccount, strictOraclePrice, marginCategory, this.getUserAccount().maxMarginRatio);
            netQuoteValue = netQuoteValue.add(ordersValue);
            const baseAssetValue = tokenValue.abs();
            const weightedValue = weightedTokenValue.abs();
            if (weightedTokenValue.lt(numericConstants_1.ZERO)) {
                healthComponents.borrows.push({
                    marketIndex: spotMarketAccount.marketIndex,
                    size: worstCaseTokenAmount,
                    value: baseAssetValue,
                    weight: weight,
                    weightedValue: weightedValue,
                });
            }
            else {
                healthComponents.deposits.push({
                    marketIndex: spotMarketAccount.marketIndex,
                    size: worstCaseTokenAmount,
                    value: baseAssetValue,
                    weight: weight,
                    weightedValue: weightedValue,
                });
            }
        }
        if (!netQuoteValue.eq(numericConstants_1.ZERO)) {
            const spotMarketAccount = this.driftClient.getQuoteSpotMarketAccount();
            const oraclePriceData = this.getOracleDataForSpotMarket(numericConstants_1.QUOTE_SPOT_MARKET_INDEX);
            const baseAssetValue = (0, spotBalance_1.getTokenValue)(netQuoteValue, spotMarketAccount.decimals, oraclePriceData);
            const { weight, weightedTokenValue } = (0, spotPosition_1.calculateWeightedTokenValue)(netQuoteValue, baseAssetValue, oraclePriceData.price, spotMarketAccount, marginCategory, this.getUserAccount().maxMarginRatio);
            if (netQuoteValue.lt(numericConstants_1.ZERO)) {
                healthComponents.borrows.push({
                    marketIndex: spotMarketAccount.marketIndex,
                    size: netQuoteValue,
                    value: baseAssetValue.abs(),
                    weight: weight,
                    weightedValue: weightedTokenValue.abs(),
                });
            }
            else {
                healthComponents.deposits.push({
                    marketIndex: spotMarketAccount.marketIndex,
                    size: netQuoteValue,
                    value: baseAssetValue,
                    weight: weight,
                    weightedValue: weightedTokenValue,
                });
            }
        }
        return healthComponents;
    }
    /**
     * Get the total position value, excluding any position coming from the given target market
     * @param marketToIgnore
     * @returns positionValue : Precision QUOTE_PRECISION
     */
    getTotalPerpPositionValueExcludingMarket(marketToIgnore, marginCategory, liquidationBuffer, includeOpenOrders) {
        const currentPerpPosition = this.getPerpPositionOrEmpty(marketToIgnore);
        const oracleData = this.getOracleDataForPerpMarket(marketToIgnore);
        let currentPerpPositionValueUSDC = numericConstants_1.ZERO;
        if (currentPerpPosition) {
            currentPerpPositionValueUSDC = this.getPerpLiabilityValue(marketToIgnore, oracleData, includeOpenOrders);
        }
        return this.getTotalPerpPositionLiability(marginCategory, liquidationBuffer, includeOpenOrders).sub(currentPerpPositionValueUSDC);
    }
    getMMOracleDataForPerpMarket(marketIndex) {
        return this.driftClient.getMMOracleDataForPerpMarket(marketIndex);
    }
    getOracleDataForPerpMarket(marketIndex) {
        return this.driftClient.getOracleDataForPerpMarket(marketIndex);
    }
    getOracleDataForSpotMarket(marketIndex) {
        return this.driftClient.getOracleDataForSpotMarket(marketIndex);
    }
    /**
     * Get the active perp and spot positions of the user.
     */
    getActivePositions() {
        const activePerpMarkets = this.getActivePerpPositions().map((position) => position.marketIndex);
        const activeSpotMarkets = this.getActiveSpotPositions().map((position) => position.marketIndex);
        return {
            activePerpPositions: activePerpMarkets,
            activeSpotPositions: activeSpotMarkets,
        };
    }
    /**
     * Compute the full margin calculation for the user's account.
     * Prioritize using this function instead of calling getMarginRequirement or getTotalCollateral multiple times.
     * Consumers can use this to avoid duplicating work across separate calls.
     */
    getMarginCalculation(marginCategory = 'Initial', opts) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const strict = (_a = opts === null || opts === void 0 ? void 0 : opts.strict) !== null && _a !== void 0 ? _a : false;
        const enteringHighLeverage = (_b = opts === null || opts === void 0 ? void 0 : opts.enteringHighLeverage) !== null && _b !== void 0 ? _b : false;
        const liquidationBufferMap = (_c = opts === null || opts === void 0 ? void 0 : opts.liquidationBufferMap) !== null && _c !== void 0 ? _c : new Map();
        const includeOpenOrders = (_d = opts === null || opts === void 0 ? void 0 : opts.includeOpenOrders) !== null && _d !== void 0 ? _d : true;
        // Equivalent to on-chain user_custom_margin_ratio
        const userCustomMarginRatio = marginCategory === 'Initial' ? this.getUserAccount().maxMarginRatio : 0;
        // Initialize calc via JS mirror of Rust/on-chain MarginCalculation
        const isolatedMarginBuffers = new Map();
        for (const [marketIndex, isolatedMarginBuffer,] of (_e = opts === null || opts === void 0 ? void 0 : opts.liquidationBufferMap) !== null && _e !== void 0 ? _e : new Map()) {
            if (marketIndex !== 'cross') {
                isolatedMarginBuffers.set(marketIndex, isolatedMarginBuffer);
            }
        }
        const ctx = marginCalculation_1.MarginContext.standard(marginCategory)
            .strictMode(strict)
            .setCrossMarginBuffer((_g = (_f = opts === null || opts === void 0 ? void 0 : opts.liquidationBufferMap) === null || _f === void 0 ? void 0 : _f.get('cross')) !== null && _g !== void 0 ? _g : numericConstants_1.ZERO)
            .setIsolatedMarginBuffers(isolatedMarginBuffers);
        const calc = new marginCalculation_1.MarginCalculation(ctx);
        // SPOT POSITIONS
        for (const spotPosition of this.getUserAccount().spotPositions) {
            if ((0, spotPosition_1.isSpotPositionAvailable)(spotPosition))
                continue;
            const isQuote = spotPosition.marketIndex === numericConstants_1.QUOTE_SPOT_MARKET_INDEX;
            const spotMarket = this.driftClient.getSpotMarketAccount(spotPosition.marketIndex);
            const oraclePriceData = this.getOracleDataForSpotMarket(spotPosition.marketIndex);
            const twap5 = strict
                ? (0, oracles_1.calculateLiveOracleTwap)(spotMarket.historicalOracleData, oraclePriceData, new anchor_1.BN(Math.floor(Date.now() / 1000)), numericConstants_1.FIVE_MINUTE)
                : undefined;
            const strictOracle = new strictOraclePrice_1.StrictOraclePrice(oraclePriceData.price, twap5);
            if (isQuote) {
                const tokenAmount = (0, spotBalance_1.getSignedTokenAmount)((0, spotBalance_2.getTokenAmount)(spotPosition.scaledBalance, spotMarket, spotPosition.balanceType), spotPosition.balanceType);
                if ((0, types_1.isVariant)(spotPosition.balanceType, 'deposit')) {
                    // add deposit value to total collateral
                    const weightedTokenValue = this.getSpotAssetValue(tokenAmount, strictOracle, spotMarket, marginCategory);
                    calc.addCrossMarginTotalCollateral(weightedTokenValue);
                }
                else {
                    // borrow on quote contributes to margin requirement
                    const tokenValueAbs = this.getSpotLiabilityValue(tokenAmount, strictOracle, spotMarket, marginCategory, (_h = liquidationBufferMap.get('cross')) !== null && _h !== void 0 ? _h : new anchor_1.BN(0)).abs();
                    calc.addCrossMarginRequirement(tokenValueAbs, tokenValueAbs);
                }
                continue;
            }
            // Non-quote spot: worst-case simulation
            const { tokenAmount: worstCaseTokenAmount, ordersValue: worstCaseOrdersValue, } = (0, spotPosition_1.getWorstCaseTokenAmounts)(spotPosition, spotMarket, strictOracle, marginCategory, userCustomMarginRatio, includeOpenOrders
            // false
            );
            if (includeOpenOrders) {
                // open order IM
                calc.addCrossMarginRequirement(new anchor_1.BN(spotPosition.openOrders).mul(numericConstants_1.OPEN_ORDER_MARGIN_REQUIREMENT), numericConstants_1.ZERO);
            }
            if (worstCaseTokenAmount.gt(numericConstants_1.ZERO)) {
                const baseAssetValue = this.getSpotAssetValue(worstCaseTokenAmount, strictOracle, spotMarket, marginCategory);
                // asset side increases total collateral (weighted)
                calc.addCrossMarginTotalCollateral(baseAssetValue);
            }
            else if (worstCaseTokenAmount.lt(numericConstants_1.ZERO)) {
                // liability side increases margin requirement (weighted >= abs(token_value))
                const getSpotLiabilityValue = this.getSpotLiabilityValue(worstCaseTokenAmount, strictOracle, spotMarket, marginCategory, liquidationBufferMap.get('cross'));
                calc.addCrossMarginRequirement(getSpotLiabilityValue.abs(), getSpotLiabilityValue.abs());
            }
            // orders value contributes to collateral or requirement
            if (worstCaseOrdersValue.gt(numericConstants_1.ZERO)) {
                calc.addCrossMarginTotalCollateral(worstCaseOrdersValue);
            }
            else if (worstCaseOrdersValue.lt(numericConstants_1.ZERO)) {
                const absVal = worstCaseOrdersValue.abs();
                calc.addCrossMarginRequirement(absVal, absVal);
            }
        }
        // PERP POSITIONS
        for (const marketPosition of this.getActivePerpPositions()) {
            const market = this.driftClient.getPerpMarketAccount(marketPosition.marketIndex);
            const quoteSpotMarket = this.driftClient.getSpotMarketAccount(market.quoteSpotMarketIndex);
            const quoteOraclePriceData = this.getOracleDataForSpotMarket(market.quoteSpotMarketIndex);
            const oraclePriceData = this.getMMOracleDataForPerpMarket(market.marketIndex);
            const nonMmmOraclePriceData = this.getOracleDataForPerpMarket(market.marketIndex);
            // Worst-case perp liability and weighted pnl
            const { worstCaseBaseAssetAmount, worstCaseLiabilityValue } = (0, margin_1.calculateWorstCasePerpLiabilityValue)(marketPosition, market, nonMmmOraclePriceData.price, includeOpenOrders);
            // margin ratio for this perp
            const customMarginRatio = Math.max(userCustomMarginRatio, marketPosition.maxMarginRatio);
            let marginRatio = new anchor_1.BN((0, market_1.calculateMarketMarginRatio)(market, worstCaseBaseAssetAmount.abs(), marginCategory, customMarginRatio, this.isHighLeverageMode(marginCategory) || enteringHighLeverage));
            if ((0, types_1.isVariant)(market.status, 'settlement')) {
                marginRatio = numericConstants_1.ZERO;
            }
            // convert liability to quote value and apply margin ratio
            const quotePrice = strict
                ? anchor_1.BN.max(quoteOraclePriceData.price, quoteSpotMarket.historicalOracleData.lastOraclePriceTwap5Min)
                : quoteOraclePriceData.price;
            let perpMarginRequirement = worstCaseLiabilityValue
                .mul(quotePrice)
                .div(numericConstants_1.PRICE_PRECISION)
                .mul(marginRatio)
                .div(numericConstants_1.MARGIN_PRECISION);
            // add open orders IM
            if (includeOpenOrders) {
                perpMarginRequirement = perpMarginRequirement.add(new anchor_1.BN(marketPosition.openOrders).mul(numericConstants_1.OPEN_ORDER_MARGIN_REQUIREMENT));
            }
            // weighted unrealized pnl
            let positionUnrealizedPnl = (0, position_2.calculatePositionPNL)(market, marketPosition, true, oraclePriceData);
            let pnlQuotePrice;
            if (strict && positionUnrealizedPnl.gt(numericConstants_1.ZERO)) {
                pnlQuotePrice = anchor_1.BN.min(quoteOraclePriceData.price, quoteSpotMarket.historicalOracleData.lastOraclePriceTwap5Min);
            }
            else if (strict && positionUnrealizedPnl.lt(numericConstants_1.ZERO)) {
                pnlQuotePrice = anchor_1.BN.max(quoteOraclePriceData.price, quoteSpotMarket.historicalOracleData.lastOraclePriceTwap5Min);
            }
            else {
                pnlQuotePrice = quoteOraclePriceData.price;
            }
            positionUnrealizedPnl = positionUnrealizedPnl
                .mul(pnlQuotePrice)
                .div(numericConstants_1.PRICE_PRECISION);
            if (marginCategory !== undefined) {
                if (positionUnrealizedPnl.gt(numericConstants_1.ZERO)) {
                    positionUnrealizedPnl = positionUnrealizedPnl
                        .mul((0, market_1.calculateUnrealizedAssetWeight)(market, quoteSpotMarket, positionUnrealizedPnl, marginCategory, oraclePriceData))
                        .div(new anchor_1.BN(numericConstants_1.SPOT_MARKET_WEIGHT_PRECISION));
                }
            }
            // Add perp contribution: isolated vs cross
            const isIsolated = this.isPerpPositionIsolated(marketPosition);
            if (isIsolated) {
                // derive isolated quote deposit value, mirroring on-chain logic
                let depositValue = numericConstants_1.ZERO;
                if ((_j = marketPosition.isolatedPositionScaledBalance) === null || _j === void 0 ? void 0 : _j.gt(numericConstants_1.ZERO)) {
                    const quoteSpotMarket = this.driftClient.getSpotMarketAccount(market.quoteSpotMarketIndex);
                    const quoteOraclePriceData = this.getOracleDataForSpotMarket(market.quoteSpotMarketIndex);
                    const strictQuote = new strictOraclePrice_1.StrictOraclePrice(quoteOraclePriceData.price, strict
                        ? quoteSpotMarket.historicalOracleData.lastOraclePriceTwap5Min
                        : undefined);
                    const quoteTokenAmount = (0, spotBalance_2.getTokenAmount)((_k = marketPosition.isolatedPositionScaledBalance) !== null && _k !== void 0 ? _k : numericConstants_1.ZERO, quoteSpotMarket, types_2.SpotBalanceType.DEPOSIT);
                    depositValue = (0, spotBalance_1.getStrictTokenValue)(quoteTokenAmount, quoteSpotMarket.decimals, strictQuote);
                }
                calc.addIsolatedMarginCalculation(market.marketIndex, depositValue, positionUnrealizedPnl, worstCaseLiabilityValue, perpMarginRequirement);
                calc.addPerpLiabilityValue(worstCaseLiabilityValue);
            }
            else {
                // cross: add to global requirement and collateral
                calc.addCrossMarginRequirement(perpMarginRequirement, worstCaseLiabilityValue);
                calc.addCrossMarginTotalCollateral(positionUnrealizedPnl);
            }
        }
        return calc;
    }
    isPerpPositionIsolated(perpPosition) {
        return (perpPosition.positionFlag & types_2.PositionFlag.IsolatedPosition) !== 0;
    }
}
exports.User = User;
