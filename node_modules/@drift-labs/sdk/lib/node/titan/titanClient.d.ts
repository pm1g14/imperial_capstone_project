/// <reference types="bn.js" />
import { Connection, PublicKey, TransactionMessage, AddressLookupTableAccount, TransactionInstruction } from '@solana/web3.js';
import { BN } from '@coral-xyz/anchor';
export declare enum SwapMode {
    ExactIn = "ExactIn",
    ExactOut = "ExactOut"
}
export interface QuoteResponse {
    inputMint: string;
    inAmount: string;
    outputMint: string;
    outAmount: string;
    swapMode: SwapMode;
    slippageBps: number;
    platformFee?: {
        amount?: string;
        feeBps?: number;
    };
    routePlan: Array<{
        swapInfo: any;
        percent: number;
    }>;
    contextSlot?: number;
    timeTaken?: number;
    error?: string;
    errorCode?: string;
}
export declare class TitanClient {
    authToken: string;
    url: string;
    connection: Connection;
    proxyUrl?: string;
    private lastQuoteData?;
    private lastQuoteParams?;
    constructor({ connection, authToken, url, proxyUrl, }: {
        connection: Connection;
        authToken: string;
        url?: string;
        proxyUrl?: string;
    });
    private buildParams;
    /**
     * Get routes for a swap
     */
    getQuote({ inputMint, outputMint, amount, userPublicKey, maxAccounts, // 50 is an estimated amount with buffer
    slippageBps, swapMode, onlyDirectRoutes, excludeDexes, sizeConstraint, accountsLimitWritable, }: {
        inputMint: PublicKey;
        outputMint: PublicKey;
        amount: BN;
        userPublicKey: PublicKey;
        maxAccounts?: number;
        slippageBps?: number;
        swapMode?: string;
        onlyDirectRoutes?: boolean;
        excludeDexes?: string[];
        sizeConstraint?: number;
        accountsLimitWritable?: number;
    }): Promise<QuoteResponse>;
    /**
     * Get a swap transaction for quote
     */
    getSwap({ userPublicKey, }: {
        inputMint?: PublicKey;
        outputMint?: PublicKey;
        amount?: BN;
        userPublicKey: PublicKey;
        maxAccounts?: number;
        slippageBps?: number;
        swapMode?: SwapMode;
        onlyDirectRoutes?: boolean;
        excludeDexes?: string[];
        sizeConstraint?: number;
        accountsLimitWritable?: number;
    }): Promise<{
        transactionMessage: TransactionMessage;
        lookupTables: AddressLookupTableAccount[];
    }>;
    /**
     * Get the titan instructions from transaction by filtering out instructions to compute budget and associated token programs
     * @param transactionMessage the transaction message
     * @param inputMint the input mint
     * @param outputMint the output mint
     */
    getTitanInstructions({ transactionMessage, inputMint, outputMint, }: {
        transactionMessage: TransactionMessage;
        inputMint: PublicKey;
        outputMint: PublicKey;
    }): TransactionInstruction[];
    private getTransactionMessageAndLookupTables;
}
//# sourceMappingURL=titanClient.d.ts.map