{"version":3,"sources":["../src/programs/token/addresses.ts","../src/programs/token-metadata/generated/types/collection.ts","../src/programs/token-metadata/generated/types/collectionDetails.ts","../src/programs/token-metadata/generated/types/creator.ts","../src/programs/token-metadata/generated/types/dataV2.ts","../src/programs/token-metadata/generated/types/uses.ts","../src/programs/token-metadata/generated/types/useMethod.ts","../src/programs/token-metadata/generated/programs/tokenMetadata.ts","../src/programs/shared/index.ts","../src/programs/token-metadata/generated/instructions/createMetadataAccountV3.ts","../src/programs/token-metadata/addresses.ts","../src/programs/token/instructions/create-token.ts","../src/programs/token/instructions/mint-tokens.ts","../src/programs/token/instructions/transfer-tokens.ts","../src/programs/token/transactions/create-token.ts","../src/programs/token/transactions/mint-tokens.ts","../src/programs/token/transactions/transfer-tokens.ts","../src/programs/token/ui-amount.ts"],"names":["getStructEncoder","getStructDecoder","combineCodec","getAddressEncoder","getBooleanEncoder","getAddressDecoder","getBooleanDecoder","getU64Encoder","getU64Decoder","UseMethod","TokenMetadataAccount","TokenMetadataInstruction","web3JsIsTransactionSigner","getU8Encoder","getOptionEncoder","getU8Decoder","getOptionDecoder","TOKEN_2022_PROGRAM_ADDRESS","getCreateAssociatedTokenIdempotentInstruction","feePayer"],"mappings":"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","file":"chunk-7WVXYP7X.node.mjs","sourcesContent":["import { findAssociatedTokenPda, TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport { isAddress, type Address, type TransactionSigner } from \"@solana/kit\";\nimport { checkedAddress } from \"../../core/utils\";\n\nexport type LegacyTokenProgramMonikers = \"legacy\" | \"token\";\n\nexport type TokenExtensionProgramMonikers = \"token22\" | \"tokenExtension\" | \"tokenExtensions\" | \"token2022\";\n\nexport type TokenProgramMonikers = LegacyTokenProgramMonikers | TokenExtensionProgramMonikers;\n\nexport const TOKEN_PROGRAM_ADDRESS =\n  \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\" as Address<\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\">;\n\n/**\n * Derive the associated token account (ata) address for an owner and mint/tokenProgram\n *\n * @argument `mint` - the token mint itself\n * @argument `owner` - destination wallet address to own tokens from `mint`\n * @argument `tokenProgram` - token program that the token `mint` was created with\n *\n * - (default) {@link TOKEN_PROGRAM_ADDRESS} - the original SPL Token Program\n * - {@link TOKEN_2022_PROGRAM_ADDRESS} - the SPL Token Extensions Program (aka Token22)\n */\nexport async function getAssociatedTokenAccountAddress(\n  mint: Address | TransactionSigner,\n  owner: Address | TransactionSigner,\n  tokenProgram?: Address,\n): Promise<Address> {\n  return (\n    await findAssociatedTokenPda({\n      mint: checkedAddress(mint),\n      owner: checkedAddress(owner),\n      tokenProgram: checkedTokenProgramAddress(tokenProgram),\n    })\n  )[0];\n}\n\nexport function parseTokenProgramAddressOrMoniker(tokenProgram: Address | TokenProgramMonikers): Address {\n  if (!isAddress(tokenProgram)) {\n    tokenProgram = tokenProgram.toLowerCase() as TokenProgramMonikers;\n  }\n  switch (tokenProgram) {\n    case \"legacy\":\n    case \"token\":\n    case TOKEN_PROGRAM_ADDRESS: {\n      return TOKEN_PROGRAM_ADDRESS;\n    }\n    case \"token22\":\n    case \"token2022\":\n    case \"tokenextension\":\n    case \"tokenextensions\":\n    case TOKEN_2022_PROGRAM_ADDRESS: {\n      return TOKEN_2022_PROGRAM_ADDRESS;\n    }\n    default:\n      throw Error(\"Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'\");\n  }\n}\n\nexport function assertIsSupportedTokenProgram(\n  tokenProgram: Address,\n): asserts tokenProgram is Address<typeof tokenProgram> {\n  if (tokenProgram !== TOKEN_PROGRAM_ADDRESS && tokenProgram !== TOKEN_2022_PROGRAM_ADDRESS) {\n    throw Error(\"Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'\");\n  }\n}\n\n/**\n * Check the provided program is one of the supported token programs.\n * Including setting the default to {@link TOKEN_PROGRAM_ADDRESS} (the original SPL token program)\n *\n * @example\n * ```\n * args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n * ```\n */\nexport function checkedTokenProgramAddress(tokenProgram?: Address | TokenProgramMonikers): Address {\n  if (!tokenProgram) return TOKEN_PROGRAM_ADDRESS;\n  tokenProgram = parseTokenProgramAddressOrMoniker(tokenProgram);\n  assertIsSupportedTokenProgram(tokenProgram);\n  return tokenProgram;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from \"@solana/kit\";\n\nexport type Collection = { verified: boolean; key: Address };\n\nexport type CollectionArgs = Collection;\n\nexport function getCollectionEncoder(): Encoder<CollectionArgs> {\n  return getStructEncoder([\n    [\"verified\", getBooleanEncoder()],\n    [\"key\", getAddressEncoder()],\n  ]);\n}\n\nexport function getCollectionDecoder(): Decoder<Collection> {\n  return getStructDecoder([\n    [\"verified\", getBooleanDecoder()],\n    [\"key\", getAddressDecoder()],\n  ]);\n}\n\nexport function getCollectionCodec(): Codec<CollectionArgs, Collection> {\n  return combineCodec(getCollectionEncoder(), getCollectionDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport type CollectionDetails =\n  | { __kind: 'V1'; size: bigint }\n  | { __kind: 'V2'; padding: ReadonlyUint8Array };\n\nexport type CollectionDetailsArgs =\n  | { __kind: 'V1'; size: number | bigint }\n  | { __kind: 'V2'; padding: ReadonlyUint8Array };\n\nexport function getCollectionDetailsEncoder(): Encoder<CollectionDetailsArgs> {\n  return getDiscriminatedUnionEncoder([\n    ['V1', getStructEncoder([['size', getU64Encoder()]])],\n    [\n      'V2',\n      getStructEncoder([['padding', fixEncoderSize(getBytesEncoder(), 8)]]),\n    ],\n  ]);\n}\n\nexport function getCollectionDetailsDecoder(): Decoder<CollectionDetails> {\n  return getDiscriminatedUnionDecoder([\n    ['V1', getStructDecoder([['size', getU64Decoder()]])],\n    [\n      'V2',\n      getStructDecoder([['padding', fixDecoderSize(getBytesDecoder(), 8)]]),\n    ],\n  ]);\n}\n\nexport function getCollectionDetailsCodec(): Codec<\n  CollectionDetailsArgs,\n  CollectionDetails\n> {\n  return combineCodec(\n    getCollectionDetailsEncoder(),\n    getCollectionDetailsDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function collectionDetails(\n  kind: 'V1',\n  data: GetDiscriminatedUnionVariantContent<\n    CollectionDetailsArgs,\n    '__kind',\n    'V1'\n  >\n): GetDiscriminatedUnionVariant<CollectionDetailsArgs, '__kind', 'V1'>;\nexport function collectionDetails(\n  kind: 'V2',\n  data: GetDiscriminatedUnionVariantContent<\n    CollectionDetailsArgs,\n    '__kind',\n    'V2'\n  >\n): GetDiscriminatedUnionVariant<CollectionDetailsArgs, '__kind', 'V2'>;\nexport function collectionDetails<\n  K extends CollectionDetailsArgs['__kind'],\n  Data,\n>(kind: K, data?: Data) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isCollectionDetails<K extends CollectionDetails['__kind']>(\n  kind: K,\n  value: CollectionDetails\n): value is CollectionDetails & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport type Creator = { address: Address; verified: boolean; share: number };\n\nexport type CreatorArgs = Creator;\n\nexport function getCreatorEncoder(): Encoder<CreatorArgs> {\n  return getStructEncoder([\n    ['address', getAddressEncoder()],\n    ['verified', getBooleanEncoder()],\n    ['share', getU8Encoder()],\n  ]);\n}\n\nexport function getCreatorDecoder(): Decoder<Creator> {\n  return getStructDecoder([\n    ['address', getAddressDecoder()],\n    ['verified', getBooleanDecoder()],\n    ['share', getU8Decoder()],\n  ]);\n}\n\nexport function getCreatorCodec(): Codec<CreatorArgs, Creator> {\n  return combineCodec(getCreatorEncoder(), getCreatorDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getCollectionDecoder,\n  getCollectionEncoder,\n  getCreatorDecoder,\n  getCreatorEncoder,\n  getUsesDecoder,\n  getUsesEncoder,\n  type Collection,\n  type CollectionArgs,\n  type Creator,\n  type CreatorArgs,\n  type Uses,\n  type UsesArgs,\n} from '.';\n\nexport type DataV2 = {\n  name: string;\n  symbol: string;\n  uri: string;\n  sellerFeeBasisPoints: number;\n  creators: Option<Array<Creator>>;\n  collection: Option<Collection>;\n  uses: Option<Uses>;\n};\n\nexport type DataV2Args = {\n  name: string;\n  symbol: string;\n  uri: string;\n  sellerFeeBasisPoints: number;\n  creators: OptionOrNullable<Array<CreatorArgs>>;\n  collection: OptionOrNullable<CollectionArgs>;\n  uses: OptionOrNullable<UsesArgs>;\n};\n\nexport function getDataV2Encoder(): Encoder<DataV2Args> {\n  return getStructEncoder([\n    ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ['sellerFeeBasisPoints', getU16Encoder()],\n    ['creators', getOptionEncoder(getArrayEncoder(getCreatorEncoder()))],\n    ['collection', getOptionEncoder(getCollectionEncoder())],\n    ['uses', getOptionEncoder(getUsesEncoder())],\n  ]);\n}\n\nexport function getDataV2Decoder(): Decoder<DataV2> {\n  return getStructDecoder([\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['sellerFeeBasisPoints', getU16Decoder()],\n    ['creators', getOptionDecoder(getArrayDecoder(getCreatorDecoder()))],\n    ['collection', getOptionDecoder(getCollectionDecoder())],\n    ['uses', getOptionDecoder(getUsesDecoder())],\n  ]);\n}\n\nexport function getDataV2Codec(): Codec<DataV2Args, DataV2> {\n  return combineCodec(getDataV2Encoder(), getDataV2Decoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\nimport {\n  getUseMethodDecoder,\n  getUseMethodEncoder,\n  type UseMethod,\n  type UseMethodArgs,\n} from '.';\n\nexport type Uses = { useMethod: UseMethod; remaining: bigint; total: bigint };\n\nexport type UsesArgs = {\n  useMethod: UseMethodArgs;\n  remaining: number | bigint;\n  total: number | bigint;\n};\n\nexport function getUsesEncoder(): Encoder<UsesArgs> {\n  return getStructEncoder([\n    ['useMethod', getUseMethodEncoder()],\n    ['remaining', getU64Encoder()],\n    ['total', getU64Encoder()],\n  ]);\n}\n\nexport function getUsesDecoder(): Decoder<Uses> {\n  return getStructDecoder([\n    ['useMethod', getUseMethodDecoder()],\n    ['remaining', getU64Decoder()],\n    ['total', getU64Decoder()],\n  ]);\n}\n\nexport function getUsesCodec(): Codec<UsesArgs, Uses> {\n  return combineCodec(getUsesEncoder(), getUsesDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum UseMethod {\n  Burn,\n  Multiple,\n  Single,\n}\n\nexport type UseMethodArgs = UseMethod;\n\nexport function getUseMethodEncoder(): Encoder<UseMethodArgs> {\n  return getEnumEncoder(UseMethod);\n}\n\nexport function getUseMethodDecoder(): Decoder<UseMethod> {\n  return getEnumDecoder(UseMethod);\n}\n\nexport function getUseMethodCodec(): Codec<UseMethodArgs, UseMethod> {\n  return combineCodec(getUseMethodEncoder(), getUseMethodDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport { type Address } from \"@solana/kit\";\n\nexport const TOKEN_METADATA_PROGRAM_ADDRESS =\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\" as Address<\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\">;\n\nexport enum TokenMetadataAccount {\n  CollectionAuthorityRecord,\n  MetadataDelegateRecord,\n  HolderDelegateRecord,\n  Edition,\n  EditionMarker,\n  EditionMarkerV2,\n  TokenOwnedEscrow,\n  MasterEditionV2,\n  MasterEditionV1,\n  Metadata,\n  TokenRecord,\n  ReservationListV2,\n  ReservationListV1,\n  UseAuthorityRecord,\n}\n\nexport enum TokenMetadataInstruction {\n  CreateMetadataAccount,\n  UpdateMetadataAccount,\n  DeprecatedCreateMasterEdition,\n  DeprecatedMintNewEditionFromMasterEditionViaPrintingToken,\n  UpdatePrimarySaleHappenedViaToken,\n  DeprecatedSetReservationList,\n  DeprecatedCreateReservationList,\n  SignMetadata,\n  DeprecatedMintPrintingTokensViaToken,\n  DeprecatedMintPrintingTokens,\n  CreateMasterEdition,\n  MintNewEditionFromMasterEditionViaToken,\n  ConvertMasterEditionV1ToV2,\n  MintNewEditionFromMasterEditionViaVaultProxy,\n  PuffMetadata,\n  UpdateMetadataAccountV2,\n  CreateMetadataAccountV2,\n  CreateMasterEditionV3,\n  VerifyCollection,\n  Utilize,\n  ApproveUseAuthority,\n  RevokeUseAuthority,\n  UnverifyCollection,\n  ApproveCollectionAuthority,\n  RevokeCollectionAuthority,\n  SetAndVerifyCollection,\n  FreezeDelegatedAccount,\n  ThawDelegatedAccount,\n  RemoveCreatorVerification,\n  BurnNft,\n  VerifySizedCollectionItem,\n  UnverifySizedCollectionItem,\n  SetAndVerifySizedCollectionItem,\n  CreateMetadataAccountV3,\n  SetCollectionSize,\n  SetTokenStandard,\n  BubblegumSetCollectionSize,\n  BurnEditionNft,\n  CreateEscrowAccount,\n  CloseEscrowAccount,\n  TransferOutOfEscrow,\n  Burn,\n  Create,\n  Mint,\n  Delegate,\n  Revoke,\n  Lock,\n  Unlock,\n  Migrate,\n  Transfer,\n  Update,\n  Use,\n  Verify,\n  Unverify,\n  Collect,\n  Print,\n  Resize,\n  CloseAccounts,\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * And vendored in from various codama generated client to help\n * minimize redundancy and bundle sizes\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport { isProgramDerivedAddress, type Address, type ProgramDerivedAddress } from \"@solana/kit\";\nimport { AccountRole, type IAccountMeta, upgradeRoleToSigner } from \"@solana/kit\";\nimport {\n  isTransactionSigner as web3JsIsTransactionSigner,\n  type IAccountSignerMeta,\n  type TransactionSigner,\n} from \"@solana/kit\";\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error(\"Expected a value but received null or undefined.\");\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined,\n): Address<T> {\n  if (!value) {\n    throw new Error(\"Expected a Address.\");\n  }\n  if (typeof value === \"object\" && \"address\" in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined,\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error(\"Expected a ProgramDerivedAddress.\");\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined,\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error(\"Expected a TransactionSigner.\");\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(programAddress: Address, optionalAccountStrategy: \"omitted\" | \"programId\") {\n  return (account: ResolvedAccount): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === \"omitted\") return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value: Address<TAddress> | ProgramDerivedAddress<TAddress> | TransactionSigner<TAddress>,\n): value is TransactionSigner<TAddress> {\n  return !!value && typeof value === \"object\" && \"address\" in value && web3JsIsTransactionSigner(value);\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n} from \"@solana/codecs\";\nimport type {\n  Address,\n  IAccountMeta,\n  IAccountSignerMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n  ReadonlySignerAccount,\n  TransactionSigner,\n  WritableAccount,\n  WritableSignerAccount,\n} from \"@solana/kit\";\n\nimport { getAccountMetaFactory, type ResolvedAccount } from \"../../../shared\";\nimport { TOKEN_METADATA_PROGRAM_ADDRESS } from \"../programs\";\nimport {\n  getCollectionDetailsDecoder,\n  getCollectionDetailsEncoder,\n  getDataV2Decoder,\n  getDataV2Encoder,\n  type CollectionDetails,\n  type CollectionDetailsArgs,\n  type DataV2,\n  type DataV2Args,\n} from \"../types\";\n\nexport const CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR = 33;\n\nexport function getCreateMetadataAccountV3DiscriminatorBytes(): ReadonlyUint8Array {\n  return getU8Encoder().encode(CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR);\n}\n\nexport type CreateMetadataAccountV3Instruction<\n  TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends string | IAccountMeta<string> = \"11111111111111111111111111111111\",\n  TAccountRent extends string | IAccountMeta<string> | undefined = undefined,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string ? WritableAccount<TAccountMetadata> : TAccountMetadata,\n      TAccountMint extends string ? ReadonlyAccount<TAccountMint> : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> & IAccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> & IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountUpdateAuthority extends string ? ReadonlyAccount<TAccountUpdateAuthority> : TAccountUpdateAuthority,\n      TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram,\n      ...(TAccountRent extends undefined\n        ? []\n        : [TAccountRent extends string ? ReadonlyAccount<TAccountRent> : TAccountRent]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateMetadataAccountV3InstructionData = {\n  discriminator: number;\n  data: DataV2;\n  isMutable: boolean;\n  collectionDetails: Option<CollectionDetails>;\n};\n\nexport type CreateMetadataAccountV3InstructionDataArgs = {\n  data: DataV2Args;\n  isMutable: boolean;\n  collectionDetails: OptionOrNullable<CollectionDetailsArgs>;\n};\n\nexport function getCreateMetadataAccountV3InstructionDataEncoder(): Encoder<CreateMetadataAccountV3InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"data\", getDataV2Encoder()],\n      [\"isMutable\", getBooleanEncoder()],\n      [\"collectionDetails\", getOptionEncoder(getCollectionDetailsEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR,\n    }),\n  );\n}\n\nexport function getCreateMetadataAccountV3InstructionDataDecoder(): Decoder<CreateMetadataAccountV3InstructionData> {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"data\", getDataV2Decoder()],\n    [\"isMutable\", getBooleanDecoder()],\n    [\"collectionDetails\", getOptionDecoder(getCollectionDetailsDecoder())],\n  ]);\n}\n\nexport function getCreateMetadataAccountV3InstructionDataCodec(): Codec<\n  CreateMetadataAccountV3InstructionDataArgs,\n  CreateMetadataAccountV3InstructionData\n> {\n  return combineCodec(\n    getCreateMetadataAccountV3InstructionDataEncoder(),\n    getCreateMetadataAccountV3InstructionDataDecoder(),\n  );\n}\n\nexport type CreateMetadataAccountV3Input<\n  TAccountMetadata extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n  TAccountPayer extends string = string,\n  TAccountUpdateAuthority extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** Metadata key (pda of ['metadata', program id, mint id]) */\n  metadata: Address<TAccountMetadata>;\n  /** Mint of token asset */\n  mint: Address<TAccountMint>;\n  /** Mint authority */\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  /** payer */\n  payer: TransactionSigner<TAccountPayer>;\n  /** update authority info */\n  updateAuthority: Address<TAccountUpdateAuthority> | TransactionSigner<TAccountUpdateAuthority>;\n  /** System program */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** Rent info */\n  rent?: Address<TAccountRent>;\n  data: CreateMetadataAccountV3InstructionDataArgs[\"data\"];\n  isMutable: CreateMetadataAccountV3InstructionDataArgs[\"isMutable\"];\n  collectionDetails: CreateMetadataAccountV3InstructionDataArgs[\"collectionDetails\"];\n};\n\nexport function getCreateMetadataAccountV3Instruction<\n  TAccountMetadata extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TAccountPayer extends string,\n  TAccountUpdateAuthority extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_METADATA_PROGRAM_ADDRESS,\n>(\n  input: CreateMetadataAccountV3Input<\n    TAccountMetadata,\n    TAccountMint,\n    TAccountMintAuthority,\n    TAccountPayer,\n    TAccountUpdateAuthority,\n    TAccountSystemProgram,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress },\n): CreateMetadataAccountV3Instruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountMint,\n  TAccountMintAuthority,\n  TAccountPayer,\n  (typeof input)[\"updateAuthority\"] extends TransactionSigner<TAccountUpdateAuthority>\n    ? ReadonlySignerAccount<TAccountUpdateAuthority> & IAccountSignerMeta<TAccountUpdateAuthority>\n    : TAccountUpdateAuthority,\n  TAccountSystemProgram,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_METADATA_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value = \"11111111111111111111111111111111\" as Address<\"11111111111111111111111111111111\">;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, \"omitted\");\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.updateAuthority),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    programAddress,\n    data: getCreateMetadataAccountV3InstructionDataEncoder().encode(args as CreateMetadataAccountV3InstructionDataArgs),\n  } as CreateMetadataAccountV3Instruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountMint,\n    TAccountMintAuthority,\n    TAccountPayer,\n    (typeof input)[\"updateAuthority\"] extends TransactionSigner<TAccountUpdateAuthority>\n      ? ReadonlySignerAccount<TAccountUpdateAuthority> & IAccountSignerMeta<TAccountUpdateAuthority>\n      : TAccountUpdateAuthority,\n    TAccountSystemProgram,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateMetadataAccountV3Instruction<\n  TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Metadata key (pda of ['metadata', program id, mint id]) */\n    metadata: TAccountMetas[0];\n    /** Mint of token asset */\n    mint: TAccountMetas[1];\n    /** Mint authority */\n    mintAuthority: TAccountMetas[2];\n    /** payer */\n    payer: TAccountMetas[3];\n    /** update authority info */\n    updateAuthority: TAccountMetas[4];\n    /** System program */\n    systemProgram: TAccountMetas[5];\n    /** Rent info */\n    rent?: TAccountMetas[6] | undefined;\n  };\n  data: CreateMetadataAccountV3InstructionData;\n};\n\nexport function parseCreateMetadataAccountV3Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> & IInstructionWithAccounts<TAccountMetas> & IInstructionWithData<Uint8Array>,\n): ParsedCreateMetadataAccountV3Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 6;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n      payer: getNextAccount(),\n      updateAuthority: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextOptionalAccount(),\n    },\n    data: getCreateMetadataAccountV3InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import { type Address, type KeyPairSigner, getAddressEncoder, getProgramDerivedAddress } from \"@solana/kit\";\nimport { checkedAddress } from \"../../core/utils\";\nimport { TOKEN_METADATA_PROGRAM_ADDRESS } from \"./generated\";\n\n/**\n * Derive the Token Metadata address from a token's mint address\n *\n * @param `mint` - `Address` or `KeyPairSigner` of the token mint\n */\nexport async function getTokenMetadataAddress(mint: Address | KeyPairSigner): Promise<Address> {\n  return (\n    await getProgramDerivedAddress({\n      programAddress: TOKEN_METADATA_PROGRAM_ADDRESS,\n      seeds: [\n        Buffer.from(\"metadata\"),\n        getAddressEncoder().encode(TOKEN_METADATA_PROGRAM_ADDRESS),\n        getAddressEncoder().encode(checkedAddress(mint)),\n      ],\n    })\n  )[0];\n}\n","import { getCreateAccountInstruction } from \"@solana-program/system\";\nimport type { Address, IInstruction, KeyPairSigner, TransactionSigner } from \"@solana/kit\";\nimport { checkedAddress, checkedTransactionSigner, getMinimumBalanceForRentExemption } from \"../../../core\";\nimport { getCreateMetadataAccountV3Instruction, getTokenMetadataAddress } from \"../../token-metadata\";\n\nimport {\n  extension,\n  getInitializeMetadataPointerInstruction,\n  getInitializeMintInstruction,\n  getInitializeTokenMetadataInstruction,\n  getMintSize,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { checkedTokenProgramAddress } from \"../addresses\";\nimport type { TokenInstructionBase } from \"./types\";\n\nexport type GetCreateTokenInstructionsArgs = TokenInstructionBase<KeyPairSigner> & {\n  /**\n   * The number of decimal places this token should have\n   *\n   * @default `9` - the most commonly used decimals value\n   **/\n  decimals?: bigint | number;\n  /**\n   * Authority address that is allowed to mint new tokens\n   *\n   * When not provided, defaults to: `feePayer`\n   **/\n  mintAuthority?: TransactionSigner;\n  /**\n   * Authority address that is able to freeze (and thaw) user owned token accounts.\n   * When a user's token account is frozen, they will not be able to transfer their tokens.\n   *\n   * When not provided, defaults to: `null`\n   **/\n  freezeAuthority?: Address | TransactionSigner;\n  /**\n   * Authority address that is allowed to update the metadata\n   *\n   * When not provided, defaults to: `feePayer`\n   **/\n  updateAuthority?: TransactionSigner;\n  /**\n   * Optional (but highly recommended) metadata to attach to this token\n   */\n  metadata: {\n    /** Name of this token */\n    name: string;\n    /** Symbol for this token */\n    symbol: string;\n    /** URI pointing to additional metadata for this token. Typically an offchain json file. */\n    uri: string;\n    /** Whether or not the onchain metadata will be editable after minting */\n    isMutable: boolean;\n  };\n  /**\n   * Metadata address for this token\n   *\n   * @example\n   * For `TOKEN_PROGRAM_ADDRESS` use the {@link getTokenMetadataAddress} function:\n   * ```\n   * metadataAddress: await getTokenMetadataAddress(mint.address);\n   * ```\n   *\n   * @example\n   * For `TOKEN_2022_PROGRAM_ADDRESS` use the mint's address:\n   * ```\n   * metadataAddress: mint.address;\n   * ```\n   * */\n  metadataAddress: Address;\n  // extensions // todo\n};\n\n/**\n * Create the instructions required to initialize a new token's mint\n */\nexport function getCreateTokenInstructions(args: GetCreateTokenInstructionsArgs): IInstruction[] {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n\n  if (args.decimals == null) args.decimals = 9;\n  if (!args.mintAuthority) args.mintAuthority = args.feePayer;\n  if (!args.updateAuthority) args.updateAuthority = args.feePayer;\n  if (args.freezeAuthority) args.freezeAuthority = checkedAddress(args.freezeAuthority);\n\n  if (args.tokenProgram === TOKEN_2022_PROGRAM_ADDRESS) {\n    const metadataPointer = extension(\"MetadataPointer\", {\n      metadataAddress: args.mint.address,\n      authority: args.updateAuthority.address,\n    });\n\n    const metadataExtensionData = extension(\"TokenMetadata\", {\n      updateAuthority: args.updateAuthority.address,\n      mint: args.mint.address,\n      name: args.metadata.name,\n      symbol: args.metadata.symbol,\n      uri: args.metadata.uri,\n      // todo: support token22 additional metadata\n      additionalMetadata: new Map(),\n    });\n\n    return [\n      getCreateAccountInstruction({\n        payer: args.feePayer,\n        newAccount: args.mint,\n        /**\n         * token22 requires only the pre-mint-initialization extensions (like metadata pointer)\n         * to be the `space`. then it will extend the account's space for each applicable extension\n         * */\n        space: BigInt(getMintSize([metadataPointer])),\n        /**\n         * token22 requires the total lamport balance for all extensions,\n         * including pre-initialization and post-initialization\n         */\n        lamports: getMinimumBalanceForRentExemption(BigInt(getMintSize([metadataPointer, metadataExtensionData]))),\n        programAddress: args.tokenProgram,\n      }),\n      getInitializeMetadataPointerInstruction({\n        authority: args.mintAuthority.address,\n        metadataAddress: args.metadataAddress,\n        mint: args.mint.address,\n      }),\n      getInitializeMintInstruction(\n        {\n          mint: args.mint.address,\n          decimals: Number(args.decimals),\n          mintAuthority: args.mintAuthority.address,\n          freezeAuthority: args.freezeAuthority || null,\n        },\n        {\n          programAddress: args.tokenProgram,\n        },\n      ),\n      getInitializeTokenMetadataInstruction({\n        metadata: args.mint.address,\n        mint: args.mint.address,\n        mintAuthority: args.mintAuthority,\n        name: args.metadata.name,\n        symbol: args.metadata.symbol,\n        uri: args.metadata.uri,\n        updateAuthority: args.updateAuthority.address,\n      }),\n      // todo: support token22 additional metadata by adding that instruction(s) here\n    ];\n  } else {\n    // the token22 `getMintSize` is fully compatible with the original token program\n    const space: bigint = BigInt(getMintSize());\n\n    return [\n      getCreateAccountInstruction({\n        payer: args.feePayer,\n        newAccount: args.mint,\n        lamports: getMinimumBalanceForRentExemption(space),\n        space,\n        programAddress: args.tokenProgram,\n      }),\n      getInitializeMintInstruction(\n        {\n          mint: args.mint.address,\n          decimals: Number(args.decimals),\n          mintAuthority: args.mintAuthority.address,\n          freezeAuthority: args.freezeAuthority || null,\n        },\n        {\n          programAddress: args.tokenProgram,\n        },\n      ),\n      getCreateMetadataAccountV3Instruction({\n        metadata: args.metadataAddress,\n        mint: args.mint.address,\n        mintAuthority: args.mintAuthority,\n        payer: args.feePayer,\n        updateAuthority: args.updateAuthority,\n        data: {\n          name: args.metadata.name,\n          symbol: args.metadata.symbol,\n          uri: args.metadata.uri,\n          sellerFeeBasisPoints: 0,\n          creators: null,\n          collection: null,\n          uses: null,\n        },\n        isMutable: args.metadata.isMutable,\n        collectionDetails: null,\n      }),\n    ];\n  }\n}\n","import type { Address, IInstruction, TransactionSigner } from \"@solana/kit\";\n\nimport { getCreateAssociatedTokenIdempotentInstruction, getMintToInstruction } from \"@solana-program/token-2022\";\nimport { checkedAddress, checkedTransactionSigner } from \"../../../core\";\nimport { checkedTokenProgramAddress } from \"../addresses\";\nimport type { TokenInstructionBase } from \"./types\";\n\nexport type GetMintTokensInstructionsArgs = TokenInstructionBase & {\n  /**\n   * The authority address capable of authorizing minting of new tokens.\n   *\n   * - this should normally by a `TransactionSigner`\n   * - only for multi-sig authorities (like Squads Protocol), should you supply an `Address`\n   * */\n  mintAuthority: TransactionSigner | Address;\n  /** Wallet address to receive the tokens being minted, via their associated token account (ata) */\n  destination: TransactionSigner | Address;\n  /**\n   * Associated token account (ata) address for `destination` and this `mint`\n   *\n   * See {@link getAssociatedTokenAccountAddress}\n   *\n   * @example\n   * ```\n   * getAssociatedTokenAccountAddress(mint, destination, tokenProgram);\n   * ```\n   * */\n  ata: Address;\n  /** Amount of tokens to mint to the `owner` via their `ata` */\n  amount: bigint | number;\n};\n\n/**\n * Create the instructions required to mint tokens to any wallet/owner,\n * including creating their ATA if it does not exist\n *\n * @example\n *\n * ```\n * const mint = await generateKeyPairSigner();\n * const destination = address(\"nicktrLHhYzLmoVbuZQzHUTicd2sfP571orwo9jfc8c\");\n *\n * const instructions = getMintTokensInstructions({\n *   mint,\n *   feePayer: signer,\n *   mintAuthority: signer,\n *   amount: 1000, // note: be sure to consider the mint's `decimals` value\n *   // if decimals=2 => this will mint 10.00 tokens\n *   // if decimals=4 => this will mint 0.100 tokens\n *   destination,\n *   // be sure to set the correct token program when getting the `ata`\n *   ata: await getAssociatedTokenAccountAddress(mint, destination, tokenProgram),\n *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default\n *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n * });\n * ```\n */\nexport function getMintTokensInstructions(args: GetMintTokensInstructionsArgs): IInstruction[] {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  return [\n    // create idempotent will gracefully fail if the ata already exists. this is the gold standard!\n    getCreateAssociatedTokenIdempotentInstruction({\n      owner: checkedAddress(args.destination),\n      mint: args.mint,\n      ata: args.ata,\n      payer: args.feePayer,\n      tokenProgram: args.tokenProgram,\n    }),\n    getMintToInstruction(\n      {\n        mint: args.mint,\n        mintAuthority: args.mintAuthority,\n        token: args.ata,\n        amount: args.amount,\n      },\n      {\n        programAddress: args.tokenProgram,\n      },\n    ),\n  ];\n}\n","import type { Address, IInstruction, TransactionSigner } from \"@solana/kit\";\n\nimport { getCreateAssociatedTokenIdempotentInstruction, getTransferInstruction } from \"@solana-program/token-2022\";\nimport { checkedAddress, checkedTransactionSigner } from \"../../../core\";\nimport { checkedTokenProgramAddress } from \"../addresses\";\nimport type { TokenInstructionBase } from \"./types\";\n\nexport type GetTransferTokensInstructionsArgs = TokenInstructionBase & {\n  /**\n   * The source account's owner/delegate or its multi-signature account:\n   * - this should normally by a `TransactionSigner`\n   * - only for multi-sig authorities (like Squads Protocol), should you supply an `Address`\n   * */\n  authority: TransactionSigner | Address;\n  /**\n   * Associated token account (ata) address for `authority` and this `mint`\n   *\n   * See {@link getAssociatedTokenAccountAddress}\n   *\n   * @example\n   * ```\n   * getAssociatedTokenAccountAddress(mint, authority, tokenProgram);\n   * ```\n   * */\n  sourceAta: Address;\n  /** Wallet address to receive the tokens, via their associated token account: `destinationAta` */\n  destination: TransactionSigner | Address;\n  /**\n   * Associated token account (ata) address for `destination` and this `mint`\n   *\n   * See {@link getAssociatedTokenAccountAddress}\n   *\n   * @example\n   * ```\n   * getAssociatedTokenAccountAddress(mint, destination, tokenProgram);\n   * ```\n   * */\n  destinationAta: Address;\n  /** Amount of tokens to be transferred to the `destination` via their `destinationAta` */\n  amount: bigint | number;\n};\n\n/**\n * Create the instructions required to transfer tokens from one wallet to another,\n * including creating the destination ATA if it does not exist\n *\n * @example\n *\n * ```\n * const sourceAta = await getAssociatedTokenAccountAddress(mint, authority, tokenProgram);\n *\n * const destination = address(...);\n * const destinationAta = await getAssociatedTokenAccountAddress(mint, destination, tokenProgram);\n *\n * const instructions = getTransferTokensInstructions({\n *    feePayer: signer,\n *    mint,\n *    amount: 10,\n *    authority: signer, // the source wallet for the tokens to be transferred\n *    sourceAta, // normally derived from the `authority`\n *    destination,\n *    destinationAta, // derived from the `destination`\n *    tokenProgram,\n * });\n * ```\n */\nexport function getTransferTokensInstructions(args: GetTransferTokensInstructionsArgs): IInstruction[] {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  return [\n    // create idempotent will gracefully fail if the ata already exists. this is the gold standard!\n    getCreateAssociatedTokenIdempotentInstruction({\n      owner: checkedAddress(args.destination),\n      mint: args.mint,\n      ata: args.destinationAta,\n      payer: args.feePayer,\n      tokenProgram: args.tokenProgram,\n    }),\n    getTransferInstruction(\n      {\n        authority: args.authority,\n        source: args.sourceAta,\n        destination: args.destinationAta,\n        amount: args.amount,\n      },\n      {\n        programAddress: args.tokenProgram,\n      },\n    ),\n  ];\n}\n","import { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport type {\n  ITransactionMessageWithFeePayer,\n  KeyPairSigner,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport { checkedTransactionSigner, createTransaction } from \"../../../core\";\nimport type { FullTransaction, Simplify } from \"../../../types\";\nimport { getTokenMetadataAddress } from \"../../token-metadata\";\nimport { checkedTokenProgramAddress, TOKEN_PROGRAM_ADDRESS } from \"../addresses\";\nimport { getCreateTokenInstructions, type GetCreateTokenInstructionsArgs } from \"../instructions/create-token\";\nimport type { TransactionBuilderInput } from \"./types\";\n\ntype GetCreateTokenTransactionInput = Simplify<\n  Omit<GetCreateTokenInstructionsArgs, \"metadataAddress\"> &\n    Partial<Pick<GetCreateTokenInstructionsArgs, \"metadataAddress\">>\n>;\n\n/**\n * Create a transaction that can create a token with metadata\n *\n * The transaction has the following defaults:\n * - Default `version` = `legacy`\n * - Default `computeUnitLimit`:\n *    - for TOKEN_PROGRAM_ADDRESS => `60_000`\n *    - for TOKEN_2022_PROGRAM_ADDRESS => `10_000`\n *\n * @example\n *\n * ```\n * const mint = await generateKeyPairSigner();\n *\n * const transaction = await buildCreateTokenTransaction({\n *   feePayer: signer,\n *   latestBlockhash,\n *   mint,\n *   metadata: {\n *     name: \"Test Token\",\n *     symbol: \"TEST\",\n *     uri: \"https://example.com/metadata.json\",\n *     isMutable: true,\n *   },\n *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default\n *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n * });\n * ```\n */\nexport async function buildCreateTokenTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;\nexport async function buildCreateTokenTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n  TLifetimeConstraint extends\n    TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"] = TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport async function buildCreateTokenTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput) {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n\n  let metadataAddress = args.mint.address;\n\n  if (args.tokenProgram === TOKEN_PROGRAM_ADDRESS) {\n    metadataAddress = await getTokenMetadataAddress(args.mint);\n\n    // default a reasonably low computeUnitLimit based on simulation data\n    if (!args.computeUnitLimit) {\n      // creating the token's mint is around 3219cu (and stable?)\n      // token metadata is the rest... and fluctuates a lot based on the pda and amount of metadata\n      args.computeUnitLimit = 60_000;\n    }\n  } else if (args.tokenProgram === TOKEN_2022_PROGRAM_ADDRESS) {\n    if (!args.computeUnitLimit) {\n      // token22 token creation, with metadata is (seemingly stable) around 7647cu,\n      // but consume more with more metadata provided\n      args.computeUnitLimit = 10_000;\n    }\n  }\n\n  return createTransaction(\n    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }: typeof args) => ({\n      feePayer,\n      version: version || \"legacy\",\n      computeUnitLimit,\n      computeUnitPrice,\n      latestBlockhash,\n      instructions: getCreateTokenInstructions(\n        (({\n          decimals,\n          mintAuthority,\n          freezeAuthority,\n          updateAuthority,\n          metadata,\n          feePayer,\n          tokenProgram,\n          mint,\n        }: typeof args) => ({\n          mint: mint as KeyPairSigner,\n          feePayer,\n          metadataAddress,\n          metadata,\n          decimals,\n          mintAuthority,\n          freezeAuthority,\n          updateAuthority,\n          tokenProgram,\n        }))(args),\n      ),\n    }))(args),\n  );\n}\n","import type {\n  Address,\n  ITransactionMessageWithFeePayer,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport { checkedAddress, checkedTransactionSigner, createTransaction } from \"../../../core\";\nimport type { FullTransaction, Simplify } from \"../../../types\";\nimport { checkedTokenProgramAddress, getAssociatedTokenAccountAddress } from \"../addresses\";\nimport { getMintTokensInstructions, type GetMintTokensInstructionsArgs } from \"../instructions/mint-tokens\";\nimport type { TransactionBuilderInput } from \"./types\";\n\ntype GetCreateTokenTransactionInput = Simplify<\n  Omit<GetMintTokensInstructionsArgs, \"ata\"> & Partial<Pick<GetMintTokensInstructionsArgs, \"ata\">>\n>;\n\n/**\n * Create a transaction that can mint tokens to the desired wallet/owner,\n * including creating their ATA if it does not exist\n *\n * The transaction has the following defaults:\n * - Default `version` = `legacy`\n * - Default `computeUnitLimit` = `31_000`\n *\n * @remarks\n *\n * - minting without creating the ata is generally < 10_000cu\n * - validating the ata onchain during creation results in a ~5000cu fluctuation\n *\n * @example\n * ```\n * const destination = address(\"nicktrLHhYzLmoVbuZQzHUTicd2sfP571orwo9jfc8c\");\n *\n * const mint = address(...);\n * // or mint can be a keypair from a freshly created token\n *\n * const transaction = await buildMintTokensTransaction({\n *   feePayer: signer,\n *   latestBlockhash,\n *   mint,\n *   mintAuthority: signer,\n *   amount: 1000, // note: be sure to consider the mint's `decimals` value\n *   // if decimals=2 => this will mint 10.00 tokens\n *   // if decimals=4 => this will mint 0.100 tokens\n *   destination,\n *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default\n *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n * });\n * ```\n */\nexport async function buildMintTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;\nexport async function buildMintTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n  TLifetimeConstraint extends\n    TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"] = TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport async function buildMintTokensTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput) {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  if (!args.ata) {\n    args.ata = await getAssociatedTokenAccountAddress(args.mint, args.destination, args.tokenProgram);\n  }\n\n  // default a reasonably low computeUnitLimit based on simulation data\n  if (!args.computeUnitLimit) {\n    /**\n     * for TOKEN_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 9156cu\n     * - when creating the ata: 26535cu\n     *\n     * for TOKEN_2022_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 8978cu\n     * - when creating the ata: 22567cu\n     */\n    args.computeUnitLimit = 31_000;\n  }\n\n  return createTransaction(\n    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }: typeof args) => ({\n      feePayer,\n      version: version || \"legacy\",\n      computeUnitLimit,\n      computeUnitPrice,\n      latestBlockhash,\n      instructions: getMintTokensInstructions(\n        (({ tokenProgram, feePayer, mint, ata, mintAuthority, amount, destination }: typeof args) => ({\n          tokenProgram,\n          feePayer,\n          mint,\n          mintAuthority,\n          ata: ata as Address,\n          amount,\n          destination,\n        }))(args),\n      ),\n    }))(args),\n  );\n}\n","import type {\n  Address,\n  ITransactionMessageWithFeePayer,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport { checkedAddress, checkedTransactionSigner, createTransaction } from \"../../../core\";\nimport type { FullTransaction, Simplify } from \"../../../types\";\nimport { checkedTokenProgramAddress, getAssociatedTokenAccountAddress } from \"../addresses\";\nimport { getTransferTokensInstructions, type GetTransferTokensInstructionsArgs } from \"../instructions\";\nimport type { TransactionBuilderInput } from \"./types\";\n\ntype GetTransferTokensTransactionInput = Simplify<\n  Omit<GetTransferTokensInstructionsArgs, \"sourceAta\" | \"destinationAta\"> &\n    Partial<Pick<GetTransferTokensInstructionsArgs, \"sourceAta\" | \"destinationAta\">>\n>;\n\n/**\n * Create a transaction that can transfer tokens to the desired wallet/owner,\n * including creating their ATA if it does not exist\n *\n * The transaction has the following defaults:\n * - Default `version` = `legacy`\n * - Default `computeUnitLimit` = `31_000`\n *\n * @remarks\n *\n * - transferring without creating the ata is generally < 10_000cu\n * - validating the ata onchain during creation results in a ~15000cu fluctuation\n *\n * @example\n * ```\n * const destination = address(...);\n *\n * const transferTokensTx = await buildTransferTokensTransaction({\n *   feePayer: signer,\n *   latestBlockhash,\n *   mint,\n *   authority: signer,\n *   amount: 900, // note: be sure to consider the mint's `decimals` value\n *   // if decimals=2 => this will transfer 9.00 tokens\n *   // if decimals=4 => this will transfer 0.090 tokens\n *   destination,\n *   // use the correct token program for the `mint`\n *   tokenProgram, // default=TOKEN_PROGRAM_ADDRESS\n *   // default cu limit set to be optimized, but can be overridden here\n *   // computeUnitLimit?: number,\n *   // obtain from your favorite priority fee api\n *   // computeUnitPrice?: number, // no default set\n * });\n * ```\n */\nexport async function buildTransferTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer> & GetTransferTokensTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;\nexport async function buildTransferTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n  TLifetimeConstraint extends\n    TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"] = TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetTransferTokensTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport async function buildTransferTokensTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address | TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetTransferTokensTransactionInput) {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  [args.destinationAta, args.sourceAta] = await Promise.all([\n    !args.destinationAta\n      ? getAssociatedTokenAccountAddress(args.mint, args.destination, args.tokenProgram)\n      : args.destinationAta,\n    !args.sourceAta ? getAssociatedTokenAccountAddress(args.mint, args.authority, args.tokenProgram) : args.sourceAta,\n  ]);\n\n  // default a reasonably low computeUnitLimit based on simulation data\n  if (!args.computeUnitLimit) {\n    /**\n     * for TOKEN_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 6336cu - 12336cu\n     * - when creating the ata: 19428cu - 25034cu\n     *\n     * for TOKEN_2022_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 6157cu - 15157cu\n     * - when creating the ata: 18722cu - 27722cu\n     */\n    args.computeUnitLimit = 31_000;\n  }\n\n  return createTransaction(\n    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }: typeof args) => ({\n      feePayer,\n      version: version || \"legacy\",\n      computeUnitLimit,\n      computeUnitPrice,\n      latestBlockhash,\n      instructions: getTransferTokensInstructions(\n        (({\n          tokenProgram,\n          feePayer,\n          mint,\n          amount,\n          destination,\n          authority,\n          destinationAta,\n          sourceAta,\n        }: typeof args) => ({\n          tokenProgram,\n          feePayer,\n          mint,\n          amount,\n          authority,\n          destination,\n          sourceAta: sourceAta as Address,\n          destinationAta: destinationAta as Address,\n        }))(args),\n      ),\n    }))(args),\n  );\n}\n","/**\n * Converts a UI amount (human-readable) to raw amount (BigInt)\n * @param uiAmount The human-readable token amount (e.g., 1.5)\n * @param decimals The number of decimals for the token\n * @returns BigInt representation of the amount\n */\nexport function tokenUiAmountToAmount(uiAmount: number, decimals: number): bigint {\n  // Handle potential scientific notation by using the built-in toFixed\n  // This ensures we get a decimal string representation without scientific notation\n  const uiAmountStr = uiAmount.toFixed(decimals);\n\n  // Find decimal point position\n  const decimalPointIndex = uiAmountStr.indexOf(\".\");\n\n  let wholeNumber: string;\n  let fractionalPart: string;\n\n  if (decimalPointIndex === -1) {\n    // No decimal point\n    wholeNumber = uiAmountStr;\n    fractionalPart = \"\";\n  } else {\n    wholeNumber = uiAmountStr.substring(0, decimalPointIndex);\n    fractionalPart = uiAmountStr.substring(decimalPointIndex + 1);\n  }\n\n  // Pad or truncate fractional part based on decimals\n  if (fractionalPart.length > decimals) {\n    fractionalPart = fractionalPart.substring(0, decimals);\n  } else {\n    fractionalPart = fractionalPart.padEnd(decimals, \"0\");\n  }\n\n  // Combine and convert to BigInt, stripping any potential leading zeros\n  const rawAmountStr = wholeNumber + fractionalPart;\n  if (rawAmountStr.replace(/0/g, \"\") === \"\") {\n    return BigInt(0);\n  }\n  return BigInt(rawAmountStr);\n}\n\n/**\n * Converts a raw amount (BigInt) to UI amount (human-readable)\n * @param amount The raw token amount as BigInt\n * @param decimals The number of decimals for the token\n * @returns UI representation of the amount as a number\n */\nexport function tokenAmountToUiAmount(amount: bigint, decimals: number): number {\n  // Convert to string for easier manipulation\n  let amountStr = amount.toString();\n\n  // Pad with leading zeros if necessary\n  if (amountStr.length <= decimals) {\n    amountStr = amountStr.padStart(decimals + 1, \"0\");\n  }\n\n  // Split into whole and fractional parts\n  const wholePartLength = amountStr.length - decimals;\n  const wholePart = amountStr.substring(0, wholePartLength);\n  const fractionalPart = amountStr.substring(wholePartLength);\n\n  // Combine with decimal point\n  const uiAmountStr = `${wholePart || \"0\"}.${fractionalPart}`;\n\n  // Convert back to number\n  return parseFloat(uiAmountStr);\n}\n"]}